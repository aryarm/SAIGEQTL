diff --git a/R/Geno.R b/R/Geno.R
index 6023899d..f2863cfa 100644
--- a/R/Geno.R
+++ b/R/Geno.R
@@ -107,6 +107,9 @@ setGenoInput = function(bgenFile = "",
 		 AlleleOrder = NULL,
 		 sampleInModel = NULL)
 {
+  set_dup_sample_index_inR(sampleInModel)
+  sampleInModel = unique(sampleInModel)
+  
 
   dosageFileType = checkGenoInput(bgenFile = bgenFile,
                  bgenFileIndex = bgenFileIndex,
diff --git a/R/NB.log b/R/NB.log
new file mode 100644
index 00000000..d4999c90
--- /dev/null
+++ b/R/NB.log
@@ -0,0 +1 @@
+Fatal error: cannot open file 'step1_fitNULLGLMM_1.1.3_Poisson.R': No such file or directory
diff --git a/R/NegBin.r b/R/NegBin.r
new file mode 100644
index 00000000..48058aec
--- /dev/null
+++ b/R/NegBin.r
@@ -0,0 +1,57 @@
+
+# from MASS
+
+NegBin <- function (theta = 5, link = "log")
+{
+  linktemp <- substitute(link)
+  if (!is.character(linktemp))
+    linktemp <- deparse(linktemp)
+  if (linktemp %in% c("log", "identity", "sqrt"))
+    stats <- make.link(linktemp)
+  else if (is.character(link)) {
+    stats <- make.link(link)
+    linktemp <- link
+  }
+  else {
+    if (inherits(link, "link-glm")) {
+      stats <- link
+      if (!is.null(stats$name))
+        linktemp <- stats$name
+    }
+    else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"",
+                       linktemp))
+  }
+  .Theta <- theta
+  env <- new.env(parent = .GlobalEnv)
+  assign(".Theta", theta, envir = env)
+  variance <- function(mu) mu + mu^2/.Theta
+  validmu <- function(mu) all(mu > 0)
+  dev.resids <- function(y, mu, wt) 2 * wt * (y * log(pmax(1, y)/mu) - (y + .Theta) * log((y + .Theta)/(mu + .Theta)))
+  aic <- function(y, n, mu, wt, dev) {
+    term <- (y + .Theta) * log(mu + .Theta) - y * log(mu) +
+      lgamma(y + 1) - .Theta * log(.Theta) + lgamma(.Theta) -
+      lgamma(.Theta + y)
+    2 * sum(term * wt)
+  }
+  initialize <- expression({
+    if (any(y < 0)) stop("negative values not allowed for the negative binomial family")
+    n <- rep(1, nobs)
+    mustart <- y + (y == 0)/6
+  })
+  simfun <- function(object, nsim) {
+    ftd <- fitted(object)
+    rnegbin(nsim * length(ftd), ftd, .Theta)
+  }
+  environment(variance) <- environment(validmu) <- environment(dev.resids) <- environment(aic) <- environment(simfun) <- env
+  famname <- paste("NegBin(", format(round(theta, 4)), ")", sep = "")
+  structure(list(family = famname, link = linktemp, linkfun = stats$linkfun,
+                 linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids,
+                 aic = aic, mu.eta = stats$mu.eta, initialize = initialize,
+                 validmu = validmu, valideta = stats$valideta, simulate = simfun, theta = .Theta),
+                 class = "family")
+}
+
+#*******************************************************************************
+
+
+
diff --git a/R/RcppExports.R b/R/RcppExports.R
index 09687bdb..0524c986 100644
--- a/R/RcppExports.R
+++ b/R/RcppExports.R
@@ -57,12 +57,8 @@ setVCFobjInCPP <- function(t_vcfFileName, t_vcfFileIndex, t_vcfField, t_SampleIn
     invisible(.Call('_SAIGE_setVCFobjInCPP', PACKAGE = 'SAIGE', t_vcfFileName, t_vcfFileIndex, t_vcfField, t_SampleInModel))
 }
 
-setSAIGEobjInCPP <- function(t_XVX, t_XXVX_inv, t_XV, t_XVX_inv_XV, t_Sigma_iXXSigma_iX, t_X, t_S_a, t_res, t_mu2, t_mu, t_varRatio_sparse, t_varRatio_null, t_cateVarRatioMinMACVecExclude, t_cateVarRatioMaxMACVecInclude, t_SPA_Cutoff, t_tauvec, t_traitType, t_y, t_impute_method, t_flagSparseGRM, t_isFastTest, t_pval_cutoff_for_fastTest, t_locationMat, t_valueVec, t_dimNum, t_isCondition, t_condition_genoIndex, t_is_Firth_beta, t_pCutoffforFirth, t_offset, t_resout) {
-    invisible(.Call('_SAIGE_setSAIGEobjInCPP', PACKAGE = 'SAIGE', t_XVX, t_XXVX_inv, t_XV, t_XVX_inv_XV, t_Sigma_iXXSigma_iX, t_X, t_S_a, t_res, t_mu2, t_mu, t_varRatio_sparse, t_varRatio_null, t_cateVarRatioMinMACVecExclude, t_cateVarRatioMaxMACVecInclude, t_SPA_Cutoff, t_tauvec, t_traitType, t_y, t_impute_method, t_flagSparseGRM, t_isFastTest, t_pval_cutoff_for_fastTest, t_locationMat, t_valueVec, t_dimNum, t_isCondition, t_condition_genoIndex, t_is_Firth_beta, t_pCutoffforFirth, t_offset, t_resout))
-}
-
-setSparseSigmaInCPP <- function(r, t_locationMatinR, t_valueVecinR) {
-    invisible(.Call('_SAIGE_setSparseSigmaInCPP', PACKAGE = 'SAIGE', r, t_locationMatinR, t_valueVecinR))
+setSAIGEobjInCPP <- function(t_XVX, t_XXVX_inv, t_XV, t_XVX_inv_XV, t_Sigma_iXXSigma_iX, t_X, t_S_a, t_res, t_mu2, t_mu, t_varRatio_sparse, t_varRatio_null, t_cateVarRatioMinMACVecExclude, t_cateVarRatioMaxMACVecInclude, t_SPA_Cutoff, t_tauvec, t_traitType, t_y, t_impute_method, t_flagSparseGRM, t_isFastTest, t_pval_cutoff_for_fastTest, t_isCondition, t_condition_genoIndex, t_is_Firth_beta, t_pCutoffforFirth, t_offset, t_resout, t_SigmaMat_sp) {
+    invisible(.Call('_SAIGE_setSAIGEobjInCPP', PACKAGE = 'SAIGE', t_XVX, t_XXVX_inv, t_XV, t_XVX_inv_XV, t_Sigma_iXXSigma_iX, t_X, t_S_a, t_res, t_mu2, t_mu, t_varRatio_sparse, t_varRatio_null, t_cateVarRatioMinMACVecExclude, t_cateVarRatioMaxMACVecInclude, t_SPA_Cutoff, t_tauvec, t_traitType, t_y, t_impute_method, t_flagSparseGRM, t_isFastTest, t_pval_cutoff_for_fastTest, t_isCondition, t_condition_genoIndex, t_is_Firth_beta, t_pCutoffforFirth, t_offset, t_resout, t_SigmaMat_sp))
 }
 
 RegionSetUpConditional_binary_InCPP <- function(t_weight_cond) {
@@ -125,360 +121,308 @@ copy_singleInGroup <- function() {
     invisible(.Call('_SAIGE_copy_singleInGroup', PACKAGE = 'SAIGE'))
 }
 
-addNewKat <- function(t_Kmat) {
-    invisible(.Call('_SAIGE_addNewKat', PACKAGE = 'SAIGE', t_Kmat))
-}
-
-getProdTauKmat <- function(tauVec) {
-    .Call('_SAIGE_getProdTauKmat', PACKAGE = 'SAIGE', tauVec)
-}
-
-getMeanDiagofKmat <- function() {
-    .Call('_SAIGE_getMeanDiagofKmat', PACKAGE = 'SAIGE')
-}
-
-get_numofV <- function() {
-    .Call('_SAIGE_get_numofV', PACKAGE = 'SAIGE')
-}
-
-set_longlVar_vec <- function(longlVec) {
-    invisible(.Call('_SAIGE_set_longlVar_vec', PACKAGE = 'SAIGE', longlVec))
-}
-
-set_covarianceidx_Mat <- function() {
-    .Call('_SAIGE_set_covarianceidx_Mat', PACKAGE = 'SAIGE')
-}
-
-set_Vmat_vec_longlVar <- function() {
-    invisible(.Call('_SAIGE_set_Vmat_vec_longlVar', PACKAGE = 'SAIGE'))
+set_dup_sample_index <- function(t_dup_sample_Index) {
+    invisible(.Call('_SAIGE_set_dup_sample_index', PACKAGE = 'SAIGE', t_dup_sample_Index))
 }
 
-closeGenoFile_plink <- function() {
-    invisible(.Call('_SAIGE_closeGenoFile_plink', PACKAGE = 'SAIGE'))
-}
-
-gettotalMarker <- function() {
-    .Call('_SAIGE_gettotalMarker', PACKAGE = 'SAIGE')
-}
-
-getAlleleFreqVec <- function() {
-    .Call('_SAIGE_getAlleleFreqVec', PACKAGE = 'SAIGE')
-}
-
-getMACVec <- function() {
-    .Call('_SAIGE_getMACVec', PACKAGE = 'SAIGE')
-}
-
-getMACVec_forVarRatio <- function() {
-    .Call('_SAIGE_getMACVec_forVarRatio', PACKAGE = 'SAIGE')
-}
-
-getIndexVec_forVarRatio <- function() {
-    .Call('_SAIGE_getIndexVec_forVarRatio', PACKAGE = 'SAIGE')
-}
-
-getIsVarRatioGeno <- function() {
-    .Call('_SAIGE_getIsVarRatioGeno', PACKAGE = 'SAIGE')
-}
-
-getSubMarkerIndex <- function() {
-    .Call('_SAIGE_getSubMarkerIndex', PACKAGE = 'SAIGE')
+setupSparseGRM_new <- function(t_spGRM) {
+    invisible(.Call('_SAIGE_setupSparseGRM_new', PACKAGE = 'SAIGE', t_spGRM))
 }
 
-getQCdMarkerIndex <- function() {
-    .Call('_SAIGE_getQCdMarkerIndex', PACKAGE = 'SAIGE')
+set_I_longl_mat <- function(t_Ilongmat, t_I_longl_vec) {
+    invisible(.Call('_SAIGE_set_I_longl_mat', PACKAGE = 'SAIGE', t_Ilongmat, t_I_longl_vec))
 }
 
-getSubMarkerNum <- function() {
-    .Call('_SAIGE_getSubMarkerNum', PACKAGE = 'SAIGE')
+set_T_longl_mat <- function(t_Tlongmat, t_T_longl_vec) {
+    invisible(.Call('_SAIGE_set_T_longl_mat', PACKAGE = 'SAIGE', t_Tlongmat, t_T_longl_vec))
 }
 
-getNnomissingOut <- function() {
-    .Call('_SAIGE_getNnomissingOut', PACKAGE = 'SAIGE')
+getCrossprodMatAndKin <- function(bVec, LOCO) {
+    .Call('_SAIGE_getCrossprodMatAndKin', PACKAGE = 'SAIGE', bVec, LOCO)
 }
 
-getMsub_MAFge_minMAFtoConstructGRM <- function() {
-    .Call('_SAIGE_getMsub_MAFge_minMAFtoConstructGRM', PACKAGE = 'SAIGE')
+getCrossprod_multiV <- function(bVec, wVec, tauVec, LOCO) {
+    .Call('_SAIGE_getCrossprod_multiV', PACKAGE = 'SAIGE', bVec, wVec, tauVec, LOCO)
 }
 
-getMsub_MAFge_minMAFtoConstructGRM_singleChr <- function() {
-    .Call('_SAIGE_getMsub_MAFge_minMAFtoConstructGRM_singleChr', PACKAGE = 'SAIGE')
+getDiagOfSigma_multiV <- function(wVec, tauVec, LOCO) {
+    .Call('_SAIGE_getDiagOfSigma_multiV', PACKAGE = 'SAIGE', wVec, tauVec, LOCO)
 }
 
-Get_MultiMarkersBySample_StdGeno_Mat <- function() {
-    invisible(.Call('_SAIGE_Get_MultiMarkersBySample_StdGeno_Mat', PACKAGE = 'SAIGE'))
+gen_sp_Sigma_multiV <- function(wVec, tauVec) {
+    invisible(.Call('_SAIGE_gen_sp_Sigma_multiV', PACKAGE = 'SAIGE', wVec, tauVec))
 }
 
-Get_MultiMarkersBySample_StdGeno <- function(markerIndexVec, stdGenoMultiMarkers) {
-    invisible(.Call('_SAIGE_Get_MultiMarkersBySample_StdGeno', PACKAGE = 'SAIGE', markerIndexVec, stdGenoMultiMarkers))
+getPCG1ofSigmaAndVector_multiV <- function(wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO) {
+    .Call('_SAIGE_getPCG1ofSigmaAndVector_multiV', PACKAGE = 'SAIGE', wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO)
 }
 
-parallelCrossProd <- function(bVec) {
-    .Call('_SAIGE_parallelCrossProd', PACKAGE = 'SAIGE', bVec)
+set_seed <- function(seed) {
+    invisible(.Call('_SAIGE_set_seed', PACKAGE = 'SAIGE', seed))
 }
 
-innerProductFun <- function(x, y) {
-    .Call('_SAIGE_innerProductFun', PACKAGE = 'SAIGE', x, y)
+nb <- function(n) {
+    .Call('_SAIGE_nb', PACKAGE = 'SAIGE', n)
 }
 
-parallelCrossProd_full <- function(bVec, markerNum) {
-    .Call('_SAIGE_parallelCrossProd_full', PACKAGE = 'SAIGE', bVec, markerNum)
+setStartEndIndex <- function(startIndex, endIndex, chromIndex) {
+    invisible(.Call('_SAIGE_setStartEndIndex', PACKAGE = 'SAIGE', startIndex, endIndex, chromIndex))
 }
 
-parallelCrossProd_LOCO <- function(bVec) {
-    .Call('_SAIGE_parallelCrossProd_LOCO', PACKAGE = 'SAIGE', bVec)
+setStartEndIndexVec <- function(startIndex_vec, endIndex_vec) {
+    invisible(.Call('_SAIGE_setStartEndIndexVec', PACKAGE = 'SAIGE', startIndex_vec, endIndex_vec))
 }
 
-setupSparseGRM <- function(r, locationMatinR, valueVecinR) {
-    invisible(.Call('_SAIGE_setupSparseGRM', PACKAGE = 'SAIGE', r, locationMatinR, valueVecinR))
+calCV <- function(xVec) {
+    .Call('_SAIGE_calCV', PACKAGE = 'SAIGE', xVec)
 }
 
-setupSparseGRM_new <- function(t_spGRM) {
-    invisible(.Call('_SAIGE_setupSparseGRM_new', PACKAGE = 'SAIGE', t_spGRM))
+getSigma_X_multiV <- function(wVec, tauVec, Xmat, maxiterPCG, tolPCG, LOCO) {
+    .Call('_SAIGE_getSigma_X_multiV', PACKAGE = 'SAIGE', wVec, tauVec, Xmat, maxiterPCG, tolPCG, LOCO)
 }
 
-getCrossprodMatAndKin <- function(bVec) {
-    .Call('_SAIGE_getCrossprodMatAndKin', PACKAGE = 'SAIGE', bVec)
+getSigma_G_multiV <- function(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO) {
+    .Call('_SAIGE_getSigma_G_multiV', PACKAGE = 'SAIGE', wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO)
 }
 
-getCrossprodMatAndKin_LOCO <- function(bVec) {
-    .Call('_SAIGE_getCrossprodMatAndKin_LOCO', PACKAGE = 'SAIGE', bVec)
+fitglmmaiRPCG_multiV <- function(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, tol, traceCVcutoff, LOCO) {
+    .Call('_SAIGE_fitglmmaiRPCG_multiV', PACKAGE = 'SAIGE', Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, tol, traceCVcutoff, LOCO)
 }
 
-printComb <- function(N) {
-    invisible(.Call('_SAIGE_printComb', PACKAGE = 'SAIGE', N))
+getMeanDiagofKmat <- function(LOCO) {
+    .Call('_SAIGE_getMeanDiagofKmat', PACKAGE = 'SAIGE', LOCO)
 }
 
-findIndiceRelatedSample <- function() {
-    invisible(.Call('_SAIGE_findIndiceRelatedSample', PACKAGE = 'SAIGE'))
+getAIScore_multiV <- function(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO) {
+    .Call('_SAIGE_getAIScore_multiV', PACKAGE = 'SAIGE', Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO)
 }
 
-parallelcalsparseGRM <- function(GRMvec) {
-    invisible(.Call('_SAIGE_parallelcalsparseGRM', PACKAGE = 'SAIGE', GRMvec))
+GetTrace_multiV <- function(Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO) {
+    .Call('_SAIGE_GetTrace_multiV', PACKAGE = 'SAIGE', Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO)
 }
 
-parallelsumTwoVec <- function(x) {
-    invisible(.Call('_SAIGE_parallelsumTwoVec', PACKAGE = 'SAIGE', x))
+getCoefficients_multiV <- function(Yvec, Xmat, wVec, tauVec, maxiterPCG, tolPCG, LOCO) {
+    .Call('_SAIGE_getCoefficients_multiV', PACKAGE = 'SAIGE', Yvec, Xmat, wVec, tauVec, maxiterPCG, tolPCG, LOCO)
 }
 
-setgeno <- function(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne) {
-    invisible(.Call('_SAIGE_setgeno', PACKAGE = 'SAIGE', bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne))
+setminMAC_VarianceRatio <- function(t_minMACVarRatio, t_maxMACVarRatio, t_isVarianceRatioinGeno) {
+    invisible(.Call('_SAIGE_setminMAC_VarianceRatio', PACKAGE = 'SAIGE', t_minMACVarRatio, t_maxMACVarRatio, t_isVarianceRatioinGeno))
 }
 
-Get_OneSNP_Geno <- function(SNPIdx) {
-    .Call('_SAIGE_Get_OneSNP_Geno', PACKAGE = 'SAIGE', SNPIdx)
+get_GRMdiagVec <- function() {
+    .Call('_SAIGE_get_GRMdiagVec', PACKAGE = 'SAIGE')
 }
 
-Get_OneSNP_Geno_forVarRatio <- function(SNPIdx) {
-    .Call('_SAIGE_Get_OneSNP_Geno_forVarRatio', PACKAGE = 'SAIGE', SNPIdx)
+setminMAFforGRM <- function(minMAFforGRM) {
+    invisible(.Call('_SAIGE_setminMAFforGRM', PACKAGE = 'SAIGE', minMAFforGRM))
 }
 
-Get_OneSNP_StdGeno <- function(SNPIdx) {
-    .Call('_SAIGE_Get_OneSNP_StdGeno', PACKAGE = 'SAIGE', SNPIdx)
+setmaxMissingRateforGRM <- function(maxMissingforGRM) {
+    invisible(.Call('_SAIGE_setmaxMissingRateforGRM', PACKAGE = 'SAIGE', maxMissingforGRM))
 }
 
-getDiagOfSigma_multiV <- function(wVec, tauVec, LOCO) {
-    .Call('_SAIGE_getDiagOfSigma_multiV', PACKAGE = 'SAIGE', wVec, tauVec, LOCO)
+set_Diagof_StdGeno_LOCO <- function() {
+    invisible(.Call('_SAIGE_set_Diagof_StdGeno_LOCO', PACKAGE = 'SAIGE'))
 }
 
-getCrossprod_multiV <- function(bVec, wVec, tauVec, LOCO) {
-    .Call('_SAIGE_getCrossprod_multiV', PACKAGE = 'SAIGE', bVec, wVec, tauVec, LOCO)
+get_DiagofKin <- function() {
+    .Call('_SAIGE_get_DiagofKin', PACKAGE = 'SAIGE')
 }
 
-gen_sp_GRM <- function() {
-    .Call('_SAIGE_gen_sp_GRM', PACKAGE = 'SAIGE')
+parallelCrossProd_usingSubMarker <- function(bVec) {
+    .Call('_SAIGE_parallelCrossProd_usingSubMarker', PACKAGE = 'SAIGE', bVec)
 }
 
-gen_sp_Sigma_multiV <- function(wVec, tauVec) {
-    .Call('_SAIGE_gen_sp_Sigma_multiV', PACKAGE = 'SAIGE', wVec, tauVec)
+getCrossprodMatAndKin_usingSubMarker <- function(bVec) {
+    .Call('_SAIGE_getCrossprodMatAndKin_usingSubMarker', PACKAGE = 'SAIGE', bVec)
 }
 
-gen_spsolve_v4_multiV <- function(wVec, tauVec, yvec) {
-    .Call('_SAIGE_gen_spsolve_v4_multiV', PACKAGE = 'SAIGE', wVec, tauVec, yvec)
+parallelInnerProduct <- function(x, y) {
+    .Call('_SAIGE_parallelInnerProduct', PACKAGE = 'SAIGE', x, y)
 }
 
-setisUsePrecondM <- function(isUseSparseSigmaforPCG) {
-    invisible(.Call('_SAIGE_setisUsePrecondM', PACKAGE = 'SAIGE', isUseSparseSigmaforPCG))
+createSparseKin <- function(markerIndexVec, relatednessCutoff, wVec, tauVec) {
+    .Call('_SAIGE_createSparseKin', PACKAGE = 'SAIGE', markerIndexVec, relatednessCutoff, wVec, tauVec)
 }
 
-setisUseSparseSigmaforInitTau <- function(isUseSparseSigmaforInitTau0) {
-    invisible(.Call('_SAIGE_setisUseSparseSigmaforInitTau', PACKAGE = 'SAIGE', isUseSparseSigmaforInitTau0))
+refineKin <- function(relatednessCutoff) {
+    .Call('_SAIGE_refineKin', PACKAGE = 'SAIGE', relatednessCutoff)
 }
 
-setisUseSparseSigmaforNullModelFitting <- function(isUseSparseSigmaforModelFitting0) {
-    invisible(.Call('_SAIGE_setisUseSparseSigmaforNullModelFitting', PACKAGE = 'SAIGE', isUseSparseSigmaforModelFitting0))
+getColfromStdGenoMultiMarkersMat <- function(a) {
+    .Call('_SAIGE_getColfromStdGenoMultiMarkersMat', PACKAGE = 'SAIGE', a)
 }
 
-getPCG1ofSigmaAndVector_multiV <- function(wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO) {
-    .Call('_SAIGE_getPCG1ofSigmaAndVector_multiV', PACKAGE = 'SAIGE', wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO)
+getNColStdGenoMultiMarkersMat <- function() {
+    .Call('_SAIGE_getNColStdGenoMultiMarkersMat', PACKAGE = 'SAIGE')
 }
 
-set_seed <- function(seed) {
-    invisible(.Call('_SAIGE_set_seed', PACKAGE = 'SAIGE', seed))
+getNRowStdGenoMultiMarkersMat <- function() {
+    .Call('_SAIGE_getNRowStdGenoMultiMarkersMat', PACKAGE = 'SAIGE')
 }
 
-nb <- function(n) {
-    .Call('_SAIGE_nb', PACKAGE = 'SAIGE', n)
+setSubMarkerIndex <- function(subMarkerIndexRandom) {
+    invisible(.Call('_SAIGE_setSubMarkerIndex', PACKAGE = 'SAIGE', subMarkerIndexRandom))
 }
 
-setStartEndIndex <- function(startIndex, endIndex, chromIndex) {
-    invisible(.Call('_SAIGE_setStartEndIndex', PACKAGE = 'SAIGE', startIndex, endIndex, chromIndex))
+setRelatednessCutoff <- function(a) {
+    invisible(.Call('_SAIGE_setRelatednessCutoff', PACKAGE = 'SAIGE', a))
 }
 
-setStartEndIndexVec <- function(startIndex_vec, endIndex_vec) {
-    invisible(.Call('_SAIGE_setStartEndIndexVec', PACKAGE = 'SAIGE', startIndex_vec, endIndex_vec))
+innerProduct <- function(x, y) {
+    .Call('_SAIGE_innerProduct', PACKAGE = 'SAIGE', x, y)
 }
 
-calCV <- function(xVec) {
-    .Call('_SAIGE_calCV', PACKAGE = 'SAIGE', xVec)
+getDiagOfSigma_noV <- function(wVec, tauVec, LOCO) {
+    .Call('_SAIGE_getDiagOfSigma_noV', PACKAGE = 'SAIGE', wVec, tauVec, LOCO)
 }
 
-getSigma_X_multiV <- function(wVec, tauVec, Xmat, maxiterPCG, tolPCG, LOCO) {
-    .Call('_SAIGE_getSigma_X_multiV', PACKAGE = 'SAIGE', wVec, tauVec, Xmat, maxiterPCG, tolPCG, LOCO)
+getCrossprod_noV <- function(bVec, wVec, tauVec, LOCO) {
+    .Call('_SAIGE_getCrossprod_noV', PACKAGE = 'SAIGE', bVec, wVec, tauVec, LOCO)
 }
 
-getSigma_G_multiV <- function(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO) {
-    .Call('_SAIGE_getSigma_G_multiV', PACKAGE = 'SAIGE', wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO)
+getPCG1ofSigmaAndVector_noV <- function(wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO) {
+    .Call('_SAIGE_getPCG1ofSigmaAndVector_noV', PACKAGE = 'SAIGE', wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO)
 }
 
-parallelCrossProd_usingSubMarker <- function(bVec) {
-    .Call('_SAIGE_parallelCrossProd_usingSubMarker', PACKAGE = 'SAIGE', bVec)
+getSigma_G_noV <- function(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO) {
+    .Call('_SAIGE_getSigma_G_noV', PACKAGE = 'SAIGE', wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO)
 }
 
-getCrossprodMatAndKin_usingSubMarker <- function(bVec) {
-    .Call('_SAIGE_getCrossprodMatAndKin_usingSubMarker', PACKAGE = 'SAIGE', bVec)
+set_useGRMtoFitNULL <- function(useGRMtoFitNULL) {
+    invisible(.Call('_SAIGE_set_useGRMtoFitNULL', PACKAGE = 'SAIGE', useGRMtoFitNULL))
 }
 
-parallelInnerProduct <- function(x, y) {
-    .Call('_SAIGE_parallelInnerProduct', PACKAGE = 'SAIGE', x, y)
+set_isSparseGRM <- function(t_isSparseGRM) {
+    invisible(.Call('_SAIGE_set_isSparseGRM', PACKAGE = 'SAIGE', t_isSparseGRM))
 }
 
-calGRMValueforSamplePair <- function(sampleidsVec) {
-    .Call('_SAIGE_calGRMValueforSamplePair', PACKAGE = 'SAIGE', sampleidsVec)
+set_store_sigma <- function(isstoreSigma) {
+    invisible(.Call('_SAIGE_set_store_sigma', PACKAGE = 'SAIGE', isstoreSigma))
 }
 
-createSparseKin <- function(markerIndexVec, relatednessCutoff, wVec, tauVec) {
-    .Call('_SAIGE_createSparseKin', PACKAGE = 'SAIGE', markerIndexVec, relatednessCutoff, wVec, tauVec)
+set_num_Kmat <- function(t_num_Kmat) {
+    invisible(.Call('_SAIGE_set_num_Kmat', PACKAGE = 'SAIGE', t_num_Kmat))
 }
 
-getColfromStdGenoMultiMarkersMat <- function(a) {
-    .Call('_SAIGE_getColfromStdGenoMultiMarkersMat', PACKAGE = 'SAIGE', a)
+get_numofV <- function() {
+    .Call('_SAIGE_get_numofV', PACKAGE = 'SAIGE')
 }
 
-getNColStdGenoMultiMarkersMat <- function() {
-    .Call('_SAIGE_getNColStdGenoMultiMarkersMat', PACKAGE = 'SAIGE')
+set_covarianceidx_Mat <- function() {
+    .Call('_SAIGE_set_covarianceidx_Mat', PACKAGE = 'SAIGE')
 }
 
-getNRowStdGenoMultiMarkersMat <- function() {
-    .Call('_SAIGE_getNRowStdGenoMultiMarkersMat', PACKAGE = 'SAIGE')
+closeGenoFile_plink <- function() {
+    invisible(.Call('_SAIGE_closeGenoFile_plink', PACKAGE = 'SAIGE'))
 }
 
-setSubMarkerIndex <- function(subMarkerIndexRandom) {
-    invisible(.Call('_SAIGE_setSubMarkerIndex', PACKAGE = 'SAIGE', subMarkerIndexRandom))
+gettotalMarker <- function() {
+    .Call('_SAIGE_gettotalMarker', PACKAGE = 'SAIGE')
 }
 
-setRelatednessCutoff <- function(a) {
-    invisible(.Call('_SAIGE_setRelatednessCutoff', PACKAGE = 'SAIGE', a))
+getAlleleFreqVec <- function() {
+    .Call('_SAIGE_getAlleleFreqVec', PACKAGE = 'SAIGE')
 }
 
-innerProduct <- function(x, y) {
-    .Call('_SAIGE_innerProduct', PACKAGE = 'SAIGE', x, y)
+getMACVec <- function() {
+    .Call('_SAIGE_getMACVec', PACKAGE = 'SAIGE')
 }
 
-refineKin <- function(relatednessCutoff) {
-    .Call('_SAIGE_refineKin', PACKAGE = 'SAIGE', relatednessCutoff)
+getMACVec_forVarRatio <- function() {
+    .Call('_SAIGE_getMACVec_forVarRatio', PACKAGE = 'SAIGE')
 }
 
-shortenList <- function(iMat, kinValueVecTemp, relatednessCutoff, wVec, tauVec) {
-    .Call('_SAIGE_shortenList', PACKAGE = 'SAIGE', iMat, kinValueVecTemp, relatednessCutoff, wVec, tauVec)
+getIndexVec_forVarRatio <- function() {
+    .Call('_SAIGE_getIndexVec_forVarRatio', PACKAGE = 'SAIGE')
 }
 
-testTime <- function(i, m_bVec) {
-    .Call('_SAIGE_testTime', PACKAGE = 'SAIGE', i, m_bVec)
+getIsVarRatioGeno <- function() {
+    .Call('_SAIGE_getIsVarRatioGeno', PACKAGE = 'SAIGE')
 }
 
-gen_sp_v2 <- function(a) {
-    .Call('_SAIGE_gen_sp_v2', PACKAGE = 'SAIGE', a)
+getSubMarkerIndex <- function() {
+    .Call('_SAIGE_getSubMarkerIndex', PACKAGE = 'SAIGE')
 }
 
-gen_spsolve_v2 <- function(a) {
-    .Call('_SAIGE_gen_spsolve_v2', PACKAGE = 'SAIGE', a)
+getQCdMarkerIndex <- function() {
+    .Call('_SAIGE_getQCdMarkerIndex', PACKAGE = 'SAIGE')
 }
 
-gen_spsolve_inR <- function(a, y) {
-    .Call('_SAIGE_gen_spsolve_inR', PACKAGE = 'SAIGE', a, y)
+getSubMarkerNum <- function() {
+    .Call('_SAIGE_getSubMarkerNum', PACKAGE = 'SAIGE')
 }
 
-get_DiagofKin <- function() {
-    .Call('_SAIGE_get_DiagofKin', PACKAGE = 'SAIGE')
+getNnomissingOut <- function() {
+    .Call('_SAIGE_getNnomissingOut', PACKAGE = 'SAIGE')
 }
 
-getstdgenoVectorScalorProduct <- function(jth, y, prodVec) {
-    invisible(.Call('_SAIGE_getstdgenoVectorScalorProduct', PACKAGE = 'SAIGE', jth, y, prodVec))
+getMsub_MAFge_minMAFtoConstructGRM <- function() {
+    .Call('_SAIGE_getMsub_MAFge_minMAFtoConstructGRM', PACKAGE = 'SAIGE')
 }
 
-sumPz <- function(Pbvec, Ubvec, mmchunksize) {
-    invisible(.Call('_SAIGE_sumPz', PACKAGE = 'SAIGE', Pbvec, Ubvec, mmchunksize))
+getMsub_MAFge_minMAFtoConstructGRM_singleChr <- function() {
+    .Call('_SAIGE_getMsub_MAFge_minMAFtoConstructGRM_singleChr', PACKAGE = 'SAIGE')
 }
 
-mmGetPb_MbyN <- function(cthchunk, mmchunksize, bvec, Pbvec, kinbvec) {
-    invisible(.Call('_SAIGE_mmGetPb_MbyN', PACKAGE = 'SAIGE', cthchunk, mmchunksize, bvec, Pbvec, kinbvec))
+Get_MultiMarkersBySample_StdGeno_Mat <- function() {
+    invisible(.Call('_SAIGE_Get_MultiMarkersBySample_StdGeno_Mat', PACKAGE = 'SAIGE'))
 }
 
-mmGetPb_NbyM <- function(cthchunk, mmchunksize, bvec, Pbvec) {
-    invisible(.Call('_SAIGE_mmGetPb_NbyM', PACKAGE = 'SAIGE', cthchunk, mmchunksize, bvec, Pbvec))
+Get_MultiMarkersBySample_StdGeno <- function(markerIndexVec, stdGenoMultiMarkers) {
+    invisible(.Call('_SAIGE_Get_MultiMarkersBySample_StdGeno', PACKAGE = 'SAIGE', markerIndexVec, stdGenoMultiMarkers))
 }
 
-muliplyMailman <- function(bvec, Gbvec, kinbvec) {
-    invisible(.Call('_SAIGE_muliplyMailman', PACKAGE = 'SAIGE', bvec, Gbvec, kinbvec))
+parallelCrossProd <- function(bVec) {
+    .Call('_SAIGE_parallelCrossProd', PACKAGE = 'SAIGE', bVec)
 }
 
-muliplyMailman_NbyM <- function(bvec, tGbvec) {
-    invisible(.Call('_SAIGE_muliplyMailman_NbyM', PACKAGE = 'SAIGE', bvec, tGbvec))
+innerProductFun <- function(x, y) {
+    .Call('_SAIGE_innerProductFun', PACKAGE = 'SAIGE', x, y)
 }
 
-freqOverStd <- function(freqOverStdVec) {
-    invisible(.Call('_SAIGE_freqOverStd', PACKAGE = 'SAIGE', freqOverStdVec))
+parallelCrossProd_full <- function(bVec, markerNum) {
+    .Call('_SAIGE_parallelCrossProd_full', PACKAGE = 'SAIGE', bVec, markerNum)
 }
 
-getCrossprodMatAndKin_mailman <- function(bVec) {
-    .Call('_SAIGE_getCrossprodMatAndKin_mailman', PACKAGE = 'SAIGE', bVec)
+parallelCrossProd_LOCO <- function(bVec) {
+    .Call('_SAIGE_parallelCrossProd_LOCO', PACKAGE = 'SAIGE', bVec)
 }
 
-get_GRMdiagVec <- function() {
-    .Call('_SAIGE_get_GRMdiagVec', PACKAGE = 'SAIGE')
+printComb <- function(N) {
+    invisible(.Call('_SAIGE_printComb', PACKAGE = 'SAIGE', N))
 }
 
-setminMAFforGRM <- function(minMAFforGRM) {
-    invisible(.Call('_SAIGE_setminMAFforGRM', PACKAGE = 'SAIGE', minMAFforGRM))
+findIndiceRelatedSample <- function() {
+    invisible(.Call('_SAIGE_findIndiceRelatedSample', PACKAGE = 'SAIGE'))
 }
 
-setmaxMissingRateforGRM <- function(maxMissingforGRM) {
-    invisible(.Call('_SAIGE_setmaxMissingRateforGRM', PACKAGE = 'SAIGE', maxMissingforGRM))
+parallelcalsparseGRM <- function(GRMvec) {
+    invisible(.Call('_SAIGE_parallelcalsparseGRM', PACKAGE = 'SAIGE', GRMvec))
 }
 
-set_Diagof_StdGeno_LOCO <- function() {
-    invisible(.Call('_SAIGE_set_Diagof_StdGeno_LOCO', PACKAGE = 'SAIGE'))
+parallelsumTwoVec <- function(x) {
+    invisible(.Call('_SAIGE_parallelsumTwoVec', PACKAGE = 'SAIGE', x))
 }
 
-setminMAC_VarianceRatio <- function(t_minMACVarRatio, t_maxMACVarRatio, t_isVarianceRatioinGeno) {
-    invisible(.Call('_SAIGE_setminMAC_VarianceRatio', PACKAGE = 'SAIGE', t_minMACVarRatio, t_maxMACVarRatio, t_isVarianceRatioinGeno))
+setgenoNULL <- function() {
+    invisible(.Call('_SAIGE_setgenoNULL', PACKAGE = 'SAIGE'))
 }
 
-getCoefficients_multiV <- function(Yvec, Xmat, wVec, tauVec, maxiterPCG, tolPCG, LOCO) {
-    .Call('_SAIGE_getCoefficients_multiV', PACKAGE = 'SAIGE', Yvec, Xmat, wVec, tauVec, maxiterPCG, tolPCG, LOCO)
+setgeno <- function(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne) {
+    invisible(.Call('_SAIGE_setgeno', PACKAGE = 'SAIGE', bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne))
 }
 
-GetTrace_multiV <- function(Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO) {
-    .Call('_SAIGE_GetTrace_multiV', PACKAGE = 'SAIGE', Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO)
+Get_OneSNP_Geno <- function(SNPIdx) {
+    .Call('_SAIGE_Get_OneSNP_Geno', PACKAGE = 'SAIGE', SNPIdx)
 }
 
-getAIScore_multiV <- function(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO) {
-    .Call('_SAIGE_getAIScore_multiV', PACKAGE = 'SAIGE', Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO)
+Get_OneSNP_Geno_forVarRatio <- function(SNPIdx) {
+    .Call('_SAIGE_Get_OneSNP_Geno_forVarRatio', PACKAGE = 'SAIGE', SNPIdx)
 }
 
-fitglmmaiRPCG_multiV <- function(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, tol, traceCVcutoff, LOCO) {
-    .Call('_SAIGE_fitglmmaiRPCG_multiV', PACKAGE = 'SAIGE', Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, tol, traceCVcutoff, LOCO)
+Get_OneSNP_StdGeno <- function(SNPIdx) {
+    .Call('_SAIGE_Get_OneSNP_StdGeno', PACKAGE = 'SAIGE', SNPIdx)
 }
 
 SPA <- function(mu, g, q, qinv, pval_noadj, tol, logp, traitType, pval, isSPAConverge) {
diff --git a/R/SAIGE_SPATest_Region.R b/R/SAIGE_SPATest_Region.R
index 51846a49..c130420e 100644
--- a/R/SAIGE_SPATest_Region.R
+++ b/R/SAIGE_SPATest_Region.R
@@ -65,15 +65,15 @@ setSparseSigma_new = function(sparseGRMFile, sparseGRMSampleIDFile, relatednessC
 	sumSpGRM[which(sumSpGRM[,1] == sumSpGRM[,2]), 3] = sumSpGRM[which(sumSpGRM[,1] == sumSpGRM[,2]), 3] + tauVec[1]
 
   }
-   #diag(sparseSigma) = tauVec[1] + diag(sparseSigma)
-  nSubj = dim(sparseGRM)[1]
-
-  locations = t(sumSpGRM[,c(1,2)])
-  print(dim(locations))
-  sigmaMatListR = list(locations = t(sumSpGRM[,c(1,2)]),
-                     values = sumSpGRM[,3],
-                     nSubj = nSubj)
-  return(sigmaMatListR)
+  #nSubj = dim(sparseGRM)[1]
+
+  #locations = t(sumSpGRM[,c(1,2)])
+  #print(dim(locations))
+  #sigmaMatListR = list(locations = t(sumSpGRM[,c(1,2)]),
+  #                   values = sumSpGRM[,3],
+  #                   nSubj = nSubj)
+  #return(sigmaMatListR)
+  return(sumSpGRM)
 }
 
 
diff --git a/R/SAIGE_Test_main.R b/R/SAIGE_Test_main.R
index 74bf8caa..a240c7d0 100644
--- a/R/SAIGE_Test_main.R
+++ b/R/SAIGE_Test_main.R
@@ -93,6 +93,8 @@ SPAGMMATtest = function(bgenFile = "",
                  condition="",
 		 sparseGRMFile="",
                  sparseGRMSampleIDFile="",
+		 VmatFilelist = "",
+                 VmatSampleFilelist = "",
 		 relatednessCutoff = 0, 
                  groupFile="",
                  weights.beta=c(1,25),
@@ -231,22 +233,43 @@ SPAGMMATtest = function(bgenFile = "",
         print("LOCO = FASLE and leave-one-chromosome-out is not applied")
     }	    
 
-    sparseSigmaRList = list()
+    #sparseSigmaRList = list()
     isSparseGRM = TRUE
-    if(sparseGRMFile != ""){ 
+    if(sparseGRMFile != ""){
+
+	       set_isSparseGRM(TRUE)
+        set_useGRMtoFitNULL(TRUE)	    
+	  #g_spGRM  
+      getsubGRM_orig(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, obj.model$sampleID)	    
       #sparseSigmaRList = setSparseSigma(sparseSigmaFile)
-      sparseSigmaRList = setSparseSigma_new(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, obj.model$sampleID, obj.model$theta, obj.model$mu2,  obj.model$traitType)
-      isSparseGRM = TRUE
+      if(any(duplicated(obj.model$sampleID))){
+      #          getsubGRM_orig(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, dataMerge_sort$IID)	      
+      #  sparseSigmaRList = setSparseSigma_new(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, obj.model$sampleID, obj.model$theta, obj.model$mu2,  obj.model$traitType)
+      #}else{
+        cat(length(obj.model$sampleID), " observations are used for analysis\n")
+        set_I_mat_inR(obj.model$sampleID)
+        if(!is.null(obj.model$longlVar)){
+          set_T_mat_inR(obj.model$sampleID, obj.model$longlVar)
+        }
+        #getsubGRM_orig(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, obj.model$sampleID)
+	SigmaMat_sp = Matrix:::sparseMatrix(i = c(1,1,2,2), j = c(1,2,1,2), x = as.vector(c(0,0,0,0))) 
+      }else{
+	  SigmaMat_sp = setSparseSigma_new(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, obj.model$sampleID, obj.model$theta, obj.model$mu2,  obj.model$traitType)     
 
+       }	       
+      isSparseGRM = TRUE
     }else{
       #if(!is.null(obj.model$useSparseGRMforVarRatio)){
       #	if(obj.model$useSparseGRMforVarRatio == TRUE){
       # 		stop("sparse GRM is not specified but it was used in Step 1.\n")
       #	}	
       #}		      
-      sparseSigmaRList = list(nSubj = 0, locations = matrix(0,nrow=2,ncol=2), values = rep(0,2))  
+      #sparseSigmaRList = list(nSubj = 0, locations = matrix(0,nrow=2,ncol=2), values = rep(0,2))
+      SigmaMat_sp = Matrix:::sparseMatrix(i = c(1,1,2,2), j = c(1,2,1,2), x = as.vector(c(0,0,0,0)))	    
       isSparseGRM = FALSE 
-    }	    
+    }
+    set_Vmat_vec_orig(VmatFilelist, VmatSampleFilelist, obj.model$sampleID)
+
     ratioVecList = Get_Variance_Ratio(varianceRatioFile, cateVarRatioMinMACVecExclude, cateVarRatioMaxMACVecInclude, isGroupTest, isSparseGRM) #readInGLMM.R
 
     if(is_fastTest){
@@ -273,7 +296,8 @@ SPAGMMATtest = function(bgenFile = "",
 
     nsample = length(obj.model$y)
     cateVarRatioMaxMACVecInclude = c(cateVarRatioMaxMACVecInclude, nsample)	
-    
+   
+
     #in Geno.R
     objGeno = setGenoInput(bgenFile = bgenFile,
                  bgenFileIndex = bgenFileIndex,
@@ -299,7 +323,7 @@ SPAGMMATtest = function(bgenFile = "",
 		is_fastTest = FALSE
 		cat("is_fastTest is not working for conditional analysis.\n")
 	}
-   }else {
+   }else{
         isCondition = FALSE
    }
     
@@ -308,6 +332,10 @@ SPAGMMATtest = function(bgenFile = "",
         cat("Conducting conditional analysis. Please specify the conditioning markers in the order as they are store in the genotype/dosage file.\n")
     }	   
     #set up the SAIGE object based on the null model results
+	print("SigmaMat_sp")
+    print(SigmaMat_sp)
+
+
     setSAIGEobjInCPP(t_XVX=obj.model$obj.noK$XVX,
 		     t_XXVX_inv=obj.model$obj.noK$XXVX_inv,
 		     t_XV=obj.model$obj.noK$XV,
@@ -330,16 +358,14 @@ SPAGMMATtest = function(bgenFile = "",
 		     t_flagSparseGRM = isSparseGRM,
 		     t_isFastTest = is_fastTest,
 		     t_pval_cutoff_for_fastTest = pval_cutoff_for_fastTest,
-        	     t_locationMat = as.matrix(sparseSigmaRList$locations),
-        	     t_valueVec = sparseSigmaRList$values,
-        	     t_dimNum = sparseSigmaRList$nSubj, 
 		     t_isCondition = isCondition,
 		     t_condition_genoIndex = condition_genoIndex,
 		     t_is_Firth_beta = is_Firth_beta,
 		     t_pCutoffforFirth = pCutoffforFirth,
 		     t_offset = obj.model$offset, 
-		     t_resout = as.integer(obj.model$obj_cc$res.out))
-  rm(sparseSigmaRList)
+		     t_resout = as.integer(obj.model$obj_cc$res.out),
+		     t_SigmaMat_sp = SigmaMat_sp)
+  #rm(sparseSigmaRList)
   gc()
    #process condition
     if (isCondition) {
diff --git a/R/SAIGE_fitGLMM_fast_func_multiV.R b/R/SAIGE_fitGLMM_fast_func_multiV.R
index a6b3ac5d..7fa9c689 100644
--- a/R/SAIGE_fitGLMM_fast_func_multiV.R
+++ b/R/SAIGE_fitGLMM_fast_func_multiV.R
@@ -1,13 +1,17 @@
 # Run iterations to get converged alpha and eta
-Get_Coef_multiV = function(y, X, tau, family, alpha0, eta0,  offset, maxiterPCG, tolPCG,maxiter, verbose=FALSE, LOCO = FALSE){
+Get_Coef_multiV = function(y, X, tau, family, alpha0, eta0,  offset, maxiterPCG, tolPCG,maxiter, verbose=FALSE, LOCO = FALSE,var_weights = NULL){
   tol.coef = 0.1
   mu = family$linkinv(eta0)
   mu.eta = family$mu.eta(eta0)
   Y = eta0 - offset + (y - mu)/mu.eta
-
-  sqrtW = mu.eta/sqrt(family$variance(mu))
+  if(is.null(var_weights)){
+  	sqrtW = mu.eta/sqrt(family$variance(mu))
+  }else{
+	sqrtW = mu.eta/sqrt(1/as.vector(var_weights)*family$variance(mu))
+  }	  
   W = sqrtW^2
 
+
   for(i in 1:maxiter){
     re.coef = getCoefficients_multiV(Y, X, W, tau, maxiter=maxiterPCG, tol=tolPCG, LOCO)
     alpha = re.coef$alpha
@@ -22,15 +26,29 @@ Get_Coef_multiV = function(y, X, tau, family, alpha0, eta0,  offset, maxiterPCG,
     mu = family$linkinv(eta)
     mu.eta = family$mu.eta(eta)
 
-    Y = eta - offset + (y - mu)/mu.eta
+    #print("mu.eta")
+    #print(mu.eta)
+
 
+    Y = eta - offset + (y - mu)/mu.eta
+    print("alpha")
+    print(alpha)
+    print("alpha0")
+    print(alpha0)
     print("y[1]")
     print(y[1])
     print("y[2]")
     print(y[2])
 
-    sqrtW = mu.eta/sqrt(family$variance(mu))
-    W = sqrtW^2
+    #if(is.null(var_weights)){
+        sqrtW = mu.eta/sqrt(family$variance(mu))
+    #}else{
+    #    sqrtW = mu.eta/sqrt(1/as.vector(var_weights)*family$variance(mu))
+    #}
+   W = sqrtW^2
+
+    #sqrtW = mu.eta/sqrt(family$variance(mu))
+    #W = sqrtW^2
 
     if( max(abs(alpha - alpha0)/(abs(alpha) + abs(alpha0) + tol.coef))< tol.coef){
         break
@@ -342,6 +360,119 @@ set_Vmat_vec = function(VmatFilelist, VmatSampleFilelist, modelID, longlVarVec=N
 }
 
 
+
+set_Vmat_vec_orig = function(VmatFilelist, VmatSampleFilelist, modelID){
+
+  if(VmatFilelist != ""){
+    VmatFile_vec = unlist(strsplit(VmatFilelist, split=","))
+    cat(length(VmatFile_vec), " additional variance covariance matrices are specified\n")
+    VmatSampleFile_vec = unlist(strsplit(VmatSampleFilelist, split=","))
+    if(length(VmatSampleFile_vec) != length(VmatFile_vec)){
+      stop("Number of sample files in ", VmatSampleFilelist, " does not equal to number of matrix files in ", VmatFilelist, "\n")
+    }else{
+      modelID = unique(modelID)	    
+      for(i in 1:length(VmatFile_vec)){
+        Vmatfile = VmatFile_vec[i]
+        VmatSamplefile = VmatSampleFile_vec[i]
+        if(!file.exists(Vmatfile)){
+          stop(Vmatfile, " does not exist\n")
+        }else if(!file.exists(VmatSamplefile)){
+          stop(VmatSamplefile, " does not exist\n")
+        }else{          		
+          sparseVmat = getVmatSub(Vmatfile, VmatSamplefile, modelID)
+          addNewKat(sparseVmat)
+          #Matrix::writeMM(sparseVmat, file="kin2_SAIGE.mtx")
+        }
+      }
+    }
+  }
+}
+
+
+
+
+
+getsubGRM_orig = function (sparseGRMFile = NULL, sparseGRMSampleIDFile = "", relatednessCutoff,
+    modelID = NULL){
+
+    cat("extract sparse GRM\n")
+    sparseGRMLarge = Matrix:::readMM(sparseGRMFile)
+    print(nnzero(sparseGRMLarge))
+    cat("set elements in the sparse GRM <= ", relatednessCutoff,
+        " to zero\n")
+    sparseGRMLarge = Matrix:::drop0(sparseGRMLarge, tol = relatednessCutoff)
+    sparseGRMLarge = sparseGRMLarge * 1
+    if (!file.exists(sparseGRMSampleIDFile)) {
+        stop("ERROR! sparseSigmaSampleIDFile ", sparseGRMSampleIDFile,
+            " does not exist\n")
+    }else{
+        sparseGRMSampleID = data.frame(data.table:::fread(sparseGRMSampleIDFile,
+            header = F, stringsAsFactors = FALSE, colClasses = c("character")))
+        colnames(sparseGRMSampleID) = c("sampleID")
+        sparseGRMSampleID$IndexGRM = seq(1, nrow(sparseGRMSampleID),
+            by = 1)
+        if (nrow(sparseGRMSampleID) != dim(sparseGRMLarge)[1] |
+            nrow(sparseGRMSampleID) != dim(sparseGRMLarge)[2]) {
+            stop("ERROR! number of samples in the sparse GRM is not the same to the number of sample IDs in the specified sparseGRMSampleIDFile ",
+                sparseGRMSampleIDFile, "\n")
+        }else {
+            sampleInModel = NULL
+	    modelID = unique(modelID) #model ID not duplicated
+            sampleInModel$IID = modelID
+            sampleInModel = data.frame(sampleInModel)
+            sampleInModel$IndexInModel = seq(1, length(sampleInModel$IID),
+                by = 1)
+            cat(nrow(sampleInModel), " samples have been used to fit the glmm null model\n")
+            mergeID = merge(sampleInModel, sparseGRMSampleID,
+                by.x = "IID", by.y = "sampleID")
+            if (nrow(sampleInModel) > nrow(mergeID)) {
+                stop("ERROR: ", nrow(sampleInModel) - nrow(mergeID),
+                  "samples used for model fitting are not in the specified GRM\n")
+            }else {
+                mergeID = mergeID[with(mergeID, order(IndexInModel)),
+                  ]
+                indexIDofGRM = mergeID$IndexGRM
+                sparseGRM = sparseGRMLarge[indexIDofGRM, indexIDofGRM]
+                setupSparseGRM_new(sparseGRM)
+                rm(sparseGRMLarge)
+                rm(sparseGRM)
+                #return(sparseGRM)
+            }
+       }
+   }
+	
+}
+
+set_dup_sample_index_inR = function(modelID){
+        b = as.numeric(factor(modelID, levels =  unique(modelID)))
+        set_dup_sample_index(b-1)
+}
+
+
+
+
+set_I_mat_inR = function(modelID){
+	b = as.numeric(factor(modelID, levels =  unique(modelID)))
+	I_mat = Matrix::sparseMatrix(i = 1:length(b), j = b, x = rep(1, length(b)))
+	I_mat = 1.0 * I_mat
+	set_I_longl_mat(I_mat, b-1)
+}
+
+
+
+set_T_mat_inR = function(modelID, longlVarVec=NULL){
+    if(is.null(longlVarVec)){
+	stop("longlVarVec is not specified\n")
+    }else{	
+        b = as.numeric(factor(modelID, levels =  unique(modelID)))
+        I_mat = Matrix::sparseMatrix(i = 1:length(b), j = b, x = rep(1, length(b)))
+        T_mat = I_mat * longlVarVec
+        set_T_longl_mat(T_mat, longlVarVec)
+    }	
+}
+
+
+
 getsubGRM <- function (sparseGRMFile = NULL, sparseGRMSampleIDFile = "", relatednessCutoff,
     modelID = NULL, longlVarVec=NULL)
 {
diff --git a/R/SAIGE_fitGLMM_fast_multiV.R b/R/SAIGE_fitGLMM_fast_multiV.R
index f8f043ae..fff69089 100644
--- a/R/SAIGE_fitGLMM_fast_multiV.R
+++ b/R/SAIGE_fitGLMM_fast_multiV.R
@@ -56,6 +56,8 @@ fitNULLGLMM_multiV = function(plinkFile = "",
                 invNormalize = FALSE,
                 covarColList = NULL,
                 qCovarCol = NULL,
+		offsetCol = NULL,
+		varWeightsCol = NULL,
 		longlCol = "",
                 sampleIDColinphenoFile = "",
                 tol=0.02,
@@ -101,7 +103,8 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 		skipVarianceRatioEstimation = FALSE, 
 		nrun = 30,
 		VmatFilelist = "",
-		VmatSampleFilelist = "")
+		VmatSampleFilelist = "", 
+		useGRMtoFitNULL=TRUE)
 {
 
     ##set up output files
@@ -123,6 +126,15 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 	bedFile = paste0(plinkFile, ".bed")
 	famFile = paste0(plinkFile, ".fam")
     }
+    setgenoNULL()
+
+    if(!useGRMtoFitNULL){
+        useSparseGRMtoFitNULL = FALSE
+        useSparseGRMforVarRatio = FALSE
+        LOCO = FALSE
+        nThreads = 1
+        cat("No GRM will be used to fit the NULL model and nThreads is set to 1\n")
+    }
 
 
     if (useSparseGRMtoFitNULL & bedFile == ""){
@@ -158,7 +170,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 
 
     if (useSparseGRMtoFitNULL){
-        useSparseGRMforVarRatio = FALSE
+        #useSparseGRMforVarRatio = FALSE
         LOCO = FALSE
 	nThreads = 1
 	if(bedFile != ""){
@@ -168,6 +180,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
     }
 
 
+
     if (useSparseGRMtoFitNULL | useSparseGRMforVarRatio) {
         if (!file.exists(sparseGRMFile)) {
             stop("sparseGRMFile ", sparseGRMFile, " does not exist!")
@@ -198,7 +211,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
             MaleCode, " in the column ", sexCol, " in the phenotype file will be included\n")
     }
 
-    if (!useSparseGRMtoFitNULL  | !skipVarianceRatioEstimation){
+    if ((!useSparseGRMtoFitNULL & useGRMtoFitNULL)  | !skipVarianceRatioEstimation){
         if (!file.exists(bedFile)) {
             stop("ERROR! bed file does not exsit\n")
         }
@@ -234,6 +247,8 @@ fitNULLGLMM_multiV = function(plinkFile = "",
             cat(nrow(sampleListwithGeno), " samples have genotypes\n")
         }
     }else{
+
+      if(useSparseGRMtoFitNULL | useSparseGRMforVarRatio){    
         sampleListwithGenov0 = data.table:::fread(sparseGRMSampleIDFile, 
         header = F, , colClasses = c("character"), data.table = F)
         colnames(sampleListwithGenov0) = c("IIDgeno")
@@ -242,7 +257,8 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         sampleListwithGeno = data.frame(sampleListwithGeno)
         sampleListwithGeno$IndexGeno = seq(1, nrow(sampleListwithGeno), 
             by = 1)
-        cat(nrow(sampleListwithGeno), " samples are in the sparse GRM\n")	
+        cat(nrow(sampleListwithGeno), " samples are in the sparse GRM\n")
+      }	
     }	    
 
 
@@ -265,6 +281,19 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 		checkColList = c(phenoCol, covarColList, sampleIDColinphenoFile, longlCol)
 	}
 
+
+	if(length(offsetCol) > 0){
+            cat(offsetCol, "is the offset term\n")
+	    checkColList = c(checkColList, offsetCol)	
+        }
+
+	if(length(varWeightsCol) > 0){
+	    cat(varWeightsCol, " is the weights for variance\n")	
+	                checkColList = c(checkColList, varWeightsCol)
+	}	
+
+
+
         for (i in checkColList) {
             if (!(i %in% colnames(data))) {
                 stop("ERROR! column for ", i, " does not exist in the phenoFile \n")
@@ -331,8 +360,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
             formula = paste0(phenoCol, "~", paste0(covarColList, 
                 collapse = "+"))
             hasCovariate = TRUE
-        }
-        else {
+        }else {
             formula = paste0(phenoCol, "~ 1")
             hasCovariate = FALSE
         }
@@ -343,11 +371,26 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 	mmat = data.frame(mmat)
         mmat = cbind(mmat,  data[, which(colnames(data) == phenoCol), drop=F])
 	colnames(mmat)[ncol(mmat)] = phenoCol
+	
+	coln=1
+	if(length(offsetCol) > 0){
+		mmat = cbind(mmat,  data[, which(colnames(data) == offsetCol), drop=F])
+		colnames(mmat)[ncol(mmat)] = offsetCol
+		coln = coln + 1
+	}	
+
+	  if(length(varWeightsCol) > 0){
+		mmat = cbind(mmat,  data[, which(colnames(data) == varWeightsCol), drop=F])
+		colnames(mmat)[ncol(mmat)] = varWeightsCol
+
+		coln = coln + 1
+        }
+
 
 
 	if (length(covarColList) > 0) {
 	    if(length(qCovarCol) > 0){
-		covarColList = colnames(mmat)[2:(ncol(mmat)-1)]
+		covarColList = colnames(mmat)[2:(ncol(mmat)-coln)]
 		formula = paste0(phenoCol, "~", paste0(covarColList, collapse = "+")) 
 		formula.null = as.formula(formula)
             }
@@ -364,16 +407,19 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         cat(nrow(mmat_nomissing), " samples have non-missing phenotypes\n")
 
 
-
-
-	if((useSparseGRMtoFitNULL & !skipVarianceRatioEstimation) | useSparseGRMforVarRatio){
+	if(length(varWeightsCol) > 0){
+		varWeights = mmat_nomissing[,which(colnames(mmat_nomissing)  == varWeightsCol)]
+	}else{
+		varWeights = NULL
+	}	
+        if(sparseGRMSampleIDFile != ""){
+	#if((useSparseGRMtoFitNULL & !skipVarianceRatioEstimation) | useSparseGRMforVarRatio){
 		sampleListwithGenov0 = data.table:::fread(sparseGRMSampleIDFile,
                 header = F, , colClasses = c("character"), data.table = F)
                 colnames(sampleListwithGenov0) = c("IIDgeno")
 		cat(length(sampleListwithGenov0$IIDgeno), " samples are in the sparse GRM\n")
 		mmat_nomissing = mmat_nomissing[which(mmat_nomissing$IID %in% sampleListwithGenov0$IIDgeno), ]
 		cat(nrow(mmat_nomissing), " samples who have non-missing phenotypes are also in the sparse GRM\n")
-
 	}
 
 
@@ -387,25 +433,36 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 		stop("No duplicated sample IDs are detected in the phenotype file\n")
 	}	
       }	      
-
-        dataMerge = merge(mmat_nomissing, sampleListwithGeno, 
+	if(useGRMtoFitNULL){
+        	dataMerge = merge(mmat_nomissing, sampleListwithGeno, 
             by.x = "IID", by.y = "IIDgeno")
-        dataMerge_sort = dataMerge[with(dataMerge, order(IndexGeno)),]
+        	dataMerge_sort = dataMerge[with(dataMerge, order(IndexGeno)),]
         #dataMerge_sort = dataMerge[with(dataMerge, order(IndexPheno)),]
-        print("Test")
+	}else{
+		dataMerge_sort = mmat_nomissing
+		dataMerge_sort$IIDgeno = dataMerge_sort$IID
+
+	}	
+
+	print("Test")
 	print(head(dataMerge_sort))
 	#dataMerge_sort = dataMerge
 
         rm(mmat)
 	rm(mmat_nomissing)
-	gc()	
-	indicatorGenoSamplesWithPheno = (sampleListwithGeno$IndexGeno %in% dataMerge_sort$IndexGeno)
+	gc()
+	if(useGRMtoFitNULL){	
+		indicatorGenoSamplesWithPheno = (sampleListwithGeno$IndexGeno %in% dataMerge_sort$IndexGeno)
 
-        if (length(unique(dataMerge_sort$IIDgeno)) < length(unique(sampleListwithGeno$IIDgeno))) {
-            cat(length(unique(sampleListwithGeno$IIDgeno)) - length(unique(dataMerge_sort$IIDgeno)), 
+        	if (length(unique(dataMerge_sort$IIDgeno)) < length(unique(sampleListwithGeno$IIDgeno))) {
+            	cat(length(unique(sampleListwithGeno$IIDgeno)) - length(unique(dataMerge_sort$IIDgeno)), 
                 " samples in geno file do not have phenotypes\n")
-        }
-        cat(length(unique(dataMerge_sort$IIDgeno)), " samples will be used for analysis\n")
+        	}
+        	cat(length(unique(dataMerge_sort$IIDgeno)), " samples will be used for analysis\n")
+	}else{
+		indicatorGenoSamplesWithPheno = rep(TRUE, nrow(dataMerge_sort))
+
+	}	
 
 	if(any(duplicated(dataMerge_sort$IID))){
 		cat(nrow(dataMerge_sort), " observations will be used for analysis\n")
@@ -413,10 +470,22 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 		  #dataMerge_sort = dataMerge_sort[with(dataMerge_sort, order(IndexGeno, longlVar)),]
 		#  dataMerge_sort = dataMerge_sort[with(dataMerge_sort, order(longlVar)),]
 		#}
-	}	
-
+		set_I_mat_inR(dataMerge_sort$IID)
+		if(longlCol != ""){
+			set_T_mat_inR(dataMerge_sort$IID, dataMerge_sort$longlVar)
+		}
+	
+	}else{
+		if(!useGRMtoFitNULL){
+			stop("No duplicated IDs are observed in the phenotype file, so GRM must be used to fit the null model. Please set useGRMtoFitNULL=TRUE\n")
+		}
+	}
+	set_useGRMtoFitNULL(useGRMtoFitNULL)	
     }
-     print("Test3")
+
+
+
+    print("Test3")
     print(head(dataMerge_sort))
 
     if (traitType == "quantitative" & invNormalize) {
@@ -467,24 +536,58 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         cat("colnames(data.new) is ", colnames(data.new), "\n")
         cat("out.transform$Param.transform$qrr: ", dim(out.transform$Param.transform$qrr), 
             "\n")
+	
+	if(length(offsetCol) > 0){
+		data.new = cbind(data.new, dataMerge_sort[which(colnames(dataMerge_sort) == offsetCol),])
+		colnames(data.new)[ncol(data.new)] == offsetCol	
+	}
+
     }else{
         formula.new = formula.null
         data.new = dataMerge_sort
         out.transform = NULL
     }
 
-    mmat = model.matrix(formula.new, data=data.new, na.action = NULL)
     if (traitType == "binary") {
-            modwitcov = glm(formula.new, data = data.new, 
-                family = binomial)
+	if(length(offsetCol) == 0){
+	    modwitcov = glm(formula.new, data = data.new, 
+                family = binomial, weights = varWeights)
+    	}else{
+		offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]	 
+	    modwitcov = glm(formula.new, offset=offsetColVal, data = data.new,
+                family = binomial, weights = varWeights)	
+	}	
     }else if(traitType == "quantitative"){
+	if(length(offsetCol) == 0){    
 	    modwitcov = glm(formula.new, data = data.new,
-                family = gaussian(link = "identity"))	
+                family = gaussian(link = "identity"), weights = varWeights)	
+        }else{
+		offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]	 
+	    modwitcov = glm(formula.new, offset=offsetColVal, data = data.new, 
+                family = gaussian(link = "identity"), weights = varWeights)	
+	}	
     }else if(traitType == "count"){
+	 if(length(offsetCol) == 0){    
 	     modwitcov = glm(formula.new, data = data.new,
-	                     family = "poisson")
+	                     family = "poisson", weights = varWeights)
+         }else{
+		offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]	 
+	     modwitcov = glm(formula.new, offset=offsetColVal, data = data.new,
+		     		family = "poisson", weights = varWeights)	     
+	 }		 
+    }else if(traitType == "count_nb"){
+
+	 if(length(offsetCol) == 0){
+             modwitcov = glm(formula.new, data = data.new,
+                             family = NegBin(), weights = varWeights)
+         }else{
+		print(head(data.new))
+		offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]	 
+	      modwitcov = glm(formula.new, offset=offsetColVal, data = data.new,
+                                family = NegBin(), weights = varWeights)			
+	 } 
     }
-
+    mmat = model.matrix(formula.new, data=data.new, na.action = NULL)
 
     if (isCovariateOffset) {
     	covoffset = mmat[,-1, drop=F] %*%  modwitcov$coefficients[-1]  
@@ -495,13 +598,14 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         hasCovariate = FALSE
     }else{
 	covoffset = rep(0,nrow(data.new))
-    }	    
+    }
+
     data.new$covoffset = covoffset
 
-	    
+
     if (useSparseGRMtoFitNULL | useSparseGRMforVarRatio) {
-        #sparseGRMtest = getsubGRM(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, dataMerge_sort$IID)
-	getsubGRM(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, dataMerge_sort$IID, dataMerge_sort$longlVar)    
+	getsubGRM_orig(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, dataMerge_sort$IID)
+   	#getsubGRM(sparseGRMFile, sparseGRMSampleIDFile, relatednessCutoff, dataMerge_sort$IID, dataMerge_sort$longlVar)    
         #m4 = gen_sp_v2(sparseGRMtest)
         #cat("Setting up sparse GRM using ", sparseGRMFile, " and ", sparseGRMSampleIDFile, "\n")
         #cat("Dimension of the sparse GRM is ", dim(m4), "\n")
@@ -515,7 +619,42 @@ fitNULLGLMM_multiV = function(plinkFile = "",
     }
 
     #allow for multiple variance components
-    set_Vmat_vec(VmatFilelist, VmatSampleFilelist, dataMerge_sort$IID, dataMerge_sort$longlVar)
+    #set_Vmat_vec(VmatFilelist, VmatSampleFilelist, dataMerge_sort$IID, dataMerge_sort$longlVar)
+    set_Vmat_vec_orig(VmatFilelist, VmatSampleFilelist, dataMerge_sort$IID)
+
+    numofV = get_numofV()
+    cat("numofV ", numofV, "\n")
+    if(any(duplicated(dataMerge_sort$IID))){
+        if(longlCol == ""){
+	    if(useGRMtoFitNULL){	
+	       num_Kmat = numofV + 3
+            }else{
+	       num_Kmat = numofV + 2	
+	    }	    
+               #k = num_Kmat + 3
+        }else{
+	    if(useGRMtoFitNULL){	
+	       num_Kmat = 7 + numofV*3
+	    }else{
+	       num_Kmat = 4 + numofV*3
+	    }	    
+	       #k = num_Kmat + 2		
+        }
+    }else{
+	if(useGRMtoFitNULL){    
+	    num_Kmat = numofV + 2
+        }else{
+	    num_Kmat = numofV + 1	
+	}	
+        #k = 2
+    }
+    k = num_Kmat
+
+
+
+    set_num_Kmat(num_Kmat)
+    cat("num_Kmat ", num_Kmat, "\n")
+
 
     if(longlCol != ""){
        covarianceIdxMat = set_covarianceidx_Mat()
@@ -528,7 +667,6 @@ fitNULLGLMM_multiV = function(plinkFile = "",
             if(isCateVarianceRatio){
                 minMAC_varRatio = min(cateVarRatioMinMACVecExclude)
                 maxMAC_varRatio = max(cateVarRatioMaxMACVecInclude)
-                #maxMAC_varRatio = max(max(cateVarRatioMaxMACVecInclude), minMACforGRM - 1)
                 cat("Categorical variance ratios will be estimated. Please make sure there are at least 200 markers in each MAC category.\n")
             }else{
                 minMAC_varRatio = 20
@@ -562,30 +700,49 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 	print("head(data.new)")
 	print(head(data.new))
         if (!isCovariateOffset) {
-            fit0 = glm(formula.new, data = data.new, family = binomial)
+	  if(length(offsetCol) == 0){		
+            fit0 = glm(formula.new, data = data.new, family = binomial, weights = varWeights)
+	  }else{
+	offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]	  
+	    fit0 = glm(formula.new, data = data.new, offset = offsetColVal, family = binomial, weights = varWeights)	
+          }
 	    Xorig = NULL
-	    
-	    }else{
-	    fit0orig = glm(formula.new.withCov, data = data.new, family = binomial)
+	 }else{	 
+	    fit0orig = glm(formula.new.withCov, data = data.new, family = binomial, weights = varWeights)
 	    Xorig = model.matrix(fit0orig)
 	    rm(fit0orig)
 	    gc()
+          if(length(offsetCol) == 0){
             fit0 = glm(formula.new, data = data.new, offset = covoffset, 
-                family = binomial)
+                family = binomial, weights = varWeights)
+	  }else{
+	    offsetTotal = covoffset + data.new[,which(colnames(data.new) == offsetCol)]
+	    fit0 = glm(formula.new, data = data.new, offset = offsetTotal, family = binomial, weights = varWeights) 
+	  }	  
         }
 
     }else if(traitType == "quantitative"){
         cat(phenoCol, " is a quantitative trait\n")
-        if (!isCovariateOffset) {
-            fit0 = glm(formula.new, data = data.new, family = gaussian(link = "identity"))
-            Xorig = NULL
+        if (!isCovariateOffset){
+	 if(length(offsetCol) == 0){	
+            fit0 = glm(formula.new, data = data.new, family = gaussian(link = "identity"), weights = varWeights)
+	 }else{ 
+		offsetColVal = data.new[,which(colnames(data.new) == offsetCol)] 
+	    fit0 = glm(formula.new, data = data.new, offset = offsetColVal, family = gaussian(link = "identity"), weights = varWeights)	
+	 }	 
+         Xorig = NULL
         }else{
-            fit0orig = glm(formula.new.withCov, data = data.new, family = gaussian(link = "identity"))
+	  fit0orig = glm(formula.new.withCov, data = data.new, family = gaussian(link = "identity"), weights = varWeights)
             Xorig = model.matrix(fit0orig)
             rm(fit0orig)
             gc()
+          if(length(offsetCol) == 0){
             fit0 = glm(formula.new, data = data.new, offset = covoffset,
-            family = gaussian(link = "identity"))
+                family = gaussian(link = "identity"), weights = varWeights)
+          }else{
+            offsetTotal = covoffset + data.new[,which(colnames(data.new) == offsetCol)]
+            fit0 = glm(formula.new, data = data.new, offset = offsetTotal, family = gaussian(link = "identity"), weights = varWeights)
+          }
         }	
     }else if(traitType == "count"){
         cat(phenoCol, " is a count trait\n")
@@ -595,34 +752,89 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         }
 
         if (!isCovariateOffset) {
-            fit0 = glm(formula.new, data = data.new, family = "poisson")
+	  if(length(offsetCol) == 0){
+            fit0 = glm(formula.new, data = data.new, family = "poisson", weights = varWeights)
+          }else{
+		  offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]
+            fit0 = glm(formula.new, data = data.new, offset = offsetColVal, family = "poisson", weights = varWeights)
+          }	
+          Xorig = NULL
+        }else{
+          fit0orig = glm(formula.new.withCov, data = data.new, family =  "poisson", weights = varWeights)
+            Xorig = model.matrix(fit0orig)
+            rm(fit0orig)
+            gc()
+          if(length(offsetCol) == 0){
+            fit0 = glm(formula.new, data = data.new, offset = covoffset,
+                family = "poisson", weights = varWeights)
+          }else{
+            offsetTotal = covoffset + data.new[,which(colnames(data.new) == offsetCol)]
+            fit0 = glm(formula.new, data = data.new, offset = offsetTotal, family = "poisson", weights = varWeights)
+          } 
+	
+        }
+    }else if(traitType == "count_nb"){
+	cat(phenoCol, " is a count_nb trait\n")
+	miny = min(dataMerge_sort[, which(colnames(dataMerge_sort) == phenoCol)])
+        if (miny < 0 ) {
+            stop("ERROR! phenotype value needs to be non-negative \n")
+        }
+	if (!isCovariateOffset){
+	  if(length(offsetCol) == 0){
+            fit0 = glm(formula.new, data = data.new, family = NegBin(), weights = varWeights)
+          }else{
+	offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]	  
+            fit0 = glm(formula.new, data = data.new, offset = offsetColVal, family = NegBin(), weights = varWeights)
+          }
+
             Xorig = NULL
         }else{
-            fit0orig = glm(formula.new.withCov, data = data.new, family = "poisson")
+	  fit0orig = glm(formula.new.withCov, data = data.new, family = NegBin(), weights = varWeights)
             Xorig = model.matrix(fit0orig)
             rm(fit0orig)
             gc()
+          if(length(offsetCol) == 0){
             fit0 = glm(formula.new, data = data.new, offset = covoffset,
-            family = "poisson")
+                family = NegBin())
+          }else{
+            offsetTotal = covoffset + data.new[,which(colnames(data.new) == offsetCol)]
+            fit0 = glm(formula.new, data = data.new, offset = offsetTotal, family = NegBin(), weights = varWeights)
+          }
+
         }
-    }
+
+    }	    
     
 
     cat("glm:\n")
     print(fit0)
     obj.noK = NULL
+
+
+    #if(length(fit0$y) > 20000){
+    isStoreSigma = FALSE
+    #}else{
+    #  isStoreSigma = TRUE
+    #}
+    print("isStoreSigma")
+    print(isStoreSigma)
+    set_store_sigma(isStoreSigma)    
+
     if (!skipModelFitting) {
-        setisUseSparseSigmaforNullModelFitting(useSparseGRMtoFitNULL)
+        #setisUseSparseSigmaforNullModelFitting(useSparseGRMtoFitNULL)
         cat("Start fitting the NULL GLMM\n")
         t_begin = proc.time()
         print(t_begin)
 
-  	k =  get_numofV()
-        tau = rep(0, k+2) 
-	fixtau = rep(0, k+2)
+
+        tau = rep(0, k) 
+	fixtau = rep(0, k)
 	tauInit = tau
 
+	set_isSparseGRM(useSparseGRMtoFitNULL)
+        set_useGRMtoFitNULL(useGRMtoFitNULL)
 
+      if(traitType != "count_nb"){
         system.time(modglmm <- glmmkin.ai_PCG_Rcpp_multiV(bedFile, bimFile, famFile, Xorig, isCovariateOffset, 
                 fit0, tau = tau, fixtau = fixtau, maxiter = maxiter, 
                 tol = tol, verbose = TRUE, nrun = nrun, tolPCG = tolPCG, 
@@ -633,9 +845,48 @@ fitNULLGLMM_multiV = function(plinkFile = "",
                 chromosomeEndIndexVec = chromosomeEndIndexVec, 
                 traceCVcutoff = traceCVcutoff, isCovariateTransform = isCovariateTransform, 
                 isDiagofKinSetAsOne = isDiagofKinSetAsOne, 
-		isLowMemLOCO = isLowMemLOCO, covarianceIdxMat = covarianceIdxMat))
-         
+		isLowMemLOCO = isLowMemLOCO, covarianceIdxMat = covarianceIdxMat, isStoreSigma = isStoreSigma, useSparseGRMtoFitNULL = useSparseGRMtoFitNULL, useGRMtoFitNULL = useGRMtoFitNULL))
 	modglmm$obj.glm.null$model <- data.frame(modglmm$obj.glm.null$model)
+      }else{
+	      
+	system.time(modglmm <- glmmkin.ai_PCG_Rcpp_multiV_NB(bedFile, bimFile, famFile, Xorig, isCovariateOffset,
+                fit0, tau = tau, fixtau = fixtau, maxiter = maxiter,
+                tol = tol, verbose = TRUE, nrun = nrun, tolPCG = tolPCG,
+                maxiterPCG = maxiterPCG, subPheno = dataMerge_sort, indicatorGenoSamplesWithPheno = indicatorGenoSamplesWithPheno,
+                obj.noK = obj.noK, out.transform = out.transform,
+                tauInit = tauInit, memoryChunk = memoryChunk,
+                LOCO = LOCO, chromosomeStartIndexVec = chromosomeStartIndexVec,
+                chromosomeEndIndexVec = chromosomeEndIndexVec,
+                traceCVcutoff = traceCVcutoff, isCovariateTransform = isCovariateTransform,
+                isDiagofKinSetAsOne = isDiagofKinSetAsOne,
+                isLowMemLOCO = isLowMemLOCO, covarianceIdxMat = covarianceIdxMat, isStoreSigma = isStoreSigma, useSparseGRMtoFitNULL = useSparseGRMtoFitNULL, useGRMtoFitNULL = useGRMtoFitNULL))	
+
+        if (!isCovariateOffset){
+          if(length(offsetCol) == 0){
+
+            fit0 = glm(formula.new, data = data.new, family = NegBin(theta = modglmm$theta_overdispersion), weights = varWeights)
+          }else{
+            offsetColVal = data.new[,which(colnames(data.new) == offsetCol)]
+            fit0 = glm(formula.new, data = data.new, offset = offsetColVal, family = NegBin(theta = modglmm$theta_overdispersion), weights = varWeights)
+          }
+            Xorig = NULL
+        }else{
+            fit0orig = glm(formula.new.withCov, data = data.new, family = NegBin(theta = modglmm$theta_overdispersion), weights = varWeights)
+            Xorig = model.matrix(fit0orig)
+            rm(fit0orig)
+            gc()
+          if(length(offsetCol) == 0){
+            fit0 = glm(formula.new, data = data.new, offset = covoffset,
+            family = NegBin(theta = modglmm$theta_overdispersion))
+          }else{
+            offsetTotal = covoffset + data.new[,which(colnames(data.new) == offsetCol)]
+            fit0 = glm(formula.new, data = data.new, offset = offsetTotal, family = NegBin(theta = modglmm$theta_overdispersion), weights = varWeights)
+          }
+
+        }
+	modglmm$obj.glm.null = fit0
+
+      }	      
             
 	for (x in names(modglmm$obj.glm.null)) {
             attr(modglmm$obj.glm.null[[x]], ".Environment") <- c()
@@ -665,6 +916,9 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 	}
        
 
+	print("CHECK HERE")
+
+
         if(skipVarianceRatioEstimation & useSparseGRMtoFitNULL){
                 family = fit0$family
                 eta = modglmm$linear.predictors
@@ -683,11 +937,20 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         tau = modglmm$theta
         alpha0 = modglmm$coefficients
 
+
         if(!is.null(out.transform) & is.null(fit0$offset)){
                 coef.alpha<-Covariate_Transform_Back(alpha, out.transform$Param.transform)
                 modglmm$coefficients = coef.alpha
         }
 
+	print("alpha0")
+	print(alpha0)
+
+	print("modglmm$coefficients")
+	print(modglmm$coefficients)
+
+
+
 
         if(LOCO & isLowMemLOCO){
                 modglmm$LOCOResult = NULL
@@ -721,7 +984,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
                                 cat("leave chromosome ", j, " out\n")
                                 setStartEndIndex(startIndex, endIndex, j-1)
 
-                                re.coef_LOCO = Get_Coef_multiV(y, X=model.matrix(fit0), tau, family = fit0$family, alpha = alpha0, eta = eta0,  offset =  offset0, verbose=TRUE, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO=TRUE)
+                                re.coef_LOCO = Get_Coef_multiV(y, X=model.matrix(fit0), tau, family = fit0$family, alpha = alpha0, eta = eta0,  offset =  offset0, verbose=TRUE, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO=TRUE, var_weights = var_weights)
                                 cov = re.coef_LOCO$cov
                                 alpha = re.coef_LOCO$alpha
                                 eta = re.coef_LOCO$eta
@@ -733,7 +996,9 @@ fitNULLGLMM_multiV = function(plinkFile = "",
           				mu2 = mu
         			}else if(family$family == "gaussian"){
           				mu2 = rep((1/(tau[1])),length(res))
-        			}
+        			}else if(traitType == "count_nb"){
+          				mu2 = fit0$family$variance(mu)
+				}	
                                 res = y - mu
 
                                 if(!is.null(out.transform) & is.null(fit0$offset)){
@@ -749,6 +1014,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
 
                                 modglmm$LOCOResult[[j]] = list(isLOCO = TRUE, coefficients=coef.alpha, linear.predictors=eta, fitted.values=mu, Y=Y, residuals=res, cov=cov, obj.noK = obj.noK)
                                 if(!isCovariateOffset & hasCovariate){
+					 data.new.X = model.matrix(fit0)[,-1,drop=F]
                                          modglmm$LOCOResult[[j]]$offset = data.new.X %*%(as.vector(modglmm$LOCOResult[[j]]$coefficients[-1]))
                                 }
                                 modelOutbychr = paste(c(outputPrefix,"_chr",j,".rda"), collapse="")
@@ -776,6 +1042,21 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         print(t_end)
         cat("t_end - t_begin, fitting the NULL model took\n")
         print(t_end - t_begin)
+
+
+	if(bedFile != "" & !useGRMtoFitNULL){
+		subSampleInGeno = dataMerge_sort$IndexGeno
+  		if(is.null(dataMerge_sort$IndexGeno)){
+        		subSampleInGeno = dataMerge_sort$IndexPheno
+  		}
+
+
+  		print("HEREHRE")
+  		setgeno(bedFile, bimFile, famFile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne)
+  	}	
+
+
+
     }else{
 	cat("Skip fitting the NULL GLMM\n")
 	if(!file.exists(modelOut)){
@@ -785,6 +1066,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
         if(is.null(modglmm$LOCO)) {
            modglmm$LOCO = FALSE
         }
+
         setgeno(bedFile, bimFile, famFile, dataMerge_sort$IndexGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne)
         tau = modglmm$theta	    
         setisUseSparseSigmaforNullModelFitting(useSparseGRMtoFitNULL)
@@ -819,7 +1101,7 @@ fitNULLGLMM_multiV = function(plinkFile = "",
                 nThreads = nThreads, cateVarRatioMinMACVecExclude = cateVarRatioMinMACVecExclude,
                 cateVarRatioMaxMACVecInclude = cateVarRatioMaxMACVecInclude,
                 minMAFforGRM = minMAFforGRM, isDiagofKinSetAsOne = isDiagofKinSetAsOne,
-                includeNonautoMarkersforVarRatio = includeNonautoMarkersforVarRatio)
+                includeNonautoMarkersforVarRatio = includeNonautoMarkersforVarRatio, isStoreSigma = isStoreSigma, useGRMtoFitNULL = useGRMtoFitNULL)
     }else{
         cat("Skip estimating variance ratios\n")
     }
@@ -855,7 +1137,9 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
                                                     cateVarRatioMaxMACVecInclude,
                                                     minMAFforGRM,
                                                     isDiagofKinSetAsOne,
-                                                    includeNonautoMarkersforVarRatio){
+                                                    includeNonautoMarkersforVarRatio,
+						    isStoreSigma = FALSE, 
+						    useGRMtoFitNULL = TRUE){
 
   obj.noK = obj.glmm.null$obj.noK
   if(file.exists(testOut)){file.remove(testOut)}
@@ -872,10 +1156,30 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
   sqrtW = mu.eta/sqrt(obj.glm.null$family$variance(mu))
   W = sqrtW^2   ##(mu*(1-mu) for binary)
   tauVecNew = obj.glmm.null$theta
+
+  if(isStoreSigma){
+         gen_sp_Sigma_multiV(W, tauVecNew)
+  }
   X = obj.glmm.null$X
+
+
+  set_isSparseGRM(useSparseGRMtoFitNULL)
+  set_useGRMtoFitNULL(useGRMtoFitNULL)
+  if(!useGRMtoFitNULL){
+    useSparseGRMforVarRatio = FALSE
+  }	  
   Sigma_iX_noLOCO = getSigma_X_multiV(W, tauVecNew, X, maxiterPCG, tolPCG, LOCO=FALSE)
+
+
   y = obj.glm.null$y
+
+  if(any(duplicated(obj.glmm.null$sampleID))){
+    dupSampleIndex = as.numeric(factor(obj.glmm.null$sampleID, levels =  unique(obj.glmm.null$sampleID)))
+  }
+
+
   ##randomize the marker orders to be tested
+ if(FALSE){
   if(useSparseGRMtoFitNULL | useSparseGRMforVarRatio){
     sparseSigma = getSparseSigma(bedFile = bedFile, bimFile = bimFile, famFile = famFile,
                 outputPrefix=varRatioOutFile,
@@ -893,6 +1197,9 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
     }
 
   }
+ }
+
+
   mMarkers = gettotalMarker()
   listOfMarkersForVarRatio = list()
   MACvector = getMACVec()
@@ -989,12 +1296,19 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
                 G0 = Get_OneSNP_Geno_forVarRatio(i-1)
           }
 
+
           cat("G0", G0[1:10], "\n")
           CHR = bimPlink[Indexvector_forVarRatio[i]+1,1]
 	  cat("CHR ", CHR, "\n")
-          if(sum(G0)/(2*Nnomissing) > 0.5){
+          #if(sum(G0)/(2*Nnomissing) > 0.5){
+          if(sum(G0)/(2*length(G0)) > 0.5){
             G0 = 2-G0
           }
+
+
+          #if(any(duplicated(obj.glmm.null$sampleID))){
+	  #	G0 = G0[dupSampleIndex]		
+          #}		   
           NAset = which(G0==0)
           AC = sum(G0)
 
@@ -1015,38 +1329,76 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
           mu.eta = family$mu.eta(eta)
           sqrtW = mu.eta/sqrt(obj.glm.null$family$variance(mu))
           W = sqrtW^2
+          print("W[1:10]")
+          print(W[1:10])
+	  print("mu.eta[1:10]")
+	  print(mu.eta[1:10])
+	  print("obj.glm.null$family$variance(mu)[1:10]")
+	  print(obj.glm.null$family$variance(mu)[1:10])
+          print("mu[1:100]")
+          print(mu[1:100])
+	  print("mu*(1-mu)[1:10]")
+	  print((mu*(1-mu))[1:10])
+	  print("y[1:100]")
+	  print(y[1:100])
+
+
+	  set_isSparseGRM(useSparseGRMtoFitNULL)
+  	  set_useGRMtoFitNULL(useGRMtoFitNULL)
+
           Sigma_iG = getSigma_G_multiV(W, tauVecNew, G, maxiterPCG, tolPCG, LOCO=FALSE)
           Sigma_iX = Sigma_iX_noLOCO
 
           var1a = t(G)%*%Sigma_iG - t(G)%*%Sigma_iX%*%(solve(t(X)%*%Sigma_iX))%*%t(X)%*%Sigma_iG
           var1 = var1a/AC
+	  cat("AC ", AC, "\n")	
           m1 = innerProduct(mu,g)
+	  S = q-m1
+
+	if(obj.glmm.null$traitType == "count_nb"){
+		gs = g * (mu.eta/obj.glm.null$family$variance(mu))	
+		S = innerProduct(gs,y) - innerProduct(mu,gs) 
+	}	
+
+   if(useSparseGRMforVarRatio){
+	set_isSparseGRM(useSparseGRMforVarRatio)
+	Sigma_iG = getSigma_G_noV(W, tauVecNew, G, maxiterPCG, tolPCG, LOCO=FALSE)
+	var2_a = t(g) %*% Sigma_iG/(sqrt(AC))
+	var2sparseGRM = var2_a[1,1]
+	cat("var2sparseGRM ", var2sparseGRM*AC, "\n")
+	varRatio_sparseGRM_vec = c(varRatio_sparseGRM_vec, var1/var2sparseGRM)
+
+  }else{
+        varRatio_sparseGRM_vec = c(varRatio_sparseGRM_vec,1)
+  }	
+
+   p_exact = pchisq(S^2/var1, df=1, lower.tail=F)
+
 
-   if(!useSparseGRMtoFitNULL){
-        if(useSparseGRMforVarRatio){
-           pcginvSigma = solve(sparseSigma, g, sparse=T)
-           var2_a = t(g) %*% pcginvSigma
-           var2sparseGRM = var2_a[1,1]
-           varRatio_sparseGRM_vec = c(varRatio_sparseGRM_vec, var1/var2sparseGRM)
-        }
-    }else{
-	  #varRatio_sparseGRM_vec = c(varRatio_sparseGRM_vec, 1)
-	  pcginvSigma = solve(sparseSigma, g, sparse=T)
-	  var2_a = t(g) %*% pcginvSigma
-	  var2sparseGRM = var2_a[1,1]
-	  x=t(G)%*%Sigma_iG/AC
-	  #cat(" x ", x, " var2 ", var2sparseGRM , "\n")
-	  varRatio_sparseGRM_vec = c(varRatio_sparseGRM_vec, var1/var2sparseGRM)
-    }
 
     if(obj.glmm.null$traitType == "binary"){
          var2null = innerProduct(mu*(1-mu), g*g)
+    varRatio_NULL_vec = c(varRatio_NULL_vec, var1/var2null)
     }else if(obj.glmm.null$traitType == "quantitative"){
          var2null = innerProduct(g, g)
+    varRatio_NULL_vec = c(varRatio_NULL_vec, var1/var2null)
     }else if(obj.glmm.null$traitType == "count"){
          var2null = innerProduct(mu, g*g)
-    }
-
+    varRatio_NULL_vec = c(varRatio_NULL_vec, var1/var2null)
+    }else if(obj.glmm.null$traitType == "count_nb"){
+	var2null = innerProduct(W, g*g) ##To update
+    }	    
+         p_approx = pchisq(S^2/(var2null), df=1, lower.tail=F)
+         #p_approx_true = pchisq(S^2/(var2null*0.0009604056), df=1, lower.tail=F)
+	p_approx_true = pchisq(S^2/(var2null*4.742222e-06), df=1, lower.tail=F)
+
+    cat("AC ", AC, "\n")
+    cat("S ", S, "\n")
+    cat("var1 ", var1*AC, "\n")
+    cat("var2null ", var2null*AC, "\n")
+    cat("p_exact ", p_exact, "\n")
+    cat("p_approx ", p_approx, "\n")
+    cat("p_approx_true ", p_approx_true, "\n")
     varRatio_NULL_vec = c(varRatio_NULL_vec, var1/var2null)
 
     #indexInMarkerList = indexInMarkerList + 1
@@ -1061,6 +1413,10 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
       }
     }#end of while(numTestedMarker < numMarkers)
 
+
+    print("varRatio_NULL_vec")
+    print(varRatio_NULL_vec)
+
     ratioCV = calCV(varRatio_NULL_vec)
 
     if(ratioCV > ratioCVcutoff){
@@ -1103,7 +1459,7 @@ extractVarianceRatio_multiV = function(obj.glmm.null,
 
 
 #Fits the null glmm
-glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovariateOffset, fit0, tau=c(0,0), fixtau = c(0,0), maxiter =20, tol = 0.02, verbose = TRUE, nrun=30, tolPCG = 1e-5, maxiterPCG = 500, subPheno, indicatorGenoSamplesWithPheno, obj.noK, out.transform, tauInit, memoryChunk, LOCO, chromosomeStartIndexVec, chromosomeEndIndexVec, traceCVcutoff, isCovariateTransform, isDiagofKinSetAsOne, isLowMemLOCO, covarianceIdxMat = NULL) {
+glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovariateOffset, fit0, tau=c(0,0), fixtau = c(0,0), maxiter =20, tol = 0.02, verbose = TRUE, nrun=30, tolPCG = 1e-5, maxiterPCG = 500, subPheno, indicatorGenoSamplesWithPheno, obj.noK, out.transform, tauInit, memoryChunk, LOCO, chromosomeStartIndexVec, chromosomeEndIndexVec, traceCVcutoff, isCovariateTransform, isDiagofKinSetAsOne, isLowMemLOCO, covarianceIdxMat = NULL, isStoreSigma = FALSE, useSparseGRMtoFitNULL = TRUE, useGRMtoFitNULL = TRUE) {
   #Fits the null generalized linear mixed model for a poisson, binomial, and gaussian
   #Args:
   #  genofile: string. Plink file for the M1 markers to be used to construct the genetic relationship matrix
@@ -1131,12 +1487,25 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
   t_begin = proc.time()
   print(t_begin)
   subSampleInGeno = subPheno$IndexGeno
+  if(is.null(subPheno$IndexGeno)){
+        subSampleInGeno = subPheno$IndexPheno
+  }
   if(verbose){
     print("Start reading genotype plink file here")
   }
 
+  #print("subSampleInGeno")
+  #print(subSampleInGeno)
+
+  print(head(subPheno))
+  set_dup_sample_index(as.numeric(factor(subPheno$IID, levels =  unique(subPheno$IID))))
+
+  #if((!useSparseGRMtoFitNULL & useGRMtoFitNULL) | (skipVarianceRatioEstimation)){
+  if(bedFile != "" & useGRMtoFitNULL){
+	print("HEREHRE")
 
-  re1 = system.time({setgeno(bedFile, bimFile, famFile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne)})
+        re1 = system.time({setgeno(bedFile, bimFile, famFile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne)})
+  }
   if(verbose){
     print("Genotype reading is done")
   }
@@ -1159,12 +1528,21 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
     offset = rep(0, n)
   }
 
+  var_weights = weights(fit0)
+
+
   family = fit0$family
   eta = fit0$linear.predictors
   mu = fit0$fitted.values
   mu.eta = family$mu.eta(eta)
   Y = eta - offset + (y - mu)/mu.eta
-  sqrtW = mu.eta/sqrt(fit0$family$variance(mu))
+
+  if(is.null(var_weights)){
+        sqrtW = mu.eta/sqrt(family$variance(mu))
+  }else{
+        sqrtW = mu.eta/sqrt(1/as.vector(var_weights)*family$variance(mu))
+  }
+
   W = sqrtW^2
 
   alpha0 = fit0$coef
@@ -1190,8 +1568,9 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
   }else{#  if(family$family %in% c("poisson", "binomial")) {
     idxtau <- which(fixtau == 0)	  
     if(sum(tauInit[idxtau]) == 0){
-      #tau[idxtau] = var(Y)/(length(tau))
       tau[1] = 1
+      #tauInit[1] = 1    
+      tau[idxtau] = var(Y)/(length(tau))
       #tau[2] = 0
       #tau[2:length(tau)] = 0
       if (abs(var(Y)) < 0.1){
@@ -1202,7 +1581,7 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
     }
   }
 
-    cat("inital tau is ", tau,"\n")
+  cat("inital tau is ", tau,"\n")
 
   if(!is.null(covarianceIdxMat)){
 	  idxtau2 <- intersect(covarianceIdxMat[, 1], idxtau)
@@ -1213,20 +1592,33 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
 	  if(length(idxtau2) > 0){
 		tau[idxtau2] = 0
           }
-	i_kmat = get_numofV()
-    	if(i_kmat > 0){
-        	Kmatdiag = getMeanDiagofKmat()
-    	}	  
+	#i_kmat = get_numofV()
+    	#if(i_kmat > 0){
+        Kmatdiag = getMeanDiagofKmat(LOCO)
+	print(Kmatdiag)
+    	#}	  
         tau[2:length(tau)] = tau[2:length(tau)]/Kmatdiag
   }
 
-    #q = 1
-    #tau = c(1, 1.300489, 1.338478)
-    #print("Kmatdiag")
-    #print(Kmatdiag)
     print("tau")
     print(tau)
-    re.coef = Get_Coef_multiV(y, X, tau, family, alpha0, eta0,  offset,verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO = FALSE)
+
+
+####set up weights for variance
+#if(!is.null(var_weights)){
+#	set_var_weights(var_weights)
+#}
+
+
+    if(isStoreSigma){
+      gen_sp_Sigma_multiV(W, tau)
+    }
+    
+    re.coef = Get_Coef_multiV(y, X, tau, family, alpha0, eta0,  offset,verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO = FALSE, var_weights = var_weights)
+
+    if(isStoreSigma){
+      gen_sp_Sigma_multiV(re.coef$W, tau)
+    }
 
 
     re = getAIScore_multiV(re.coef$Y, X, re.coef$W, tau, fixtau, re.coef$Sigma_iY, re.coef$Sigma_iX, re.coef$cov, nrun, maxiterPCG,tolPCG = tolPCG, traceCVcutoff = traceCVcutoff, LOCO = FALSE)
@@ -1265,10 +1657,19 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
       eta0 = eta
       # use Get_Coef before getAIScore
       t_begin_Get_Coef = proc.time()
-      re.coef = Get_Coef_multiV(y, X, tau, family, alpha0, eta0,  offset, verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO = FALSE)
+      #if(isStoreSigma){
+      #  gen_sp_Sigma_multiV(W, tau)
+      #}
+#cat("eta0 ", eta0, "\n")
+      re.coef = Get_Coef_multiV(y, X, tau, family, alpha0, eta0,  offset, verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO = FALSE, var_weights = var_weights)
       t_end_Get_Coef =  proc.time()
       cat("t_end_Get_Coef - t_begin_Get_Coef\n")
       print(t_end_Get_Coef - t_begin_Get_Coef)
+      if(isStoreSigma){
+        gen_sp_Sigma_multiV(re.coef$W, tau)
+      }
+
+
       fit = fitglmmaiRPCG_multiV(re.coef$Y, X, re.coef$W, tau, fixtau, re.coef$Sigma_iY, re.coef$Sigma_iX, re.coef$cov, nrun, maxiterPCG, tolPCG, tol = tol, traceCVcutoff = traceCVcutoff, LOCO = FALSE)
 
 	if(i == 1){
@@ -1286,16 +1687,26 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
       Y = re.coef$Y
       mu = re.coef$mu
 
+  mu.eta = family$mu.eta(eta)
+ 
+#  if(is.null(var_weights)){
+#        sqrtW = mu.eta/sqrt(family$variance(mu))
+#  }else{
+#        sqrtW = mu.eta/sqrt(1/as.vector(var_weights)*family$variance(mu))
+#  }
+#  W = sqrtW^2
+
      
       print(abs(tau - tau0)/(abs(tau) + abs(tau0) + tol))
       cat("tau: ", tau, "\n")
       cat("tau0: ", tau0, "\n")
 
-      if(family$family == "gaussian"){
-        if(tau[1]<=0){
-          stop("ERROR! The first variance component parameter estimate is 0\n")
-        }
-      }
+      #if(family$family == "gaussian"){
+        #if(tau[1]<=0){
+	#  tau[1] = tau[1] + 0.1	
+        #  #stop("ERROR! The first variance component parameter estimate is 0\n")
+        #}
+      #}
 
       if(sum(tau[2:length(tau)]) == 0) break
       
@@ -1311,8 +1722,13 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
 
   if(verbose) cat("\nFinal " ,tau, ":\n")
 
+
+     if(isStoreSigma){
+        gen_sp_Sigma_multiV(W, tau)
+     }
+
     #added these steps after tau is estimated 04-14-2018
-  re.coef = Get_Coef_multiV(y, X, tau, family, alpha, eta,  offset,verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO=FALSE)
+  re.coef = Get_Coef_multiV(y, X, tau, family, alpha, eta,  offset,verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO=FALSE, var_weights = var_weights)
   cov = re.coef$cov
   alpha = re.coef$alpha
   eta = re.coef$eta
@@ -1322,6 +1738,27 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
   converged = ifelse(i < maxiter, TRUE, FALSE)
   res = y - mu
 
+
+  print("y[1:20]")
+  print(y[1:20])
+
+
+  print("mu[1:20]")
+  print(mu[1:20])
+
+  print("res")
+  print(res[1:20])
+
+  res_scaled = res*as.vector(weights(fit0))
+  print("res_scaled")
+  print(res_scaled[1:20])
+  
+  
+  res_scaled2 = res*as.vector(weights(fit0))/tau[1]
+  print("res_scaled2")
+  print(res_scaled2[1:20])
+
+
   if(family$family == "binomial"){
     mu2 = mu * (1-mu)
     traitType = "binary"
@@ -1330,6 +1767,7 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
     traitType = "count"
   }else if(family$family == "gaussian"){
     mu2 = rep((1/(tau[1])),length(res))
+    #mu2 = rep(1,length(res))	  
     traitType = "quantitative"
   }
 
@@ -1342,6 +1780,11 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
 
   #mu2 = mu * (1-mu)
 
+   if(!is.null(var_weights)){
+        mu2 = mu2 * var_weights
+   }
+
+
   if(!isCovariateOffset){
     obj.noK = ScoreTest_NULL_Model(mu, mu2, y, X)
     glmmResult = list(theta=tau, coefficients=alpha, linear.predictors=eta, fitted.values=mu, Y=Y, residuals=res, cov=cov, converged=converged,sampleID = subPheno$IID, obj.noK=obj.noK, y = y, X = X, traitType=traitType, isCovariateOffset = isCovariateOffset)
@@ -1358,6 +1801,9 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
   cat("t_end_null - t_begin, fitting the NULL model without LOCO took\n")
   print(t_end_null - t_begin)
   if(!isLowMemLOCO & LOCO){
+     if(isStoreSigma){
+        gen_sp_Sigma_multiV(re.coef$W, tau)
+     }	  
     set_Diagof_StdGeno_LOCO()
     glmmResult$LOCOResult = list()
     for (j in 1:22){
@@ -1367,7 +1813,7 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
         cat("leave chromosome ", j, " out\n")
         setStartEndIndex(startIndex, endIndex, j-1)
         t_begin_Get_Coef_LOCO = proc.time()
-        re.coef_LOCO = Get_Coef_multiV(y, X, tau, family, alpha, eta,  offset,verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO=TRUE)
+        re.coef_LOCO = Get_Coef_multiV(y, X, tau, family, alpha, eta,  offset,verbose=verbose, maxiterPCG=maxiterPCG, tolPCG = tolPCG, maxiter=maxiter, LOCO=TRUE, var_weights = var_weights)
         t_end_Get_Coef_LOCO = proc.time()
         cat("t_end_Get_Coef_LOCO - t_begin_Get_Coef_LOCO\n")
         print(t_end_Get_Coef_LOCO - t_begin_Get_Coef_LOCO)
@@ -1388,6 +1834,10 @@ glmmkin.ai_PCG_Rcpp_multiV = function(bedFile, bimFile, famFile, Xorig, isCovari
           mu2 = rep((1/(tau[1])),length(res))
         }
 
+	if(!is.null(var_weights)){
+          mu2 = mu2 * var_weights
+   	}
+
         if(!is.null(out.transform) & is.null(fit0$offset)){
           coef.alpha<-Covariate_Transform_Back(alpha, out.transform$Param.transform)
         }else{
diff --git a/R/SAIGE_fitGLMM_fast_multiV_NB.R b/R/SAIGE_fitGLMM_fast_multiV_NB.R
new file mode 100644
index 00000000..76537aca
--- /dev/null
+++ b/R/SAIGE_fitGLMM_fast_multiV_NB.R
@@ -0,0 +1,240 @@
+#Fits the null glmm
+glmmkin.ai_PCG_Rcpp_multiV_NB = function(bedFile, bimFile, famFile, Xorig, isCovariateOffset, fit0, tau=c(0,0), fixtau = c(0,0), maxiter =20, tol = 0.02, verbose = TRUE, nrun=30, tolPCG = 1e-5, maxiterPCG = 500, subPheno, indicatorGenoSamplesWithPheno, obj.noK, out.transform, tauInit, memoryChunk, LOCO, chromosomeStartIndexVec, chromosomeEndIndexVec, traceCVcutoff, isCovariateTransform, isDiagofKinSetAsOne, isLowMemLOCO, covarianceIdxMat = NULL, isStoreSigma = FALSE, useSparseGRMtoFitNULL = TRUE, useGRMtoFitNULL = TRUE) {
+  #Fits the null generalized linear mixed model for a poisson, binomial, and gaussian
+  #Args:
+  #  genofile: string. Plink file for the M1 markers to be used to construct the genetic relationship matrix
+  #  fit0: glm model. Logistic model output (with no sample relatedness accounted for)
+  #  tau: vector for iniial values for the variance component parameter estimates
+  #  fixtau: vector for fixed tau values
+  #  maxiter: maximum iterations to fit the glmm model
+  #  tol: tolerance for tau estimating to converge
+  #  verbose: whether outputting messages in the process of model fitting
+  #  nrun: integer. Number of random vectors used for trace estimation
+  #  tolPCG: tolerance for PCG to converge
+  #  maxiterPCG: maximum iterations for PCG to converge
+  #  subPheno: data set with samples having non-missing phenotypes and non-missing genotypes (for M1 markers)
+  #  obj.noK: model output from the SPAtest::ScoreTest_wSaddleApprox_NULL_Model
+  #  out.transform: output from the function Covariate_Transform
+  #  tauInit: vector for iniial values for the variance component parameter estimates
+  #  memoryChunk: integer or float. The size (Gb) for each memory chunk
+  #  LOCO:logical. Whether to apply the leave-one-chromosome-out (LOCO) option.
+  #  chromosomeStartIndexVec: integer vector of length 22. Contains start indices for each chromosome, starting from 0
+  #  chromosomeEndIndexVec: integer vector of length. Contains end indices for each chromosome
+  #  traceCVcutoff: threshold for the coefficient of variation for trace estimation
+  #Returns:
+  #  model output for the null glmm
+
+  t_begin = proc.time()
+  print(t_begin)
+
+  subSampleInGeno = subPheno$IndexGeno
+  if(is.null(subPheno$IndexGeno)){
+	subSampleInGeno = subPheno$IndexPheno 
+  }	  
+  if(verbose){
+    print("Start reading genotype plink file here")
+  }
+
+  #print("subSampleInGeno")
+  #print(subSampleInGeno)
+
+  set_dup_sample_index(as.numeric(factor(subPheno$IID, levels =  unique(subPheno$IID))))
+
+  #if((!useSparseGRMtoFitNULL & useGRMtoFitNULL) | (skipVarianceRatioEstimation)){
+  print(bedFile)
+  if(bedFile != "" & useGRMtoFitNULL){
+  print("HEREHRE")
+  print(subSampleInGeno[1:10])
+  print(indicatorGenoSamplesWithPheno[1:10])
+
+  re1 = system.time({setgeno(bedFile, bimFile, famFile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne)})
+  }
+  if(verbose){
+    print("Genotype reading is done")
+  }
+
+  if (LOCO){
+    MsubIndVec = getQCdMarkerIndex()
+    chrVec = data.table:::fread(bimFile, header = F)[,1]
+    chrVec = chrVec[which(MsubIndVec == TRUE)]
+    updatechrList = updateChrStartEndIndexVec(chrVec)
+    LOCO = updatechrList$LOCO
+    chromosomeStartIndexVec = updatechrList$chromosomeStartIndexVec
+    chromosomeEndIndexVec = updatechrList$chromosomeEndIndexVec
+  }
+
+  family = fit0$family
+  y = fit0$y
+  n = length(y)
+  X = model.matrix(fit0)
+  offset = fit0$offset
+  
+  print("offset")
+  print(offset[1:10])
+
+  if(is.null(offset)){
+    offset = rep(0, n)
+  }
+
+
+  wts <- model.weights(fit0)
+  if (is.null(wts)) wts <- rep(1, n)
+  w = fit0$prior.weights
+  eta = fit0$linear.predictors
+  print("eta")
+  print(eta[1:10])
+  zz = eta + fit0$residuals - offset
+  wz = fit0$weights
+  invwt <- 1/(wz + 1e-04)
+  #invwt <- (wz + 1e-04)
+ 
+  print("invwt")
+  print(invwt[1:10])
+
+  y = fit0$y
+
+  mu = fit0$fitted.values
+  mu.eta = family$mu.eta(eta)
+  Y = eta - offset + (y - mu)/mu.eta
+  print("Y")
+  print(Y[1:10])
+  zz <- eta + fit0$residuals - offset
+  print("zz")
+  print(zz[1:10])
+  sqrtW = mu.eta/sqrt(fit0$family$variance(mu))
+  W = sqrtW^2
+
+  #alpha0 = fit0$coef
+  #eta0 = eta
+  datanew = cbind(X, zz)
+  datanew = as.data.frame(datanew)
+  colnames(datanew)[ncol(datanew)] = "y"
+  newformula = as.formula(paste0("y ~ ", strsplit(as.character(fit0$formula), split="~")[[3]]))
+
+  print("head(datanew)")
+  print(head(datanew))
+  fit0_gaussian = glm(newformula, data = datanew,
+                  family = gaussian(link = "identity"))
+
+  family <- NegBin()
+  fam <- family
+
+
+  for (i in seq_len(maxiter)) {
+    W = sqrtW^2
+    if(verbose) cat("\nIteration ", i, tau, ":\n")
+    datanew = cbind(X, zz)    
+  datanew = as.data.frame(datanew)
+    colnames(datanew)[ncol(datanew)] = "y"
+  newformula = as.formula(paste0("y ~ ", strsplit(as.character(fit0$formula), split="~")[[3]]))
+  fit0_gaussian = glm(newformula, data = datanew,
+                  family = gaussian(link = "identity"), weights=invwt)
+
+
+
+       system.time(modglmm_gaussian <- glmmkin.ai_PCG_Rcpp_multiV(bedFile, bimFile, famFile, Xorig, isCovariateOffset,
+                fit0_gaussian, tau = tau, fixtau = fixtau, maxiter = maxiter,
+                tol = tol, verbose = TRUE, nrun = nrun, tolPCG = tolPCG,
+                maxiterPCG = maxiterPCG, subPheno = subPheno, indicatorGenoSamplesWithPheno = indicatorGenoSamplesWithPheno,
+                obj.noK = obj.noK, out.transform = out.transform,
+                tauInit = tauInit, memoryChunk = memoryChunk,
+                LOCO = LOCO, chromosomeStartIndexVec = chromosomeStartIndexVec,
+                chromosomeEndIndexVec = chromosomeEndIndexVec,
+                traceCVcutoff = traceCVcutoff, isCovariateTransform = isCovariateTransform,
+                isDiagofKinSetAsOne = isDiagofKinSetAsOne,
+                isLowMemLOCO = isLowMemLOCO, covarianceIdxMat = covarianceIdxMat, isStoreSigma = isStoreSigma, useSparseGRMtoFitNULL = useSparseGRMtoFitNULL, useGRMtoFitNULL = useGRMtoFitNULL)) 
+      etaold = eta
+      eta = modglmm_gaussian$fitted.values + offset
+
+      print("modglmm_gaussian$fitted.value")
+      print(modglmm_gaussian$fitted.value[1:10])
+
+      if (i > 1 & sum((eta - etaold)^2) < 1e-05 * sum(eta^2)) break
+      mu <- fam$linkinv(eta)
+      mu.eta.val <- fam$mu.eta(eta)
+      mu.eta.val <- ifelse(mu.eta.val == 0, 1e-04, mu.eta.val) 
+#      print("mu")
+#print(mu[1:20]) 
+      varmu <- fam$variance(mu)
+#print("varmu")
+#print(varmu[1:20])
+      varmu <- ifelse(varmu == 0, 1e-04, varmu)
+      zz <- eta + (y - mu)/mu.eta.val - offset
+      wz <- w * mu.eta.val^2/varmu
+      wz <- ifelse(wz == 0, 1e-04, wz)
+      invwt <- 1/wz
+      #invwt <- wz
+
+	print("zz")
+       print(zz[1:10])
+       print("mu")
+       print(mu[1:10])
+	print("invwt")
+       print(invwt[1:10])
+
+
+      th <- suppressWarnings( MASS::theta.ml(y=y, mu=mu, n=sum(wts), weights=wts, limit=10, trace=FALSE) )
+      if (is.null(th)) th <- fam$theta
+      fam <- NegBin(theta = th)
+
+  }
+
+  if(verbose) cat("\nFinal " ,modglmm_gaussian$theta, ":\n")
+
+  print("fam$theta")
+  print(fam$theta)
+
+  print("eta[1:10]")
+  print(eta[1:10])
+  print("mu[1:10]")
+  print(mu[1:10])
+      mu <- fam$linkinv(eta)
+      mu.eta.val <- fam$mu.eta(eta)
+      mu.eta.val <- ifelse(mu.eta.val == 0, 1e-04, mu.eta.val)
+      varmu <- fam$variance(mu)
+      varmu <- ifelse(varmu == 0, 1e-04, varmu)
+
+
+
+  converged = ifelse(i < maxiter, TRUE, FALSE)
+  #res = y - mu
+  #mu2 = fit0$family$variance(mu)
+  traitType = "count_nb"
+
+  print(names(modglmm_gaussian))
+  print(modglmm_gaussian$coefficients)
+  print(modglmm_gaussian$alpha)
+
+  glmmResult = modglmm_gaussian
+
+  mu2 = varmu
+
+  print("mu2 HEREHREHREHREHRERHE")
+  print(mu2[1:10])
+  print("y[1:10]")
+  print(y[1:10])
+
+
+  #mu2 = mu + (mu^2/fam$theta)
+  res = y - mu
+
+  if(!isCovariateOffset){
+    obj.noK = ScoreTest_NULL_Model(mu, mu2, y, X)
+    glmmResult$X = X
+    glmmResult = list(theta=modglmm_gaussian$theta, coefficients=modglmm_gaussian$coefficients, linear.predictors=eta, fitted.values=mu, Y=Y, residuals=res, cov=cov, converged=converged,sampleID = modglmm_gaussian$sampleID, obj.noK=obj.noK, y = y, X = modglmm_gaussian$X, traitType=traitType, isCovariateOffset = modglmm_gaussian$isCovariateOffset)
+  }else{
+    obj.noK = ScoreTest_NULL_Model(mu, mu2, y, Xorig)
+    glmmResult$X = Xorig
+    glmmResult = list(theta=modglmm_gaussian$theta, coefficients=modglmm_gaussian$coefficients, linear.predictors=eta, fitted.values=mu, Y=Y, residuals=res, cov=cov, converged=converged,sampleID = modglmm_gaussian$sampleID, obj.noK=obj.noK, y = y, X = modglmm_gaussian$Xorig, traitType=traitType, isCovariateOffset = modglmm_gaussian$isCovariateOffset)
+  }
+  glmmResult$traitType = traitType
+  glmmResult$theta[1] = 1
+  glmmResult$theta_overdispersion = fam$theta
+  
+
+  #if(isLowMemLOCO & LOCO){
+  #  glmmResult$chromosomeStartIndexVec = modglmm_gaussian$chromosomeStartIndexVec
+  #  glmmResult$chromosomeEndIndexVec = modglmm_gaussian$chromosomeEndIndexVec
+  #}
+  return(glmmResult)
+}
diff --git a/R/readInGLMM.R b/R/readInGLMM.R
index fe295968..7b23d715 100644
--- a/R/readInGLMM.R
+++ b/R/readInGLMM.R
@@ -126,8 +126,8 @@ ReadModel = function(GMMATmodelFile = "", chrom="", LOCO=TRUE, is_Firth_beta=FAL
     modglmm$obj_cc$pi_1 = modglmm$mu2
   }else if(modglmm$traitType == "quantitative"){
     modglmm$mu2 = (1/tau[1])*rep(1,N)
-  }else if(obj.glmm.null$traitType == "count"){
-    modglmm$mu2 = modglmml$mu
+  }else if(modglmm$traitType == "count"){
+    modglmm$mu2 = modglmm$mu
   }
  #if(FALSE){
 
diff --git a/R/test.log b/R/test.log
new file mode 100644
index 00000000..d4999c90
--- /dev/null
+++ b/R/test.log
@@ -0,0 +1 @@
+Fatal error: cannot open file 'step1_fitNULLGLMM_1.1.3_Poisson.R': No such file or directory
diff --git a/src/GENO_null.cpp b/src/GENO_null.cpp
new file mode 100644
index 00000000..4e80bebf
--- /dev/null
+++ b/src/GENO_null.cpp
@@ -0,0 +1,1016 @@
+#define ARMA_USE_SUPERLU 1
+//[[Rcpp::depends(RcppArmadillo)]]
+#include <RcppArmadillo.h>
+//[[Rcpp::depends(RcppParallel)]]
+#include <RcppParallel.h>
+#include <omp.h>
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include <cmath>
+#include <ctime>// include this header for calculating execution time
+#include <cassert>
+#include <boost/date_time.hpp> // for gettimeofday and timeval
+#include "getMem.hpp"
+#include "GENO_null.hpp"
+
+
+using namespace Rcpp;
+using namespace std;
+using namespace RcppParallel;
+
+namespace NullGENO {
+
+/*
+NullGenoClass::NullGenoClass(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int> & subSampleInGeno, std::vector<bool> & indicatorGenoSamplesWithPheno, float memoryChunk, bool  isDiagofKinSetAsOne)
+{
+	
+	setGenoObj(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne);
+
+}
+*/
+
+
+NullGenoClass::NullGenoClass(){
+	
+}	
+
+
+void NullGenoClass::setStdGenoLookUpArr(float mafVal, float invsdVal, arma::fvec & stdGenoLookUpArr){
+                float mafVal2 = 2*mafVal;
+                stdGenoLookUpArr(0) = (0-mafVal2)*invsdVal;
+                stdGenoLookUpArr(1) = (1-mafVal2)*invsdVal;
+                stdGenoLookUpArr(2) = (2-mafVal2)*invsdVal;
+}
+
+
+
+void NullGenoClass::setSparseKinLookUpArr(float mafVal, float invsdVal){
+                float mafVal2 = 2*mafVal;
+                float a0 = (0-mafVal2)*invsdVal;
+                float a1 = (1-mafVal2)*invsdVal;
+                float a2 = (2-mafVal2)*invsdVal;
+
+                sKinLookUpArr[0][0] = a0*a0;
+                sKinLookUpArr[0][1] = a0*a1;
+                sKinLookUpArr[0][2] = a0*a2;
+                sKinLookUpArr[1][0] = sKinLookUpArr[0][1];
+                sKinLookUpArr[1][1] = a1*a1;
+                sKinLookUpArr[1][2] = a1*a2;
+                sKinLookUpArr[2][0] = sKinLookUpArr[0][2];
+                sKinLookUpArr[2][1] = sKinLookUpArr[1][2];
+                sKinLookUpArr[2][2] = a2*a2;
+
+}
+
+void NullGenoClass::setBit(unsigned char & ch, int ii, int aVal, int bVal){
+
+                if (bVal == 1 && aVal == 1){
+                        ch ^= char(1 << ((ii*2) + 1)); //set a to be 1
+
+                }else if(bVal == 0){
+                        ch ^= char(1 << (ii*2)); //change b to 0
+
+                        if(aVal == 1){
+                                ch ^= char(1 << ((ii*2) + 1)); //change a to 1
+                        }
+                }
+}
+
+
+void NullGenoClass::setGenotype(unsigned char* c, const int pos, const int geno) {
+                (*c) |= (geno << (pos << 1));
+}
+
+
+void NullGenoClass::getGenotype(unsigned char* c, const int pos, int& geno) {
+                geno = ((*c) >> (pos << 1)) & 0x3;  // 0b11 = 0x3
+}
+
+void NullGenoClass::Init_OneSNP_Geno(){
+                m_size_of_esi = (Nnomissing+3)/4;
+                int k = 8;
+                while (k > 0){
+                        -- k;
+                        m_bits_val[k] = 1 << k;
+                }
+}
+
+arma::ivec* NullGenoClass::Get_OneSNP_Geno(size_t SNPIdx){
+               m_OneSNP_Geno.zeros(Nnomissing);
+
+                //avoid large continuous memory usage
+                int indexOfVectorPointer = SNPIdx/numMarkersofEachArray;
+                int SNPIdxinVec = SNPIdx % numMarkersofEachArray;
+                ////////////////
+
+                size_t Start_idx = m_size_of_esi * SNPIdxinVec;
+                size_t ind= 0;
+                unsigned char geno1;
+                int bufferGeno;
+                for(size_t i=Start_idx; i< Start_idx+m_size_of_esi - 1; i++){
+                        //geno1 = genoVec[i];
+                        geno1 = genoVecofPointers[indexOfVectorPointer]->at(i); //avoid large continuous memory usage
+                        for(int j=0; j<4; j++){
+                                int b = geno1 & 1 ;
+                                geno1 = geno1 >> 1;
+                                int a = geno1 & 1 ;
+                                bufferGeno = 2-(a+b);
+                                m_OneSNP_Geno[ind] = bufferGeno;
+                                ind++;
+                                geno1 = geno1 >> 1;
+                                //if(ind >= Nnomissing){
+
+                                ////printf("%d, %d-%d-%d-%f-%d\n",Start_idx, genoVec[i] ,a ,b , m_OneSNP_Geno[ind-1] , m_size_of_esi);
+                                //        return & m_OneSNP_Geno;
+                                //}
+                        }
+                }
+
+                size_t i = Start_idx+m_size_of_esi - 1;
+                geno1 = genoVecofPointers[indexOfVectorPointer]->at(i);
+                for(int j=0; j<4; j++){
+                                int b = geno1 & 1 ;
+                                geno1 = geno1 >> 1;
+                                int a = geno1 & 1 ;
+                                bufferGeno = 2-(a+b);
+                                m_OneSNP_Geno[ind] = bufferGeno;
+                                ind++;
+                                geno1 = geno1 >> 1;
+                                if(ind >= Nnomissing){
+
+                                ////printf("%d, %d-%d-%d-%f-%d\n",Start_idx, genoVec[i] ,a ,b , m_OneSNP_Geno[ind-1] , m_size_of_esi);
+                                        return & m_OneSNP_Geno;
+                                }
+                }
+
+                return & m_OneSNP_Geno;
+ }
+
+
+
+arma::ivec* NullGenoClass::Get_OneSNP_Geno_forVarRatio(size_t SNPIdx){
+                m_OneSNP_Geno.zeros(Nnomissing);
+
+                //avoid large continuous memory usage
+                int indexOfVectorPointer = SNPIdx/numMarkersofEachArray;
+                int SNPIdxinVec = SNPIdx % numMarkersofEachArray;
+                ////////////////
+
+                size_t Start_idx = m_size_of_esi * SNPIdxinVec;
+                size_t ind= 0;
+                unsigned char geno1;
+                int bufferGeno;
+                for(size_t i=Start_idx; i< Start_idx+m_size_of_esi-1; i++){
+                        //geno1 = genoVec[i];
+                        geno1 = genoVecofPointers_forVarRatio[indexOfVectorPointer]->at(i); //avoid large continuous memory usage
+                        for(int j=0; j<4; j++){
+                                int b = geno1 & 1 ;
+                                geno1 = geno1 >> 1;
+                                int a = geno1 & 1 ;
+                                bufferGeno = 2-(a+b);
+                                m_OneSNP_Geno[ind] = bufferGeno;
+                                ind++;
+                                geno1 = geno1 >> 1;
+                                //if(ind >= Nnomissing){
+
+                                //printf("%d, %d-%d-%d-%f-%d\n",Start_idx, genoVec[i] ,a ,b , m_OneSNP_Geno[ind-1] , m_size_of_esi);
+                                //        return & m_OneSNP_Geno;
+                                //}
+                        }
+                }
+
+                size_t i = Start_idx+m_size_of_esi-1;
+                geno1 = genoVecofPointers_forVarRatio[indexOfVectorPointer]->at(i); //avoid large continuous memory usage
+                for(int j=0; j<4; j++){
+                                int b = geno1 & 1 ;
+                                geno1 = geno1 >> 1;
+                                int a = geno1 & 1 ;
+                                bufferGeno = 2-(a+b);
+                                m_OneSNP_Geno[ind] = bufferGeno;
+                                ind++;
+                                geno1 = geno1 >> 1;
+                                if(ind >= Nnomissing){
+
+                                //printf("%d, %d-%d-%d-%f-%d\n",Start_idx, genoVec[i] ,a ,b , m_OneSNP_Geno[ind-1] , m_size_of_esi);
+                                        return & m_OneSNP_Geno;
+                                }
+                  }
+
+                return & m_OneSNP_Geno;
+}
+
+
+
+void NullGenoClass::Get_OneSNP_Geno_atBeginning(size_t SNPIdx, vector<int> & indexNA, vector<unsigned char> & genoVecOneMarkerOld, float & altFreq, float & missingRate, int & mac,  int & alleleCount, bool & passQC, size_t SNPIdx_new, bool & passVarRatio , size_t SNPIdx_vr){
+	                arma::ivec m_OneSNP_GenoTemp;
+                m_OneSNP_GenoTemp.zeros(N);
+                m_OneSNP_Geno.zeros(Nnomissing);
+                int m_size_of_esi_temp = (N+3)/4;
+                size_t ind= 0;
+                unsigned char geno1;
+                int bufferGeno;
+                int u;
+                alleleCount = 0;
+                int numMissing = 0;
+                for(int i=0; i< (m_size_of_esi_temp - 1); i++){
+                        geno1 = genoVecOneMarkerOld[i];
+                        for(int j=0; j<4; j++){
+                                u = j & 3;
+
+                                int b = geno1 & 1 ;
+                                geno1 = geno1 >> 1;
+                                int a = geno1 & 1 ;
+                                if (b == 1 && a == 0){
+                                        bufferGeno = 3;
+                                }else if(b == 0 && a == 0){
+                                        bufferGeno = 2;
+                                }else if(b == 0 && a == 1){
+                                        bufferGeno = 1;
+                                }else if(b == 1 && a == 1){
+                                        bufferGeno = 0;
+                                }else{
+                                        cout << "Error GENO!!\n";
+                                        break;
+                                }
+
+
+                                //getGenotype(&geno1, u, bufferGeno);
+                                //printf("%d", geno1);
+        //                      std::cout << "bufferGeno " << bufferGeno << std::endl;
+                                /*
+                                switch(geno1){
+                                 case HOM_REF: break;
+                                 case HET: sum+=1; break;
+                                 case HOM_ALT: sum+=2; break;
+                                 case MISSING: numMissing++; break;
+                                }
+                                */
+                                m_OneSNP_GenoTemp[ind] = bufferGeno;
+                                //if(SNPIdx == 0){
+                                //      std::cout << "[ind] " << ind << std::endl;
+                                //      std::cout << "indicatorGenoSamplesWithPheno_in[ind] " << indicatorGenoSamplesWithPheno_in[ind] << std::endl;
+                                //}
+                                if(indicatorGenoSamplesWithPheno_in[ind]){
+                                        if(bufferGeno == 3){
+        //                                      std::cout << "SNPIdx " << SNPIdx << std::endl;
+        //                                      std::cout << "ind " << ind << std::endl;
+                                                numMissing++;
+                                                //indexNA.push_back(ptrsubSampleInGeno[ind])
+                                        }else{
+                                                alleleCount = alleleCount + bufferGeno;
+                                        }
+                                }
+                                ind++;
+                                geno1 = geno1 >> 1;
+                          }
+
+              }
+		                int i = m_size_of_esi_temp - 1;
+                geno1 = genoVecOneMarkerOld[i];
+                //std::cout << "N " << N << std::endl;
+                //while(ind < N){
+                        for(int j=0; j<4; j++){
+                                u = j & 3;
+
+                                int b = geno1 & 1 ;
+                                geno1 = geno1 >> 1;
+                                int a = geno1 & 1 ;
+                                if (b == 1 && a == 0){
+                                        bufferGeno = 3;
+                                }else if(b == 0 && a == 0){
+                                        bufferGeno = 2;
+                                }else if(b == 0 && a == 1){
+                                        bufferGeno = 1;
+                                }else if(b == 1 && a == 1){
+                                        bufferGeno = 0;
+                                }else{
+                                        cout << "Error GENO!!\n";
+                                        break;
+                                }
+
+                                m_OneSNP_GenoTemp[ind] = bufferGeno;
+                                //if(SNPIdx == 0){
+                                //        std::cout << "[ind] " << ind << std::endl;
+                                //        std::cout << "indicatorGenoSamplesWithPheno_in[ind] " << indicatorGenoSamplesWithPheno_in[ind] << std::endl;
+                                //}
+                                if(indicatorGenoSamplesWithPheno_in[ind]){
+                                        if(bufferGeno == 3){
+        //                                      std::cout << "SNPIdx " << SNPIdx << std::endl;
+        //                                      std::cout << "ind " << ind << std::endl;
+                                                numMissing++;
+                                        }else{
+                                                alleleCount = alleleCount + bufferGeno;
+                                        }
+                                }
+                                ind++;
+                                geno1 = geno1 >> 1;
+                                if(ind == (N)){
+                                break;
+                                }
+                          }
+                //}
+
+
+              altFreq = alleleCount/float((Nnomissing-numMissing) * 2);
+              //sum = 0;
+              //std::cout << "missingRate " << missingRate << std::endl;
+              //std::cout << "maxMissingRate " << maxMissingRate << std::endl;
+              missingRate = numMissing/float(Nnomissing);
+
+              //int indxInOut = 0;
+              //if(minMAFtoConstructGRM > 0){
+              //if(altFreq >= minMAFtoConstructGRM && altFreq <= (1-minMAFtoConstructGRM) && missingRate <= maxMissingRate){
+                int fillinMissingGeno = int(round(2*altFreq));
+
+                if(numMissing > 0){
+                       //for(int indx=0; indx < Nnomissing; indx++){
+                                                //cout << "HERE5\n";
+                        //      u = indx & 3;
+                        //      bufferGeno = m_OneSNP_GenoTemp[ptrsubSampleInGeno[indx] - 1];
+                        alleleCount = alleleCount + fillinMissingGeno*numMissing;
+
+                        //              if(bufferGeno == 3){
+                        //                      bufferGeno = fillinMissingGeno;
+                        //                      alleleCount = alleleCount + bufferGeno;
+                        //              }
+                        //      }
+                        /*
+                                //setGenotype(&geno2, u, bufferGeno);
+                                if(bufferGeno == 0){
+                                        setGenotype(&geno2, u, HOM_ALT);
+                                }else if(bufferGeno == 1){
+                                        setGenotype(&geno2, u, HET);
+                                }else if(bufferGeno == 2){
+                                        setGenotype(&geno2, u, HOM_REF);
+                                }
+                                //else{
+                                //        setGenotype(&geno1, u, MISSING);
+                                        //m_OneSNP_Geno[j] = 0;  //12-18-2017
+                                //}
+
+                                if(u == 3 || indx == (Nnomissing-1)){
+                                        genoVecofPointers[SNPIdx/numMarkersofEachArray]->push_back(geno2); //avoid large continuous memory usage
+                                        geno2 = 0;
+                                }
+                */
+                }
+
+		             altFreq = alleleCount/float(Nnomissing * 2);
+
+             unsigned char geno2;
+             passQC = false;
+             passVarRatio = false;
+             float maf = std::min(altFreq, 1-altFreq);
+             mac = std::min(alleleCount, int(Nnomissing) * 2 - alleleCount);
+
+
+                if(maf >= minMAFtoConstructGRM && missingRate <= maxMissingRate){
+                        passQC = true;
+                }
+                if(isVarRatio){
+                        if(g_maxMACVarRatio != -1){ //if estimating categorical variance ratios
+                           if(mac >= g_minMACVarRatio && mac < g_maxMACVarRatio){
+                                passVarRatio = true;
+                                genoVecofPointers_forVarRatio[SNPIdx_vr] = new vector<unsigned char>;
+                                genoVecofPointers_forVarRatio[SNPIdx_vr]->reserve(numMarkersofEachArray*ceil(float(Nnomissing)/4));
+                           }else if(mac >= g_maxMACVarRatio){
+                                   //randomly select 200 markers for estimating the variance ratio for the last MAC category
+                                   //if(numberofMarkers_varRatio_common < 200){
+                                        //if(static_cast<int>(SNPIdx) == 123){
+                                        //      std::cout << "123" << std::endl;
+                                        //      bool isIng_randMarkerIndforVR = arma::any(g_randMarkerIndforVR == static_cast<int>(SNPIdx));
+                                        //      std::cout << "isIng_randMarkerIndforVR " << isIng_randMarkerIndforVR << std::endl;
+                                        //}
+                                        passVarRatio = arma::any(g_randMarkerIndforVR == static_cast<int>(SNPIdx));
+                                        if(passVarRatio){
+                                                //std::cout << "SNPIdx " << SNPIdx << std::endl;
+                                                genoVecofPointers_forVarRatio[SNPIdx_vr] = new vector<unsigned char>;
+                                                genoVecofPointers_forVarRatio[SNPIdx_vr]->reserve(numMarkersofEachArray*ceil(float(Nnomissing)/4));
+                                                numberofMarkers_varRatio_common = numberofMarkers_varRatio_common + 1;
+                                                //passVarRatio = false;
+                                        }
+                                  //}
+                        //      passVarRatio = true;
+                        }
+                        }else{
+                                if(mac >= g_minMACVarRatio){
+                                   //randomly select 200 markers for estimating the variance ratio for the last MAC category
+                                   //if(numberofMarkers_varRatio_common < 200){
+                                        //if(static_cast<int>(SNPIdx) == 123){
+                                        //      std::cout << "123" << std::endl;
+                                        //      bool isIng_randMarkerIndforVR = arma::any(g_randMarkerIndforVR == static_cast<int>(SNPIdx));
+                                        //      std::cout << "isIng_randMarkerIndforVR " << isIng_randMarkerIndforVR << std::endl;
+                                        //}
+                                        passVarRatio = arma::any(g_randMarkerIndforVR == static_cast<int>(SNPIdx));
+                                        if(passVarRatio){
+                                                //std::cout << "SNPIdx " << SNPIdx << std::endl;
+                                                genoVecofPointers_forVarRatio[SNPIdx_vr] = new vector<unsigned char>;
+                                                genoVecofPointers_forVarRatio[SNPIdx_vr]->reserve(numMarkersofEachArray*ceil(float(Nnomissing)/4));
+                                                numberofMarkers_varRatio_common = numberofMarkers_varRatio_common + 1;
+                                                //passVarRatio = false;
+                                        }
+                                  //}
+                        //      passVarRatio = true;
+                        }
+
+
+                        }
+                        //avoid the overlap between markers for GRM and markers for variance ratio estimation
+                        if(passVarRatio){
+                                passQC = false;
+                        }
+                      //}
+                }
+
+                if(passQC | passVarRatio){
+                        for(int indx=0; indx < Nnomissing; indx++){
+                                                //cout << "HERE5\n";
+                              u = indx & 3;
+                              bufferGeno = m_OneSNP_GenoTemp[ptrsubSampleInGeno[indx] - 1];
+                              if(bufferGeno == 3){
+                                bufferGeno = fillinMissingGeno;
+                              }
+                              if(bufferGeno == 0){
+                                        setGenotype(&geno2, u, HOM_ALT);
+                                }else if(bufferGeno == 1){
+                                        setGenotype(&geno2, u, HET);
+                                }else if(bufferGeno == 2){
+                                        setGenotype(&geno2, u, HOM_REF);
+                              }
+                              if(u == 3 || indx == (Nnomissing-1)){
+                                       if(passVarRatio){
+                                                genoVecofPointers_forVarRatio[SNPIdx_vr/numMarkersofEachArray]->push_back(geno2); //avoid large continuous memory usage
+                                        }
+                                        if(passQC){
+						                                                genoVecofPointers[SNPIdx_new/numMarkersofEachArray]->push_back(geno2);
+                                        }
+                                        geno2 = 0;
+                              }
+                        }
+                }
+            // altFreq = alleleCount/float(Nnomissing * 2);
+
+}
+
+int NullGenoClass::Get_OneSNP_StdGeno(size_t SNPIdx, arma::fvec * out ){
+                //avoid large continuous memory usage
+                int indexOfVectorPointer = SNPIdx/numMarkersofEachArray;
+                int SNPIdxinVec = SNPIdx % numMarkersofEachArray;
+                ////////////////
+                //std::cout << "indexOfVectorPointer " << indexOfVectorPointer << std::endl;
+                out->zeros(Nnomissing);
+                //std::cout << "m_size_of_esi " << m_size_of_esi << std::endl;
+                //std::cout << "SNPIdxinVec " << SNPIdxinVec << std::endl;
+                //std::cout << "genoVecofPointers[indexOfVectorPointer]->size() " << genoVecofPointers[indexOfVectorPointer]->size() << std::endl;
+
+
+
+                size_t Start_idx = m_size_of_esi * SNPIdxinVec;
+
+                //std::cout << "Start_idx " << Start_idx << std::endl;
+                size_t ind= 0;
+                unsigned char geno1;
+
+                float freq = alleleFreqVec[SNPIdx];
+                //cout << "Get_OneSNP_StdGeno here" << endl;
+                float invStd = invstdvVec[SNPIdx];
+
+                arma::fvec stdGenoLookUpArr(3);
+                setStdGenoLookUpArr(freq, invStd, stdGenoLookUpArr);
+//              std::cout << "freq " << freq << endl;
+//              std::cout << "invStd " << invStd << endl;
+
+                //setStdGenoLookUpArr(freq, invStd);
+                //std::cout << "stdGenoLookUpArr[0]: " << stdGenoLookUpArr[0] << std::endl;
+                //std::cout << "stdGenoLookUpArr[1]: " << stdGenoLookUpArr[1] << std::endl;
+                //std::cout << "stdGenoLookUpArr[2]: " << stdGenoLookUpArr[2] << std::endl;
+//              cout << "Get_OneSNP_StdGeno here2"  << endl;
+                for(size_t i=Start_idx; i< Start_idx+m_size_of_esi-1; i++){
+//                      geno1 = genoVec[i];
+                        geno1 = genoVecofPointers[indexOfVectorPointer]->at(i);
+
+                        for(int j=0; j<4; j++){
+                        int b = geno1 & 1 ;
+                        geno1 = geno1 >> 1;
+                        int a = geno1 & 1 ;
+                        //(*out)[ind] = ((2-(a+b)) - 2*freq)* invStd;;
+                        (*out)[ind] = stdGenoLookUpArr(2-(a+b));
+//                      std::cout << "a " << a << endl;
+//                      std::cout << "b " << b << endl;
+//                      std::cout << "(*out)[ind] " << (*out)[ind] << endl;
+                        ind++;
+                        geno1 = geno1 >> 1;
+
+//                      if(ind >= Nnomissing){
+//                              cout << "Get_OneSNP_StdGeno " << SNPIdx << endl;
+//                              cout << "Nnomissing " << Nnomissing << endl;
+//                              stdGenoLookUpArr.clear();
+//                              return 1;
+//                      }
+                        }
+                }
+
+
+                size_t i = Start_idx+m_size_of_esi-1;
+                geno1 = genoVecofPointers[indexOfVectorPointer]->at(i);
+
+                for(int j=0; j<4; j++){
+                        int b = geno1 & 1 ;
+                        geno1 = geno1 >> 1;
+                        int a = geno1 & 1 ;
+                        (*out)[ind] = stdGenoLookUpArr(2-(a+b));
+                        ind++;
+                        geno1 = geno1 >> 1;
+
+                        if(ind >= Nnomissing){
+                                stdGenoLookUpArr.clear();
+                                return 1;
+                        }
+                }
+                //cout << "SNPIdx " << SNPIdx << endl;
+
+                stdGenoLookUpArr.clear();
+                return 1;
+}
+
+
+arma::fvec* NullGenoClass::Get_Diagof_StdGeno(){
+
+                arma::fvec * temp = &m_OneSNP_StdGeno;
+                // Not yet calculated
+                //cout << "size(m_DiagStd)[0] " << size(m_DiagStd)[0] << endl;
+                if(size(m_DiagStd)[0] != Nnomissing){
+                        m_DiagStd.zeros(Nnomissing);
+                        for(size_t i=0; i< numberofMarkerswithMAFge_minMAFtoConstructGRM; i++){
+                                //if(alleleFreqVec[i] >= minMAFtoConstructGRM && alleleFreqVec[i] <= 1-minMAFtoConstructGRM){
+
+
+                                Get_OneSNP_StdGeno(i, temp);
+
+                                /*if(i == 0){
+                                        cout << "setgeno mark7 " << i <<  endl;
+                                        for(int j=0; j<10; ++j)
+                                        {
+                                                cout << (*temp)[j] << ' ';
+                                        }
+                                        cout << endl;
+                                }
+                                */
+                                m_DiagStd = m_DiagStd + (*temp) % (*temp);
+
+                                //}
+                //              std::cout << "i " << i << std::endl;
+                //              std::cout << "numberofMarkerswithMAFge_minMAFtoConstructGRM " << numberofMarkerswithMAFge_minMAFtoConstructGRM << std::endl;
+                        }
+
+                }
+/*
+                std::cout << "test\n";
+                for(int i=0; i<10; ++i)
+                {
+                  cout << m_DiagStd[i] << ' ';
+                }
+                cout << endl;
+*/
+                return & m_DiagStd;
+}
+
+
+arma::fvec* NullGenoClass::Get_Diagof_StdGeno_LOCO(){
+                //if(size(m_DiagStd_LOCO)[0] != Nnomissing){
+                //m_DiagStd_LOCO.zeros(Nnomissing);
+                  //      for(size_t i=startIndex; i<= endIndex; i++){
+                                //if(i < startIndex || i > endIndex){
+                //                      if(alleleFreqVec[i] >= minMAFtoConstructGRM && alleleFreqVec[i] <= 1-minMAFtoConstructGRM){
+                  //                            Get_OneSNP_StdGeno(i, temp);
+                    //                          m_DiagStd_LOCO = m_DiagStd_LOCO + (*temp) % (*temp);
+                //                              Msub_MAFge_minMAFtoConstructGRM = Msub_MAFge_minMAFtoConstructGRM + 1;
+                //                      }
+                                //}
+                 //       }
+
+
+                //m_DiagStd_LOCO = m_DiagStd - geno.mtx_DiagStd_LOCO.col(geno.chromIndex);
+                m_DiagStd_LOCO = mtx_DiagStd_LOCO.col(chromIndex);
+                Msub_MAFge_minMAFtoConstructGRM_singleChr  = Msub_MAFge_minMAFtoConstructGRM_byChr(chromIndex);
+                //}
+
+                return & m_DiagStd_LOCO;
+}
+
+
+void NullGenoClass::setGenoObj(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int> & subSampleInGeno, std::vector<bool> & indicatorGenoSamplesWithPheno, float memoryChunk, bool  isDiagofKinSetAsOne){
+
+               //cout << "OK1\n";
+                setKinDiagtoOne = isDiagofKinSetAsOne;
+                ptrsubSampleInGeno = subSampleInGeno;
+                indicatorGenoSamplesWithPheno_in = indicatorGenoSamplesWithPheno;
+                Nnomissing = subSampleInGeno.size();
+                // reset
+                //genoVec.clear();
+                alleleFreqVec.clear();
+                MACVec.clear();
+                invstdvVec.clear();
+
+                M=0;
+                N=0;
+
+                //std::string bedfile = genofile+".bed";
+                //std::string bimfile = genofile+".bim";
+                //std::string famfile = genofile+".fam";
+                std::string junk;
+                //cout << "OK2\n";
+                //count the number of individuals
+                ifstream test_famfile;
+                test_famfile.open(famfile.c_str());
+                if (!test_famfile.is_open()){
+                        printf("Error! fam file not open!");
+                        return ;
+                }
+                int indexRow = 0;
+                while (std::getline(test_famfile,junk)){
+                        indexRow = indexRow + 1;
+                        junk.clear();
+                }
+                N = indexRow;
+                test_famfile.clear();
+                //cout << "OK3\n";
+                //count the number of markers
+                ifstream test_bimfile;
+                test_bimfile.open(bimfile.c_str());
+                if (!test_bimfile.is_open()){
+                        printf("Error! bim file not open!");
+                        return ;
+                }
+                indexRow = 0;
+                while (std::getline(test_bimfile,junk)){
+                        indexRow = indexRow + 1;
+                        junk.clear();
+                }
+                M = indexRow;
+                test_bimfile.clear();
+
+                junk.clear();
+                //cout << "OK3b\n";
+                // Init OneSNP Geno
+                Init_OneSNP_Geno();
+                //cout << "OK3c\n";
+
+                //std::string junk;
+                indexRow = 0;
+                int buffer;
+                int TotalRead=0;
+
+                std::vector<unsigned char> genoVecOneMarkerOld;
+                std::vector<unsigned char> genoVecOneMarkerNew;
+                /////////////////////////////
+                // Added for reserve for genoVec
+                size_t nbyteOld = ceil(float(N)/4);
+                size_t nbyteNew = ceil(float(Nnomissing)/4);
+                size_t reserve = ceil(float(Nnomissing)/4) * M + M*2;
+                cout << "nbyte: " << nbyteOld << endl;
+                cout << "nbyte: " << nbyteNew << endl;
+                cout << "reserve: " << reserve << endl;
+
+                genoVecOneMarkerOld.reserve(nbyteOld);
+                genoVecOneMarkerOld.resize(nbyteOld);
+                //genoVec.reserve(reserve);
+
+                //cout << "OK4\n";
+
+                ifstream test_bedfile;
+                test_bedfile.open(bedfile.c_str(), ios::binary);
+                if (!test_bedfile.is_open()){
+                        printf("Error! file open!");
+                        return;
+                }
+                //printf("\nM: %zu, N: %zu, Reserve: %zu\n", M, N, reserveTemp);
+                printf("\nM: %zu, N: %zu\n", M, N);
+		                //test_bedfile.seekg(3);
+                //set up the array of vectors for genotype
+                //numMarkersofEachArray = floor((memoryChunk*pow (10.0, 9.0))/(ceil(float(N)/4)));
+                //cout << "numMarkersofEachArray: " << numMarkersofEachArray << endl;
+                numMarkersofEachArray = 1;
+                //if(M % numMarkersofEachArray == 0){
+                        //numofGenoArray = M / numMarkersofEachArray;
+                        numofGenoArray = M;
+                        genoVecofPointers.resize(numofGenoArray);
+                        genoVecofPointers_forVarRatio.resize(numofGenoArray);
+                        //cout << "size of genoVecofPointers: " << genoVecofPointers.size() << endl;
+                        for (int i = 0; i < numofGenoArray ; i++){
+                                genoVecofPointers[i] = new vector<unsigned char>;
+                                genoVecofPointers[i]->reserve(numMarkersofEachArray*ceil(float(Nnomissing)/4));
+                        }
+
+                //}
+                /*else{
+                        numofGenoArray = M/numMarkersofEachArray + 1;
+                        genoVecofPointers.resize(numofGenoArray);
+                        numMarkersofLastArray = M - (numofGenoArray-1)*numMarkersofEachArray;
+                        cout << "size of genoVecofPointers: " << genoVecofPointers.size() << endl;
+                        try{
+                        for (int i = 0; i < numofGenoArray-1; i++){
+                                genoVecofPointers[i] = new vector<unsigned char>;
+                                genoVecofPointers[i]->reserve(numMarkersofEachArray*ceil(float(Nnomissing)/4));
+                        }
+                        genoVecofPointers[numofGenoArray-1] = new vector<unsigned char>;
+                        genoVecofPointers[numofGenoArray-1]->reserve(numMarkersofLastArray*ceil(float(Nnomissing)/4));
+                        }
+                        catch(std::bad_alloc& ba)
+                        {
+                                std::cerr << "bad_alloc caught1: " << ba.what() << '\n';
+                                exit(EXIT_FAILURE);
+                        }
+                }*/
+
+                cout << "setgeno mark1" << endl;
+                arma::ivec g_randMarkerIndforVR_temp;
+                //randomly select common markers for variance ratio
+                if(isVarRatio){
+                         g_randMarkerIndforVR_temp = arma::randi(1000, arma::distr_param(0,M-1));
+                         g_randMarkerIndforVR = arma::unique(g_randMarkerIndforVR_temp);
+                         //arma::ivec g_randMarkerIndforVR_sort = arma::sort(g_randMarkerIndforVR);
+                         //g_randMarkerIndforVR_sort.print("g_randMarkerIndforVR_sort");
+                }
+                //alleleFreqVec.zeros(M);
+                //invstdvVec.zeros(M);
+                //MACVec.zeros(M);
+                float freq, Std, invStd, missingRate;
+                int alleleCount, mac;
+                std::vector<int> indexNA;
+                int lengthIndexNA;
+                int indexGeno;
+                int indexBit;
+                int fillinMissingGeno;
+                int b2;
+                int a2;
+
+                size_t ind= 0;
+                unsigned char geno1 = 0;
+                int bufferGeno;
+                int u;
+                //std::vector<int> genoVec4Markers(4);
+                //test_bedfile.read((char*)(&genoVecTemp[0]),nbyteTemp*M);
+                bool isPassQC = false;
+                bool isPass_vr = false;
+                cout << "setgeno mark2" << endl;
+                size_t SNPIdx_new = 0;
+                size_t SNPIdx_vr = 0;
+                //Mmafge1perc = 0;
+                for(int i = 0; i < M; i++){
+                        genoVecOneMarkerOld.clear();
+                        genoVecOneMarkerOld.reserve(nbyteOld);
+                        genoVecOneMarkerOld.resize(nbyteOld);
+
+                        test_bedfile.seekg(3+nbyteOld*i);
+                        test_bedfile.read((char*)(&genoVecOneMarkerOld[0]),nbyteOld);
+                        //printf("\nFile read is done: M: %zu, N: %zu, TotalByte %zu\n", M, N, genoVecTemp.size());
+                        //cout << "Imputing missing genotypes and extracting the subset of samples with nonmissing genotypes and phenotypes\n";
+        //              cout << "i is " << i << endl;
+
+                        indexNA.clear();
+                //}
+                        Get_OneSNP_Geno_atBeginning(i, indexNA, genoVecOneMarkerOld, freq, missingRate, mac, alleleCount, isPassQC, SNPIdx_new, isPass_vr, SNPIdx_vr);
+
+                        //std::cout << "freq " << freq << std::endl;
+			                       //std::cout << "freq " << freq << std::endl;
+                        //std::cout << "isPassQC " << isPassQC << std::endl;
+                        if(isPassQC){
+
+                                Std = std::sqrt(2*freq*(1-freq));
+                                if(Std == 0){
+                                        invStd= 0;
+                                } else {
+                                        invStd= 1/Std;
+                                }
+                                invstdvVec0.push_back(invStd);
+                                alleleFreqVec0.push_back(freq);
+                                numberofMarkerswithMAFge_minMAFtoConstructGRM = numberofMarkerswithMAFge_minMAFtoConstructGRM + 1;
+
+                                MACVec0.push_back(mac);
+                                MarkerswithMAFge_minMAFtoConstructGRM_indVec.push_back(true);
+                                SNPIdx_new = SNPIdx_new + 1;
+                        }else{
+                                MarkerswithMAFge_minMAFtoConstructGRM_indVec.push_back(false);
+                        }
+
+                        if(isVarRatio){
+                                if(isPass_vr){
+                                        Std = std::sqrt(2*freq*(1-freq));
+                                        if(Std == 0){
+                                                invStd= 0;
+                                        }else {
+                                                invStd= 1/Std;
+                                        }
+                                        invstdvVec0_forVarRatio.push_back(invStd);
+                                        alleleFreqVec0_forVarRatio.push_back(freq);
+                                        MACVec0_forVarRatio.push_back(mac);
+                                        markerIndexVec0_forVarRatio.push_back(i);
+                                        SNPIdx_vr = SNPIdx_vr + 1;
+                                        numberofMarkers_varRatio = numberofMarkers_varRatio + 1;
+                                }
+                        }
+
+
+                        //m_OneSNP_Geno.clear();
+
+                }//end for(int i = 0; i < M; i++){
+
+                if( minMAFtoConstructGRM > 0 | maxMissingRate < 1){
+                        cout << numberofMarkerswithMAFge_minMAFtoConstructGRM << " markers with MAF >= " << minMAFtoConstructGRM << " and missing rate <= " << maxMissingRate  << endl;
+                }
+                //else{
+                //      cout << M << " markers with MAF >= " << minMAFtoConstructGRM << endl;
+                //}
+
+
+                int numofGenoArray_old = numofGenoArray;
+                if(numberofMarkerswithMAFge_minMAFtoConstructGRM % numMarkersofEachArray == 0){
+                        numofGenoArray = numberofMarkerswithMAFge_minMAFtoConstructGRM / numMarkersofEachArray;
+                        //genoVecofPointers.resize(numofGenoArray);
+                        //cout << "size of genoVecofPointers: " << genoVecofPointers.size() << endl;
+
+                }else{
+                        numofGenoArray = numberofMarkerswithMAFge_minMAFtoConstructGRM/numMarkersofEachArray + 1;
+                }
+//              cout << " numofGenoArray "<< numofGenoArray << endl;
+//              cout << " numofGenoArray_old "<< numofGenoArray_old << endl;
+//              cout << " genoVecofPointers.size() "<< genoVecofPointers.size() << endl;
+                if(numofGenoArray > numofGenoArray_old){
+
+                        for (int i = numofGenoArray; i < numofGenoArray_old ; i++){
+                                delete genoVecofPointers[i];
+                                //genoVecofPointers[i] = new vector<unsigned char>;
+                                //genoVecofPointers[i]->reserve(numMarkersofEachArray*ceil(float(Nnomissing)/4));
+                        }
+                }
+//              cout << " genoVecofPointers.size() "<< genoVecofPointers.size() << endl;
+
+                //genoVecofPointers.resize(MarkerswithMAFge_minMAFtoConstructGRM_indVec);
+
+                invstdvVec.clear();
+                invstdvVec.set_size(numberofMarkerswithMAFge_minMAFtoConstructGRM);
+                alleleFreqVec.clear();
+                alleleFreqVec.set_size(numberofMarkerswithMAFge_minMAFtoConstructGRM);
+                MACVec.clear();
+                MACVec.set_size(numberofMarkerswithMAFge_minMAFtoConstructGRM);
+		                for(int i = 0; i < numberofMarkerswithMAFge_minMAFtoConstructGRM; i++){
+
+                        invstdvVec[i] = invstdvVec0.at(i);
+                        alleleFreqVec[i] = alleleFreqVec0.at(i);
+                        MACVec[i] = MACVec0.at(i);
+
+                }
+        if(isVarRatio){
+                invstdvVec_forVarRatio.clear();
+                invstdvVec_forVarRatio.set_size(numberofMarkers_varRatio);
+                alleleFreqVec_forVarRatio.clear();
+                alleleFreqVec_forVarRatio.set_size(numberofMarkers_varRatio);
+                MACVec_forVarRatio.clear();
+                MACVec_forVarRatio.set_size(numberofMarkers_varRatio);
+                markerIndexVec_forVarRatio.clear();
+                markerIndexVec_forVarRatio.set_size(numberofMarkers_varRatio);
+                for(int i = 0; i < numberofMarkers_varRatio; i++){
+                        invstdvVec_forVarRatio[i] = invstdvVec0_forVarRatio.at(i);
+                        alleleFreqVec_forVarRatio[i] =alleleFreqVec0_forVarRatio.at(i);
+                        MACVec_forVarRatio[i] = MACVec0_forVarRatio.at(i);
+                        markerIndexVec_forVarRatio[i] = markerIndexVec0_forVarRatio.at(i);
+                }
+        }
+
+                test_bedfile.close();
+//              cout << "setgeno mark5" << endl;
+//              printAlleleFreqVec();
+                //printGenoVec();
+                //Get_Diagof_StdGeno();
+//              cout << "setgeno mark6" << endl;
+}//End Function
+
+
+
+void NullGenoClass::printFromgenoVec(unsigned char genoBinary0){
+                unsigned char genoBinary = genoBinary0;
+                for(int j=0; j<4; j++){
+                        int b = genoBinary & 1 ;
+                        genoBinary = genoBinary >> 1;
+                        int a = genoBinary & 1 ;
+                        genoBinary = genoBinary >> 1;
+                        cout << 2-(a+b) << " " << endl;
+                }
+                cout << endl;
+}
+
+
+int NullGenoClass::getM() const{
+                return(M);
+}
+
+int NullGenoClass::getnumberofMarkerswithMAFge_minMAFtoConstructGRM() const{
+                return(numberofMarkerswithMAFge_minMAFtoConstructGRM);
+}
+
+
+int NullGenoClass::getMsub() const{
+                return(Msub);
+}
+
+int NullGenoClass::getStartIndex() const{
+                return(startIndex);
+}
+
+int NullGenoClass::getEndIndex() const{
+                return(endIndex);
+}
+
+int NullGenoClass::getN() const{
+                return(N);
+}
+
+int NullGenoClass::getNnomissing() const{
+                return(Nnomissing);
+}
+
+float NullGenoClass::getAC(int m){
+                return(alleleFreqVec[m]*2*Nnomissing);
+}
+
+float NullGenoClass::getMAC(int m){
+                if(alleleFreqVec[m] > 0.5){
+                        return((1-alleleFreqVec[m])*2*Nnomissing);
+                }else{
+                        return(alleleFreqVec[m]*2*Nnomissing);
+                }
+}
+
+int NullGenoClass::getMsub_MAFge_minMAFtoConstructGRM_in() const{
+                return(numberofMarkerswithMAFge_minMAFtoConstructGRM);
+}
+
+int NullGenoClass::getMsub_MAFge_minMAFtoConstructGRM_singleChr_in() const{
+                return(Msub_MAFge_minMAFtoConstructGRM_singleChr);
+}
+
+void NullGenoClass::Get_Samples_StdGeno(arma::ivec SampleIdsVec){
+                int indexOfVectorPointer;
+                int SNPIdxinVec;
+
+                int numSamples = SampleIdsVec.n_elem;
+                //stdGenoVec.zeros(Nnomissing*numSamples);
+                stdGenoforSamples.clear();
+                stdGenoforSamples.resize(M*numSamples);
+
+                arma::ivec sampleGenoIdxVec;
+                sampleGenoIdxVec.zeros(numSamples);
+                arma::ivec sampleGenoIdxSubVec;
+                sampleGenoIdxSubVec.zeros(numSamples);
+
+                for(int j=0; j < numSamples; j++){
+                        sampleGenoIdxVec[j] = SampleIdsVec[j] / 4;
+                        sampleGenoIdxSubVec[j] = SampleIdsVec[j] % 4;
+                }
+
+
+                int startidx;
+                unsigned char geno1;
+
+                for(int i=0; i < M; i++){
+                        indexOfVectorPointer = i/numMarkersofEachArray;
+                        SNPIdxinVec = i % numMarkersofEachArray;
+                        startidx = m_size_of_esi * SNPIdxinVec;
+
+                        float freq = alleleFreqVec[i];
+                        float invStd = invstdvVec[i];
+
+                        for(int j=0; j < numSamples; j++){
+                                int k = startidx + sampleGenoIdxVec[j];
+                                geno1 = genoVecofPointers[indexOfVectorPointer]->at(k);
+                                for(int q=0; q<4; q++){
+                                        if(q == sampleGenoIdxSubVec[j]){
+                                                int b = geno1 & 1 ;
+                                                geno1 = geno1 >> 1;
+                                                int a = geno1 & 1 ;
+                                                stdGenoforSamples[i*(numSamples)+j] = ((2-(a+b)) - 2*freq)* invStd;
+                                //(*out)[ind] = ((2-(a+b)) - 2*freq)* invStd;;
+                                //ind++;
+                                                geno1 = geno1 >> 1;
+                                        }else{
+                                                geno1 = geno1 >> 1;
+                                                geno1 = geno1 >> 1;
+                                        }
+                                }
+                        }
+                }
+
+        //return(stdGenoVec);
+}
+
+void NullGenoClass::setstartendIndexVec(arma::ivec & t_startIndexVec, arma::ivec & t_endIndexVec){
+
+	startIndexVec = t_startIndexVec;
+	endIndexVec = t_endIndexVec;
+
+}
+
+}	
diff --git a/src/GENO_null.hpp b/src/GENO_null.hpp
new file mode 100644
index 00000000..214b1446
--- /dev/null
+++ b/src/GENO_null.hpp
@@ -0,0 +1,182 @@
+
+#ifndef NullGENO_HPP
+#define NullGENO_HPP
+
+
+#define ARMA_USE_SUPERLU 1
+//[[Rcpp::depends(RcppArmadillo)]]
+#include <RcppArmadillo.h>
+//[[Rcpp::depends(RcppParallel)]]
+#include <RcppParallel.h>
+#include <omp.h>
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include <cmath>
+#include <ctime>// include this header for calculating execution time
+#include <cassert>
+#include <boost/date_time.hpp> // for gettimeofday and timeval
+#include "getMem.hpp"
+using namespace Rcpp;
+using namespace std;
+using namespace RcppParallel;
+
+namespace NullGENO {
+
+class NullGenoClass{
+private:
+        //COPY from RVTEST:
+        // we reverse the two bits as defined in PLINK format
+        const static unsigned char HOM_REF = 0x0;  // 0b00 ;
+        const static unsigned char HET = 0x2;      // 0b10 ;
+        const static unsigned char HOM_ALT = 0x3;  // 0b11 ;
+        const static unsigned char MISSING = 0x1;  // 0b01 ;
+
+	arma::sp_fmat g_I_longl_mat;
+	arma::sp_fmat g_T_longl_mat;
+	arma::uvec g_I_longl_vec;
+	arma::fvec g_T_longl_vec;
+
+public:
+	//to chunk the geno vector to avoid large continuous memory usage
+        int numMarkersofEachArray;
+        int numofGenoArray;
+        int numMarkersofLastArray;
+        std::vector< std::vector<unsigned char>* > genoVecofPointers;
+        ///////////
+        std::vector< std::vector<unsigned char>* > genoVecofPointers_forVarRatio;
+        //arma::fvec g_cateVarRatioMinMACVecExclude;
+        //arma::fvec g_cateVarRatioMaxMACVecInclude;
+        float g_minMACVarRatio;
+        float g_maxMACVarRatio;
+        bool isVarRatio = false;
+        int numberofMarkers_varRatio = 0;
+        int numberofMarkers_varRatio_common = 0;
+        arma::ivec g_randMarkerIndforVR;
+        std::vector<float>      invstdvVec0_forVarRatio;
+        arma::fvec      invstdvVec_forVarRatio;
+         std::vector<float>      alleleFreqVec0_forVarRatio;
+        arma::fvec      alleleFreqVec_forVarRatio;
+        std::vector<int>      MACVec0_forVarRatio;
+        std::vector<int>      markerIndexVec0_forVarRatio;
+        arma::ivec MACVec_forVarRatio;
+        arma::ivec markerIndexVec_forVarRatio;
+	        //vector<unsigned char> genoVec;
+        size_t M;
+        size_t N;
+        size_t Nnomissing;
+        std::vector<float>      invstdvVec0;
+        arma::fvec      invstdvVec;
+        vector<int>     ptrsubSampleInGeno;
+        std::vector<bool> indicatorGenoSamplesWithPheno_in;
+        std::vector<float>      alleleFreqVec0;
+        arma::fvec      alleleFreqVec;
+        arma::ivec      m_OneSNP_Geno;
+        arma::fvec      m_OneSNP_StdGeno;
+        arma::fvec      m_DiagStd;
+        arma::fvec      m_DiagStd_LOCO;
+        arma::fmat      mtx_DiagStd_LOCO;
+
+
+        std::vector<int>        MACVec0; //for variance ratio based on different MAC categories
+        arma::ivec      MACVec;
+        arma::ivec      subMarkerIndex; //for sparse GRM
+        arma::fmat      stdGenoMultiMarkersMat;
+        std::vector<float> stdGenoforSamples; //for sparse GRM
+        std::vector<float>     kinValueVecFinal;
+        float relatednessCutoff;
+        float maxMissingRate;
+	        float minMAFtoConstructGRM;
+
+
+        tbb::concurrent_vector< std::pair<int, int> > indiceVec;
+        arma::ivec xout;
+        arma::ivec yout;
+        bool setKinDiagtoOne;
+        int numberofMarkerswithMAFge_minMAFtoConstructGRM = 0;
+        std::vector<bool> MarkerswithMAFge_minMAFtoConstructGRM_indVec;
+
+
+        size_t Msub;
+        int startIndex;
+	int endIndex;
+        int chromIndex;
+
+
+        arma::ivec startIndexVec;
+        arma::ivec endIndexVec;
+        arma::ivec startIndexVec_forvr;
+        arma::ivec endIndexVec_forvr;
+
+
+        int Msub_MAFge_minMAFtoConstructGRM;
+
+        int Msub_MAFge_minMAFtoConstructGRM_singleChr;
+        arma::ivec Msub_MAFge_minMAFtoConstructGRM_byChr;
+
+        unsigned char m_genotype_buffer[4];
+        int geno_idx;
+        int m_size_of_esi;
+        unsigned char m_bits_val[8];
+
+	//look-up table in a 2D array for sparseKin
+        float sKinLookUpArr[3][3] = {{0}};
+
+	//look-up table for std geno
+        //float stdGenoLookUpArr[3] = {0};
+	//
+	//
+	//NullGenoClass(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int> & subSampleInGeno, std::vector<bool> & indicatorGenoSamplesWithPheno, float memoryChunk, bool  isDiagofKinSetAsOne);
+	NullGenoClass();
+
+	void setStdGenoLookUpArr(float mafVal, float invsdVal, arma::fvec & stdGenoLookUpArr);
+
+
+        void setSparseKinLookUpArr(float mafVal, float invsdVal);
+	void setBit(unsigned char & ch, int ii, int aVal, int bVal);
+	void setGenotype(unsigned char* c, const int pos, const int geno);
+	void getGenotype(unsigned char* c, const int pos, int& geno);
+
+	void setstartendIndexVec(arma::ivec & t_startIndexVec, arma::ivec & t_endIndexVec);
+
+
+
+	void Init_OneSNP_Geno();
+
+	arma::ivec * Get_OneSNP_Geno(size_t SNPIdx);
+
+	arma::ivec * Get_OneSNP_Geno_forVarRatio(size_t SNPIdx);
+
+	void Get_OneSNP_Geno_atBeginning(size_t SNPIdx, vector<int> & indexNA, vector<unsigned char> & genoVecOneMarkerOld, float & altFreq, float & missingRate, int & mac,  int & alleleCount, bool & passQC, size_t SNPIdx_new, bool & passVarRatio , size_t SNPIdx_vr);
+
+	int Get_OneSNP_StdGeno(size_t SNPIdx, arma::fvec * out );
+
+	arma::fvec * Get_Diagof_StdGeno();
+
+	arma::fvec * Get_Diagof_StdGeno_LOCO();
+
+	void setGenoObj(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int> & subSampleInGeno, std::vector<bool> & indicatorGenoSamplesWithPheno, float memoryChunk, bool  isDiagofKinSetAsOne);
+
+	void printFromgenoVec(unsigned char genoBinary0);
+
+	int getM() const;
+	int getnumberofMarkerswithMAFge_minMAFtoConstructGRM() const;
+
+	int getMsub() const;
+	int getStartIndex() const;
+	int getEndIndex() const;
+        int getN() const;
+        int getNnomissing() const;
+        float getAC(int m);
+	float getMAC(int m);
+	int getMsub_MAFge_minMAFtoConstructGRM_in() const;
+	int getMsub_MAFge_minMAFtoConstructGRM_singleChr_in() const;
+	void Get_Samples_StdGeno(arma::ivec SampleIdsVec);
+ 
+	
+};
+
+}
+
+#endif	
diff --git a/src/Main.cpp b/src/Main.cpp
index 8bfb0d00..4f184926 100644
--- a/src/Main.cpp
+++ b/src/Main.cpp
@@ -1,5 +1,4 @@
-// This includes the main codes to connect C++ and R
-
+#define ARMA_USE_SUPERLU 1
 // [[Rcpp::depends(RcppArmadillo)]]
 #include <RcppArmadillo.h>
 
@@ -23,6 +22,8 @@
 #include "SAIGE_test.hpp"
 #include "UTIL.hpp"
 #include "CCT.hpp"
+#include "GENO_null.hpp"
+
 
 #include <Rcpp.h>
 #include "getMem.hpp"
@@ -34,12 +35,38 @@
 static PLINK::PlinkClass* ptr_gPLINKobj = NULL;
 static BGEN::BgenClass* ptr_gBGENobj = NULL;
 static VCF::VcfClass* ptr_gVCFobj = NULL;
-// global objects for different analysis methods
 static SAIGE::SAIGEClass* ptr_gSAIGEobj = NULL;
+static NullGENO::NullGenoClass* ptr_gNULLGENOobj = NULL;
 //single, SAIGE
 //Region, SAIGE-GENE+
+//Step 1: NULL model
+//
 
 
+//Step 1
+bool isUseSparseSigmaforModelFitting = false;
+std::vector<arma::sp_fmat> Kmat_vec;
+arma::sp_fmat g_I_longl_mat;
+arma::sp_fmat g_T_longl_mat;
+arma::uvec g_I_longl_vec;
+arma::fvec g_T_longl_vec;
+arma::sp_fmat g_spGRM;
+arma::sp_fmat g_spSigma;
+arma::sp_fmat g_spSigma_noV;
+bool g_isSparseGRM;
+bool g_isStoreSigma;
+int g_num_Kmat;
+bool g_isGRM;
+arma::umat g_covarianceidxMat;
+arma::uvec g_covarianceidxMat_col1;
+arma::uvec g_covarianceidxMat_col2;
+arma::uvec g_covarianceidxMat_col3;
+arma::uvec g_covarianceidxMat_notcol1;
+//arma::fvec g_var_weights;
+
+
+
+//Step 2
 // global variables for analysis
 std::string g_impute_method;      // "mean", "minor", or "drop", //drop is not allowed
 double g_missingRate_cutoff;
@@ -67,6 +94,8 @@ bool  g_is_Firth_beta;
 double g_pCutoffforFirth;
 double g_MACCutoffforER;
 
+arma::uvec g_dup_sample_Index;
+int g_n_unique = 0;
 
 std::ofstream OutFile;
 std::ofstream OutFile_singleInGroup;
@@ -81,8 +110,6 @@ std::string g_outputFilePrefixSingle;
 
 
 
-
-
 // [[Rcpp::export]]
 void setAssocTest_GlobalVarsInCPP(std::string t_impute_method,
 		double t_missing_cutoff,
@@ -153,7 +180,7 @@ void mainMarkerInCPP(
 			   std::vector<std::string> & t_genoIndex,
 			   bool & t_isMoreOutput,
 			   bool & t_isImputation,
-			   bool & t_isFirth)
+			   bool & t_isFirth) 
 {
 
   int q = t_genoIndex.size();  // number of markers
@@ -202,7 +229,15 @@ void mainMarkerInCPP(
   std::vector<uint> indexNonZeroVec;
   std::vector<uint> indexForMissing;
 
+  //int n = ptr_gSAIGEobj->m_n;
   int n = ptr_gSAIGEobj->m_n;
+  std::cout << "g_n_unique " << g_n_unique << std::endl;	  
+	  
+	  ;
+  if(g_n_unique > 0){
+    n = g_n_unique;
+  }	  
+
   arma::vec t_GVec(n);
   arma::vec gtildeVec(n);
   arma::vec t_P2Vec;
@@ -272,7 +307,11 @@ void mainMarkerInCPP(
    indexForMissing.clear();
    //t_GVec0.clear();
    //t_GVec.clear();
-   //
+   std::cout << "Unified_getOneMarker " << std::endl;
+   std::cout << "n " << n << std::endl;
+   std::cout << "t_GVec.n_elem " << t_GVec.n_elem << std::endl; 
+
+   //t_GVec.set_size(n);
    bool isReadMarker = Unified_getOneMarker(t_genoType, gIndex_prev, gIndex, ref, alt, marker, pd, chr, altFreq, altCounts, missingRate, imputeInfo,
                                           isOutputIndexForMissing, // bool t_isOutputIndexForMissing,
                                           indexForMissing,
@@ -331,8 +370,14 @@ void mainMarkerInCPP(
 
     // MAF and MAC are for Quality Control (QC)
     double MAF = std::min(altFreq, 1 - altFreq);
+    int nG = t_GVec.n_elem;
     double MAC = MAF * n * (1 - missingRate) *2;
-    
+   
+   std::cout << "MAC " << MAC << std::endl;
+   std::cout << "MAF " << MAF << std::endl;
+   std::cout << "n " << n << std::endl;
+   std::cout << "nG " << nG << std::endl;
+ 
     
    /*
    std::cout << "missingRate " << missingRate << std::endl;
@@ -363,7 +408,10 @@ void mainMarkerInCPP(
     altFreqVec.at(i) = altFreq;         // allele frequencies of ALT allele, this is not always < 0.5.
     altCountsVec.at(i) = altCounts;         // allele frequencies of ALT allele, this is not always < 0.5.
     MAC = std::min(altCounts, 2*n-altCounts);
-   //std::cout << "MAC " << MAC << std::endl; 
+    
+    
+    std::cout << "MAC " << MAC << std::endl; 
+    std::cout << "altCounts " << altCounts << std::endl; 
    //std::cout << "altFreq after flip " << altFreq << std::endl; 
    //std::cout << "info " << info << std::endl; 
     // analysis results for single-marker
@@ -373,10 +421,23 @@ void mainMarkerInCPP(
     bool isSPAConverge, is_gtilde, is_Firth, is_FirthConverge;
     //arma::vec t_P2Vec;
     //arma::vec t_P2Vec;
-
     arma::uvec indexZeroVec_arma, indexNonZeroVec_arma;
-    indexZeroVec_arma = arma::conv_to<arma::uvec>::from(indexZeroVec);
-    indexNonZeroVec_arma = arma::conv_to<arma::uvec>::from(indexNonZeroVec);
+
+    arma::vec t_GVec0;
+    if(g_n_unique == 0){
+      indexZeroVec_arma = arma::conv_to<arma::uvec>::from(indexZeroVec);
+      indexNonZeroVec_arma = arma::conv_to<arma::uvec>::from(indexNonZeroVec);
+      t_GVec0 = t_GVec;
+    }else{
+      t_GVec0 = t_GVec.elem(g_dup_sample_Index);
+      //t_GVec.set_size(t_GVec0.n_elem);
+      //t_GVec = t_GVec0;
+      indexZeroVec_arma = arma::find(t_GVec0 == 0);
+      indexNonZeroVec_arma = arma::find(t_GVec0 != 0);
+      gtildeVec.set_size(t_GVec0.n_elem);
+    }
+
+
     indexZeroVec.clear();
     indexNonZeroVec.clear();
     t_P2Vec.clear();
@@ -402,6 +463,23 @@ void mainMarkerInCPP(
     //check 'Main.cpp'
     bool is_region = false;
 
+
+
+
+    if(ptr_gSAIGEobj->m_flagSparseGRM_cur && ptr_gSAIGEobj->m_SigmaMat_sp.n_rows == 2){
+	ptr_gSAIGEobj->getadjGFast(t_GVec0, gtildeVec, indexNonZeroVec_arma);    
+	arma::fvec tauvec_f = arma::conv_to< arma::fvec >::from(ptr_gSAIGEobj->m_tauvec);
+	arma::fvec m_mu2_f = arma::conv_to< arma::fvec >::from(ptr_gSAIGEobj->m_mu2);
+	arma::fvec t_GVec_f = arma::conv_to< arma::fvec >::from(gtildeVec);
+	arma::fvec sigmainvG_noV_vec = getSigma_G_noV(m_mu2_f, tauvec_f, t_GVec_f, 500, 1e-5, false);
+
+
+	ptr_gSAIGEobj->m_sigmainvG_noV = arma::conv_to< arma::vec >::from(sigmainvG_noV_vec);
+    }
+
+if(g_n_unique == 0){
+
+
     if(MAC > g_MACCutoffforER){
       Unified_getMarkerPval( 
 		    t_GVec, 
@@ -411,14 +489,25 @@ void mainMarkerInCPP(
     }else{
       Unified_getMarkerPval( 
 		    t_GVec, 
-                          false, // bool t_isOnlyOutputNonZero, 
+		    false, // bool t_isOnlyOutputNonZero, 
                           indexNonZeroVec_arma, indexZeroVec_arma, Beta, seBeta, pval, pval_noSPA, Tstat, gy, varT,   
 			  altFreq, isSPAConverge, gtildeVec, is_gtilde, is_region, t_P2Vec, isCondition, Beta_c, seBeta_c, pval_c, pval_noSPA_c, Tstat_c, varT_c, G1tilde_P_G2tilde_Vec, is_Firth, is_FirthConverge, true);
     }
 
 
     if(ptr_gSAIGEobj->m_isFastTest && pval < (ptr_gSAIGEobj->m_pval_cutoff_for_fastTest)){
-      ptr_gSAIGEobj->set_flagSparseGRM_cur(true);
+       ptr_gSAIGEobj->set_flagSparseGRM_cur(true);
+
+       if(ptr_gSAIGEobj->m_flagSparseGRM_cur && ptr_gSAIGEobj->m_SigmaMat_sp.n_rows == 2){	
+	              ptr_gSAIGEobj->getadjGFast(t_GVec0, gtildeVec, indexNonZeroVec_arma);
+       arma::fvec tauvec_f = arma::conv_to< arma::fvec >::from(ptr_gSAIGEobj->m_tauvec);
+       arma::fvec m_mu2_f = arma::conv_to< arma::fvec >::from(ptr_gSAIGEobj->m_mu2);
+       //arma::fvec t_GVec_f = arma::conv_to< arma::fvec >::from(t_GVec);
+        arma::fvec t_GVec_f = arma::conv_to< arma::fvec >::from(gtildeVec);
+       arma::fvec sigmainvG_noV_vec = getSigma_G_noV(m_mu2_f, tauvec_f, t_GVec_f, 500, 1e-5, false);
+       ptr_gSAIGEobj->m_sigmainvG_noV = arma::conv_to< arma::vec >::from(sigmainvG_noV_vec);	
+      }
+
 
       if(!isSingleVarianceRatio){ 
         hasVarRatio = ptr_gSAIGEobj->assignVarianceRatio(MAC, ptr_gSAIGEobj->m_flagSparseGRM_cur);
@@ -444,6 +533,65 @@ void mainMarkerInCPP(
      }     
      }
 
+}else{//if(g_n_unique == 0){
+      std::cout << "Here OK1 " << std::endl;	    
+
+    if(MAC > g_MACCutoffforER){
+      std::cout << "Here OK2" << std::endl;	    
+      Unified_getMarkerPval(
+                    t_GVec0,
+                          false, // bool t_isOnlyOutputNonZero,
+                          indexNonZeroVec_arma, indexZeroVec_arma, Beta, seBeta, pval, pval_noSPA, Tstat, gy, varT,
+                          altFreq, isSPAConverge, gtildeVec, is_gtilde, is_region, t_P2Vec, isCondition, Beta_c, seBeta_c, pval_c, pval_noSPA_c, Tstat_c, varT_c, G1tilde_P_G2tilde_Vec, is_Firth, is_FirthConverge, false);
+    }else{
+      Unified_getMarkerPval(
+                    t_GVec0,
+                          false, // bool t_isOnlyOutputNonZero,
+                          indexNonZeroVec_arma, indexZeroVec_arma, Beta, seBeta, pval, pval_noSPA, Tstat, gy, varT,
+                          altFreq, isSPAConverge, gtildeVec, is_gtilde, is_region, t_P2Vec, isCondition, Beta_c, seBeta_c, pval_c, pval_noSPA_c, Tstat_c, varT_c, G1tilde_P_G2tilde_Vec, is_Firth, is_FirthConverge, true);
+    }
+
+
+    if(ptr_gSAIGEobj->m_isFastTest && pval < (ptr_gSAIGEobj->m_pval_cutoff_for_fastTest)){
+      ptr_gSAIGEobj->set_flagSparseGRM_cur(true);
+              ptr_gSAIGEobj->getadjGFast(t_GVec0, gtildeVec, indexNonZeroVec_arma);
+       arma::fvec tauvec_f = arma::conv_to< arma::fvec >::from(ptr_gSAIGEobj->m_tauvec);
+        arma::fvec m_mu2_f = arma::conv_to< arma::fvec >::from(ptr_gSAIGEobj->m_mu2);
+        //arma::fvec t_GVec_f = arma::conv_to< arma::fvec >::from(t_GVec0);
+	arma::fvec t_GVec_f = arma::conv_to< arma::fvec >::from(gtildeVec);
+        arma::fvec sigmainvG_noV_vec = getSigma_G_noV(m_mu2_f, tauvec_f, t_GVec_f, 500, 1e-5, false);
+        ptr_gSAIGEobj->m_sigmainvG_noV = arma::conv_to< arma::vec >::from(sigmainvG_noV_vec);
+
+      if(!isSingleVarianceRatio){
+        hasVarRatio = ptr_gSAIGEobj->assignVarianceRatio(MAC, ptr_gSAIGEobj->m_flagSparseGRM_cur);
+      }else{
+        ptr_gSAIGEobj->assignSingleVarianceRatio(ptr_gSAIGEobj->m_flagSparseGRM_cur);
+      }
+
+
+     if(MAC > g_MACCutoffforER){
+      Unified_getMarkerPval(
+                    t_GVec0,
+                          false, // bool t_isOnlyOutputNonZero,
+                          indexNonZeroVec_arma, indexZeroVec_arma, Beta, seBeta, pval, pval_noSPA, Tstat, gy, varT,
+                          altFreq, isSPAConverge, gtildeVec, is_gtilde, is_region, t_P2Vec, isCondition, Beta_c, seBeta_c, pval_c, pval_noSPA_c, Tstat_c, varT_c, G1tilde_P_G2tilde_Vec, is_Firth, is_FirthConverge, false);
+     }else{
+      Unified_getMarkerPval(
+                    t_GVec0,
+                          false, // bool t_isOnlyOutputNonZero,
+                          indexNonZeroVec_arma, indexZeroVec_arma, Beta, seBeta, pval, pval_noSPA, Tstat, gy, varT,
+                          altFreq, isSPAConverge, gtildeVec, is_gtilde, is_region, t_P2Vec, isCondition, Beta_c, seBeta_c, pval_c, pval_noSPA_c, Tstat_c, varT_c, G1tilde_P_G2tilde_Vec, is_Firth, is_FirthConverge, true);
+
+
+     }
+     }
+
+
+}
+
+
+std::cout << "pval_noSPA " << pval_noSPA << std::endl;
+std::cout << "pval " << pval << std::endl;
 
 
    if(t_traitType == "binary"){
@@ -774,16 +922,15 @@ void setSAIGEobjInCPP(arma::mat & t_XVX,
 	bool t_flagSparseGRM,
 	bool t_isFastTest,
 	double t_pval_cutoff_for_fastTest,
-        arma::umat & t_locationMat,
-        arma::vec & t_valueVec,
-        int t_dimNum,
 	bool t_isCondition,
 	std::vector<uint32_t> & t_condition_genoIndex,
 	bool t_is_Firth_beta,
 	double t_pCutoffforFirth,
 	arma::vec & t_offset,
-	arma::vec & t_resout)
+	arma::vec & t_resout, 
+	arma::sp_mat & t_SigmaMat_sp)
 {
+	t_SigmaMat_sp.print("t_SigmaMat_sp");
   // check SAIGE.cpp
   ptr_gSAIGEobj = new SAIGE::SAIGEClass(
 	t_XVX,
@@ -808,27 +955,25 @@ void setSAIGEobjInCPP(arma::mat & t_XVX,
 	t_flagSparseGRM,
 	t_isFastTest,
 	t_pval_cutoff_for_fastTest,
-	t_locationMat,
-	t_valueVec,
-	t_dimNum, 
 	t_isCondition,
 	t_condition_genoIndex,
 	t_is_Firth_beta,
         t_pCutoffforFirth,
 	t_offset, 
-	t_resout);
+	t_resout, 
+	t_SigmaMat_sp);
   //ptr_gSAIGEobj->m_flagSparseGRM = false;
 }
 
 
-
+/*
 // [[Rcpp::export]]
 void setSparseSigmaInCPP(int r, arma::umat & t_locationMatinR, arma::vec & t_valueVecinR)
 {
   ptr_gSAIGEobj->setupSparseMat(r, t_locationMatinR, t_valueVecinR);
   ptr_gSAIGEobj->m_flagSparseGRM = true;
 }
-
+*/
 
 // [[Rcpp::export]]
 Rcpp::List RegionSetUpConditional_binary_InCPP(arma::vec & t_weight_cond){
@@ -2790,3 +2935,2807 @@ void copy_singleInGroup(){
 }
 
 
+
+
+
+
+// [[Rcpp::export]]
+void set_dup_sample_index(arma::uvec & t_dup_sample_Index){
+        g_dup_sample_Index = t_dup_sample_Index;
+        arma::uvec uniq_sample_Inddex  = arma::find_unique(g_dup_sample_Index);
+        g_n_unique = uniq_sample_Inddex.n_elem;
+}
+
+
+// [[Rcpp::export]]
+void setupSparseGRM_new(arma::sp_mat & t_spGRM){
+        arma::sp_mat t_spGRM_1 = t_spGRM;
+        arma::sp_fmat g_spGRM_f = arma::conv_to<arma::sp_fmat>::from(t_spGRM_1);
+        g_spGRM = g_spGRM_f;
+}
+
+// [[Rcpp::export]]
+void set_I_longl_mat(arma::sp_mat & t_Ilongmat, arma::vec & t_I_longl_vec){
+        arma::sp_fmat t_Kmat_new = arma::conv_to< arma::sp_fmat >::from(t_Ilongmat);
+        g_I_longl_mat = t_Kmat_new;
+        arma::uvec t_I_longl_vec_new = arma::conv_to< arma::uvec >::from(t_I_longl_vec);
+        g_I_longl_vec = t_I_longl_vec_new;
+
+}
+
+// [[Rcpp::export]]
+void set_T_longl_mat(arma::sp_mat & t_Tlongmat, arma::vec & t_T_longl_vec){
+        arma::sp_fmat t_Kmat_new = arma::conv_to< arma::sp_fmat >::from(t_Tlongmat);
+        g_T_longl_mat = t_Kmat_new;
+        arma::fvec t_T_longl_vec_new = arma::conv_to< arma::fvec >::from(t_T_longl_vec);
+        g_T_longl_vec = t_T_longl_vec_new;
+}
+
+
+// [[Rcpp::export]]
+arma::fvec getCrossprodMatAndKin(arma::fcolvec& bVec, bool LOCO){
+    arma::fvec crossProdVec;
+    if(g_isSparseGRM){
+        crossProdVec = g_spGRM * bVec;
+    }else{
+	if(!LOCO){    
+          crossProdVec = parallelCrossProd(bVec);
+	}else{
+	  crossProdVec = parallelCrossProd_LOCO(bVec);
+	}	
+    }
+    return(crossProdVec);
+}
+
+
+
+
+// [[Rcpp::export]]
+arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+
+        arma::fcolvec crossProdVec;
+        // Added by SLEE, 04/16/2017
+        if(tauVec(1) == 0 && tauVec.n_elem == 2){
+                crossProdVec = tauVec(0)*(bVec % (1/wVec));
+                return(crossProdVec);
+        }
+        //
+        arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+
+        unsigned int tau_ind = 0;
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){ //it must have specified GRM
+		if(g_isGRM){
+                  crossProd1 = getCrossprodMatAndKin(bVec, LOCO);
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+		}else{
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec));
+		  tau_ind = tau_ind + 1;
+	        }		
+        }else{
+                Ibvec = g_I_longl_mat.t() * bVec;
+		if(g_isGRM){
+                  GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                  crossProd1 = g_I_longl_mat * GRM_I_bvec;
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+		}else{
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec));
+		  tau_ind = tau_ind + 1;
+		}	
+
+
+                if(g_T_longl_mat.n_rows > 0){
+                        Tbvec = g_T_longl_mat.t() * bVec;
+			if(g_isGRM){
+                          GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                          crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                          crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+                          crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdGRM_TGIb + crossProdGRM_IGTb);
+                          tau_ind = tau_ind + 1;
+                          crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * GRM_T_bvec);
+                          tau_ind = tau_ind + 1;
+			}
+                }
+
+        }
+
+
+        if(g_T_longl_mat.n_rows == 0 && g_I_longl_mat.n_rows == 0){
+
+                if(Kmat_vec.size() > 0){
+                        for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                                crossProdVec  = crossProdVec + tauVec(tau_ind)*(Kmat_vec[i] * bVec);
+                                tau_ind = tau_ind + 1;
+                        }
+                }
+
+        }else{ //if(g_T_longl_mat.n_rows == 0 && g_I_longl_mat.n_rows == 0){
+                crossProdVec  = crossProdVec + tauVec(tau_ind) * (g_I_longl_mat * Ibvec);
+                tau_ind = tau_ind + 1;
+
+                if(g_T_longl_mat.n_rows > 0){
+                        crossProdGRM_TIb = g_T_longl_mat * Ibvec;
+                        crossProdGRM_ITb = g_I_longl_mat * Tbvec;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdGRM_TIb + crossProdGRM_ITb);
+                        tau_ind = tau_ind + 1;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * Tbvec);
+                        tau_ind = tau_ind + 1;
+                        //crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                        //crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+                }
+
+
+                if(Kmat_vec.size() > 0){
+                        for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                                V_I_bvec = Kmat_vec[i] * Ibvec;
+                                crossProdVec  = crossProdVec + tauVec(tau_ind) * (g_I_longl_mat * V_I_bvec);
+                                tau_ind = tau_ind + 1;
+                                if(g_T_longl_mat.n_rows > 0){
+                                        V_T_bvec = Kmat_vec[i] * Tbvec;
+                                        crossProdV_TGIb = g_T_longl_mat * V_I_bvec;
+                                        crossProdV_IGTb = g_I_longl_mat * V_T_bvec;
+                                        crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdV_TGIb + crossProdV_IGTb);
+                                        tau_ind = tau_ind + 1;
+                                        crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * V_T_bvec);
+                                        tau_ind = tau_ind + 1;
+                                }
+                        }
+                }
+
+        }
+        return(crossProdVec);
+}
+
+
+
+
+
+
+// [[Rcpp::export]]
+arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+        int Nnomissing = wVec.n_elem;
+        arma::fvec diagVec(Nnomissing);
+        arma::sp_fvec diagVecV0;
+        arma::fvec diagVecG, diagVecV, diagVecG_I, diagVecG_T, diagVecG_IT,diagVecV_I, diagVecV_T, diagVecV_IT;
+        unsigned int tauind = 0;
+        
+	if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+         if(g_isGRM){		
+          if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+           if(!g_isSparseGRM){		  
+            if(!LOCO){
+              int MminMAF = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+              diagVec = tauVec(1)* (*ptr_gNULLGENOobj->Get_Diagof_StdGeno()) /MminMAF + tauVec(0)/wVec;
+            }else{
+              diagVec = tauVec(1)* (*ptr_gNULLGENOobj->Get_Diagof_StdGeno_LOCO());
+              int Msub_MAFge_minMAFtoConstructGRM_in_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_in();
+              int Msub_MAFge_minMAFtoConstructGRM_singleVar_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_singleChr_in();
+              diagVec = diagVec/(Msub_MAFge_minMAFtoConstructGRM_in_b - Msub_MAFge_minMAFtoConstructGRM_singleVar_b) + tauVec(0)/wVec;
+            }
+	    tauind = tauind + 2;
+	   }else{
+	     diagVec = tauVec(0)/wVec;
+	     tauind = tauind + 1;
+	     diagVecG = g_spGRM.diag();
+	     diagVec = diagVec + tauVec(tauind) * diagVecG;
+             tauind = tauind + 1;
+	
+	   }		   
+          }else{ //if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+            diagVec = tauVec(1) + tauVec(0)/wVec;
+	    tauind = tauind + 2;
+          }
+	}else{//if(g_isGRM){
+          diagVec = tauVec(0)/wVec;
+	  tauind = tauind + 1;
+	}	
+
+
+          if(Kmat_vec.size() > 0){
+            for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+              diagVec = diagVec + (Kmat_vec[i]).diag() * tauVec(tauind);
+            }
+          }
+
+        }else{ //if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                diagVec = tauVec(0)/wVec;
+                tauind = tauind + 1;
+	  if(g_isGRM && g_isSparseGRM){
+                diagVecG = g_spGRM.diag();
+                diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVec + tauVec(tauind) * diagVecG_I;
+                tauind = tauind + 1;
+
+                if(g_T_longl_mat.n_rows > 0){
+		//std::cout << "getDiagOfSigma_multiV Here1" << std::endl;
+		//diagVecG_I.print("diagVecG_I");
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+		//std::cout << "getDiagOfSigma_multiV Here2" << std::endl;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+		//std::cout << "getDiagOfSigma_multiV Here3" << std::endl;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_IT;
+                  tauind = tauind + 1;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_T;
+                  tauind = tauind + 1;
+                }
+	    }else{
+		diagVecG.ones(g_n_unique);
+		diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVec + tauVec(tauind) * diagVecG_I;
+		tauind = tauind + 1;
+		if(g_T_longl_mat.n_rows > 0){
+                  //std::cout << "getDiagOfSigma_multiV Here1" << std::endl;
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+                  //std::cout << "getDiagOfSigma_multiV Here2" << std::endl;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+                  //std::cout << "getDiagOfSigma_multiV Here3" << std::endl;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_IT;
+                  tauind = tauind + 1;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_T;
+                  tauind = tauind + 1;
+                  //std::cout << "getDiagOfSigma_multiV Here4" << std::endl;
+                }
+
+           } 		    
+
+	
+
+                if(Kmat_vec.size() > 0){
+                  for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                    diagVecV0 = Kmat_vec[i].diag();
+                    arma::fvec diagVecVtemp(diagVecV0);
+                    diagVecV = diagVecVtemp;
+                    diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                    diagVec = diagVec + tauVec(tauind) * diagVecV_I;
+                    tauind = tauind + 1;
+                    if(g_T_longl_mat.n_rows > 0){
+                      diagVecV_IT = diagVecV_I % g_T_longl_vec;
+                      diagVecV_T = diagVecV_IT % g_T_longl_vec;
+                      diagVecV_IT = 2 * diagVecV_IT;
+                      diagVec = diagVec + tauVec(tauind) * diagVecV_IT;
+                      tauind = tauind + 1;
+                      diagVec = diagVec + tauVec(tauind) * diagVecV_T;
+                      tauind = tauind + 1;
+                    }
+                  }
+                }
+
+        }
+
+        for(unsigned int i=0; i< Nnomissing; i++){
+                if(diagVec(i) < 1e-4){
+                        diagVec(i) = 1e-4 ;
+                }
+        }
+
+        return(diagVec);
+}
+
+
+
+// [[Rcpp::export]]
+void gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
+   arma::fvec dtVec = (1/wVec) * (tauVec(0));
+   arma::sp_fmat GRM_Imat, GRM_Tmat;
+   arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+   unsigned int tau_ind = 0;
+   //arma::sp_fmat g_spGRM_f = arma::conv_to< arma::sp_fmat >::from(g_spGRM);
+
+   if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+       if(g_isGRM && g_isSparseGRM){ 
+         g_spSigma = g_spGRM * tauVec(1);
+         g_spSigma.diag() = g_spSigma.diag() + dtVec;
+         tau_ind = tau_ind + 2;
+	}else{
+          g_spSigma.zeros(wVec.n_elem, wVec.n_elem);
+          g_spSigma.diag() = g_spSigma.diag() + dtVec;
+	  tau_ind = tau_ind + 1;	  
+	}	
+   }else{
+       if(g_isGRM && g_isSparseGRM){	   
+         GRM_Imat = g_spGRM * (g_I_longl_mat.t());
+         g_spSigma = g_I_longl_mat * GRM_Imat;
+         g_spSigma = g_spSigma * tauVec(1);
+	 g_spSigma.diag() = g_spSigma.diag() + dtVec;
+	 tau_ind = tau_ind + 2;
+         if(g_T_longl_mat.n_rows > 0){
+           GRM_Tmat = g_spGRM * (g_T_longl_mat.t());
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * GRM_Imat + g_I_longl_mat * GRM_Tmat);
+           tau_ind = tau_ind + 1;
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * GRM_Tmat);
+           tau_ind = tau_ind + 1;
+         }
+       }else{
+	 g_spSigma.zeros(wVec.n_elem, wVec.n_elem);      
+         g_spSigma.diag() = g_spSigma.diag() + dtVec;
+         tau_ind = tau_ind + 1;
+	}
+   }
+
+
+   if(g_T_longl_mat.n_rows == 0 && g_I_longl_mat.n_rows == 0){
+        if(Kmat_vec.size() > 0){
+             for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                     g_spSigma = g_spSigma + tauVec(tau_ind)*(Kmat_vec[i]);
+                     tau_ind = tau_ind + 1;
+             }
+         }
+   }else{
+       g_spSigma = g_spSigma + tauVec(tau_ind) * g_I_longl_mat * (g_I_longl_mat.t());
+       tau_ind = tau_ind + 1;
+
+       if(g_T_longl_mat.n_rows > 0){
+
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * (g_I_longl_mat.t()) + g_I_longl_mat * (g_T_longl_mat.t()));
+           tau_ind = tau_ind + 1;
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * (g_T_longl_mat.t()));
+           tau_ind = tau_ind + 1;
+                        //crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                        //crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+       }
+
+       if(Kmat_vec.size() > 0){
+           for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                GRM_Imat = Kmat_vec[i] * (g_I_longl_mat.t());
+                g_spSigma = g_spSigma + tauVec(tau_ind) * (g_I_longl_mat * GRM_Imat);
+                tau_ind = tau_ind + 1;
+                if(g_T_longl_mat.n_rows > 0){
+                        GRM_Tmat = Kmat_vec[i] * (g_T_longl_mat.t());
+                        g_spSigma = g_spSigma + tauVec(tau_ind) * ((g_T_longl_mat * GRM_Imat) + (g_I_longl_mat * GRM_Tmat));
+                        tau_ind = tau_ind + 1;
+                        g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * GRM_Tmat);
+                        tau_ind = tau_ind + 1;
+                }
+           }
+        }
+
+   }
+
+    //return g_spSigma;
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO){
+    // Start Timers
+    //double wall0 = get_wall_time();
+    //double cpu0  = get_cpu_time();
+    int Nnomissing = wVec.n_elem;
+    arma::fvec xVec(Nnomissing);
+    xVec.zeros();
+
+    if(g_isStoreSigma){
+        std::cout << " arma::spsolve(g_spSigma, bVec) 0" << std::endl;
+        xVec = arma::spsolve(g_spSigma, bVec);
+        std::cout << " arma::spsolve(g_spSigma, bVec) 1" << std::endl;
+    }else{
+        arma::fvec rVec = bVec;
+        arma::fvec r1Vec;
+        arma::fvec crossProdVec(Nnomissing);
+        arma::fvec zVec(Nnomissing);
+        arma::fvec minvVec(Nnomissing);
+	//std::cout << "getPCG1ofSigmaAndVector_multiV Here1" << std::endl;
+        minvVec = 1/getDiagOfSigma_multiV(wVec, tauVec, LOCO);
+        zVec = minvVec % rVec;
+
+        float sumr2 = sum(rVec % rVec);
+        arma::fvec z1Vec(Nnomissing);
+        arma::fvec pVec = zVec;
+
+        int iter = 0;
+        while (sumr2 > tolPCG && iter < maxiterPCG) {
+		iter = iter + 1;
+	//	        std::cout << "getPCG1ofSigmaAndVector_multiV Here2" << std::endl;
+                arma::fcolvec ApVec = getCrossprod_multiV(pVec, wVec, tauVec, LOCO);
+	//	        std::cout << "getPCG1ofSigmaAndVector_multiV Here3" << std::endl;
+                arma::fvec preA = (rVec.t() * zVec)/(pVec.t() * ApVec);
+
+                float a = preA(0);
+                xVec = xVec + a * pVec;
+                r1Vec = rVec - a * ApVec;
+                z1Vec = minvVec % r1Vec;
+
+                arma::fvec Prebet = (z1Vec.t() * r1Vec)/(zVec.t() * rVec);
+                float bet = Prebet(0);
+                pVec = z1Vec+ bet*pVec;
+                zVec = z1Vec;
+                rVec = r1Vec;
+                sumr2 = sum(rVec % rVec);
+        }
+
+        if (iter >= maxiterPCG){
+                cout << "pcg did not converge. You may increase maxiter number." << endl;
+
+        }
+        cout << "iter from getPCG1ofSigmaAndVector " << iter << endl;
+} 
+        return(xVec);
+}
+
+
+
+// [[Rcpp::export]]
+void set_seed(unsigned int seed) {
+        Rcpp::Environment base_env("package:base");
+        Rcpp::Function set_seed_r = base_env["set.seed"];
+        set_seed_r(seed);
+}
+
+// [[Rcpp::export]]
+Rcpp::NumericVector nb(int n) {
+        return(rbinom(n,1,0.5));
+}
+
+// [[Rcpp::export]]
+void setStartEndIndex(int startIndex, int endIndex, int chromIndex){
+  ptr_gNULLGENOobj->startIndex = startIndex;
+  ptr_gNULLGENOobj->endIndex = endIndex;
+  ptr_gNULLGENOobj->Msub = 0;
+  ptr_gNULLGENOobj->chromIndex = chromIndex;
+
+  for(size_t i=0; i< ptr_gNULLGENOobj->M; i++){
+        if(i < startIndex || i > endIndex){
+                if(ptr_gNULLGENOobj->alleleFreqVec[i] >= ptr_gNULLGENOobj->minMAFtoConstructGRM && ptr_gNULLGENOobj->alleleFreqVec[i] <= 1-ptr_gNULLGENOobj->minMAFtoConstructGRM){
+
+                        ptr_gNULLGENOobj->Msub = ptr_gNULLGENOobj->Msub + 1;
+                }
+        }
+  }
+}
+
+// [[Rcpp::export]]
+void setStartEndIndexVec( arma::ivec & startIndex_vec,  arma::ivec & endIndex_vec){
+
+  startIndex_vec.print("startIndex_vec");
+
+  ptr_gNULLGENOobj->setstartendIndexVec(startIndex_vec, endIndex_vec);
+  //ptr_gNULLGENOobj->startIndexVec = startIndex_vec;
+  //ptr_gNULLGENOobj->endIndexVec = endIndex_vec;
+  //ptr_gNULLGENOobj->Msub = ptr_gNULLGENOobj->M - (endIndex - startIndex + 1);
+}
+
+//This function calculates the coefficients of variation for mean of a vector
+// [[Rcpp::export]]
+float calCV(arma::fvec& xVec){
+  int veclen = xVec.n_elem;
+  float vecMean = arma::mean(xVec);
+  float vecSd = arma::stddev(xVec);
+  float vecCV = (vecSd/vecMean)/veclen;
+  return(vecCV);
+}
+
+// [[Rcpp::export]]
+arma::fmat getSigma_X_multiV(arma::fvec& wVec, arma::fvec& tauVec,arma::fmat& Xmat, int maxiterPCG, float tolPCG, bool LOCO){
+
+
+        int Nnomissing = Xmat.n_rows;
+        int colNumX = Xmat.n_cols;
+        arma::fmat Sigma_iX1(Nnomissing,colNumX);
+        arma::fvec XmatVecTemp;
+
+        for(int i = 0; i < colNumX; i++){
+                XmatVecTemp = Xmat.col(i);
+                Sigma_iX1.col(i) = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG, LOCO);
+        }
+        return(Sigma_iX1);
+}
+
+// [[Rcpp::export]]
+arma::fvec  getSigma_G_multiV(arma::fvec& wVec, arma::fvec& tauVec,arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO){
+        arma::fvec Sigma_iG;
+        Sigma_iG = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO);
+        return(Sigma_iG);
+}
+
+
+// [[Rcpp::export]]
+Rcpp::List fitglmmaiRPCG_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec &wVec,  arma::fvec & tauVec, arma::ivec & fixtauVec, arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
+int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOCO){
+        Function warning("warning");
+
+        unsigned int k1 = g_num_Kmat;
+
+        int q2 = arma::sum(fixtauVec==0);
+        arma::uvec idxtau = arma::find(fixtauVec==0);
+        arma::fvec tau0 = tauVec;
+
+        std::cout << "check 1" << std::endl;
+        Rcpp::List re = getAIScore_multiV(Yvec, Xmat,wVec,  tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO);
+
+        std::cout << "check 2" << std::endl;
+
+        arma::fvec YPAPY = re["YPAPY"];
+        arma::fvec Trace = re["Trace"];
+        arma::fvec score1 = YPAPY - Trace;
+        score1.print("score1");
+        YPAPY.print("YPAPY");
+        Trace.print("Trace");
+        arma::fmat AI1 = re["AI"];
+        arma::fvec Dtau(AI1.n_cols);
+        score1.print("score");
+        try{
+                Dtau = arma::solve(AI1, score1, arma::solve_opts::allow_ugly);
+        }
+        catch(std::runtime_error){
+                std::cout << "arma::solve(AI, score): AI seems singular, using less variant components matrix is suggested." << std::endl;
+                Dtau.zeros();
+        }
+        //std::cout << "check 3" << std::endl;
+        Dtau.print("Dtau");
+        score1.print("score1");
+        AI1.print("AI1");
+        //
+        //
+        arma::fvec Dtau_k1(k1);
+        Dtau_k1.zeros();
+
+        std::cout << "k1 " << k1 << std::endl;
+        fixtauVec.print("fixtauVec");
+
+        // fill dtau using dtau_pre, padding 0
+        int i2 = 0;
+        for(int i=0; i<k1; i++){
+                std::cout << "i " << i << std::endl;
+                if(fixtauVec(i)==0){ // not fixed
+                        Dtau_k1(i) = Dtau(i2);
+                        i2++;
+                }
+        } // end for i
+        Dtau_k1.print("Dtau_k1");
+        tau0 = tauVec;
+        tauVec = tauVec + Dtau_k1;
+        arma::fvec tauVecabs, tauVec_sub1;
+        arma::ivec fixrhoidx0, fixrhoidx, tauupdateidx;
+        //arma::ivec fixrhoidx0, fixrhoidx, covarianceidxVec1, covarianceidxVec_sub1, covarianceidxVec2, covarianceidxVec_sub2,covarianceidxVec3, covarianceidxVec_sub3, tauupdateidx;
+        arma::uvec covarianceidxVec1, covarianceidxVec_sub1, covarianceidxVec2, covarianceidxVec_sub2,covarianceidxVec3, covarianceidxVec_sub3, zeroindVec1;
+
+        if(g_covarianceidxMat.n_rows == 0){
+                tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                float step = 1.0;
+                while ( arma::any(tauVec < 0.0) ){
+                        step = step*0.5;
+                        tauVec = tau0 + step*Dtau_k1;
+                        tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                } // end while
+                tauVec.elem( arma::find(tauVec < tol) ).zeros();
+        }else{
+                fixrhoidx0 = updatefixrhoidx0(tau0, tol);
+                tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+                fixrhoidx = updatefixrhoidx0(tauVec, tol);
+                covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+
+		tauVec_sub1 = tauVec.elem(covarianceidxVec_sub1);
+                zeroindVec1 = arma::find(tauVec_sub1 != 0);
+		if(zeroindVec1.n_elem == tauVec_sub1.n_elem){
+                        tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                        tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+                }else{
+                        tauVecabs = tauVec_sub1;
+                        tauVecabs.zeros();
+                        tauVecabs.elem(zeroindVec1) = tauVecabs.elem(zeroindVec1)/arma::abs(tauVecabs.elem(zeroindVec1));
+                        tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+                }
+
+
+
+                //tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                //tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+                tauupdateidx = tauUpdateValue(tauVec);
+                float step = 1.0;
+                 while ( arma::any(tauVec.elem(g_covarianceidxMat_notcol1) < 0.0) || tauVec(0) < 0.0 || arma::any(tauupdateidx == 0)){
+                 tauVec.print("tauVec");
+                 tauupdateidx.print("tauupdateidx");
+                        step = step*0.5;
+                        tauVec = tau0 + step*Dtau_k1;
+                        tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                        tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+                        fixrhoidx = updatefixrhoidx0(tauVec, tol);
+                        covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                        covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                        covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                        tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                        tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+                        tauupdateidx = tauUpdateValue(tauVec);
+                        Rcpp::checkUserInterrupt();
+                } // end while
+                tauVec.elem( arma::find(tauVec < tol) ).zeros();
+                tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+
+		tauVec_sub1 = tauVec.elem(covarianceidxVec_sub1);
+		zeroindVec1 = arma::find(tauVec_sub1 != 0);	
+
+		if(zeroindVec1.n_elem == tauVec_sub1.n_elem){
+                	tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                	tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+		}else{
+			tauVecabs = tauVec_sub1;
+			tauVecabs.zeros();
+			tauVecabs.elem(zeroindVec1) = tauVecabs.elem(zeroindVec1)/arma::abs(tauVecabs.elem(zeroindVec1));
+			tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));			
+		}	
+        }
+         return List::create(Named("tau") = tauVec, Named("AI") = AI1, Named("score") = score1);
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec getMeanDiagofKmat(bool LOCO){
+
+		                  std::cout << "Here3a" << std::endl;	
+	arma::fvec mean_diag_kins_vec(g_num_Kmat - 1);
+		                  std::cout << "Here3b" << std::endl;	
+
+        arma::sp_vec diagVecG0;
+        arma::sp_fvec diagVecV0;
+        arma::fvec diagVecG, diagVecV, diagVecG_I, diagVecG_T, diagVecG_IT,diagVecV_I, diagVecV_T, diagVecV_IT;
+        arma::fvec diagVec;
+        unsigned int tauind = 0;
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+        if(g_isGRM){
+           if(!LOCO){
+              if(!g_isSparseGRM){
+                int MminMAF = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+                diagVec = (*ptr_gNULLGENOobj->Get_Diagof_StdGeno()) /MminMAF;
+              }else{
+                diagVec = arma::diagvec(g_spGRM);
+              }
+            }else{
+              diagVec = (*ptr_gNULLGENOobj->Get_Diagof_StdGeno_LOCO());
+              int Msub_MAFge_minMAFtoConstructGRM_in_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_in();
+              int Msub_MAFge_minMAFtoConstructGRM_singleVar_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_singleChr_in();
+              diagVec = diagVec/(Msub_MAFge_minMAFtoConstructGRM_in_b - Msub_MAFge_minMAFtoConstructGRM_singleVar_b);
+            }
+	   mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+	   tauind = tauind + 1;
+	  }
+
+          if(Kmat_vec.size() > 0){
+            for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+              diagVec = (Kmat_vec[i]).diag();
+              mean_diag_kins_vec(i+tauind) = arma::mean(diagVec);
+	      tauind = tauind + 1;
+            }
+          }
+
+        }else{ //if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+	    /*if(g_isGRM && g_isSparseGRM){	
+                diagVecG = arma::diagvec(g_spGRM);
+                diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVecG_I;
+                mean_diag_kins_vec(0) = arma::mean(diagVec);
+                tauind = tauind + 1;
+            }*/
+		                  std::cout << "Here3c" << std::endl;	
+		std::cout << "g_T_longl_mat.n_rows " << g_T_longl_mat.n_rows << std::endl;
+            if(g_T_longl_mat.n_rows > 0){
+		std::cout << "g_isGRM " << g_isGRM << std::endl;
+		std::cout << "g_isSparseGRM " << g_isSparseGRM << std::endl;
+
+	        if(g_isGRM && g_isSparseGRM){
+			//g_spGRM.print("g_spGRM");		
+		  diagVecG = arma::diagvec(g_spGRM);
+
+                  diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                  diagVec = diagVecG_I;
+                  mean_diag_kins_vec(0) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVecG_IT;
+                  std::cout << "Here1" << std::endl;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+                  std::cout << "Here2" << std::endl;
+                  diagVec = diagVecG_T;
+		  std::cout << "tauind " << tauind << std::endl;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  std::cout << "Here2" << std::endl;
+                  tauind = tauind + 1;
+		}  
+
+                  //diagVecV = diagVecG;
+		std::cout << "g_n_unique " << g_n_unique << std::endl;
+                  diagVecV.ones(g_n_unique);
+		  //diagVecV.print("diagVecV");
+                  diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                  diagVec = diagVecV_I;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+		  std::cout << "Here2a" << std::endl;
+                  tauind = tauind + 1;
+                  diagVecV_IT = diagVecV_I % g_T_longl_vec;
+                  diagVecV_T = diagVecV_IT % g_T_longl_vec;
+                  diagVecV_IT = 2 * diagVecV_IT;
+                  diagVec = diagVecV_IT;
+		  std::cout << "Here2b" << std::endl;
+
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+                  std::cout << "Here2" << std::endl;
+                  diagVec = diagVecV_T;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+
+
+           }else{
+		                  std::cout << "Here3d" << std::endl;	
+		if(g_isGRM && g_isSparseGRM){	
+		                  std::cout << "Here3e" << std::endl;	
+                  diagVecG = arma::diagvec(g_spGRM);
+                  diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                  diagVec = diagVecG_I;
+                  mean_diag_kins_vec(0) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+	  	}
+		                  std::cout << "Here3" << std::endl;	
+		  diagVecV = diagVecG;
+                  diagVecV.ones();
+                  diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                  diagVec = diagVecV_I;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;		
+	   }	   
+
+                if(Kmat_vec.size() > 0){
+                  for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                    diagVecV0 = Kmat_vec[i].diag();
+                    arma::fvec diagVecVtemp(diagVecV0);
+                    diagVecV = diagVecVtemp;
+                    diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                    diagVec = diagVecV_I;
+                    mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                    tauind = tauind + 1;
+                    if(g_T_longl_mat.n_rows > 0){
+                      diagVecV_IT = diagVecV_I % g_T_longl_vec;
+                      diagVecV_T = diagVecV_IT % g_T_longl_vec;
+                      diagVecV_IT = 2 * diagVecV_IT;
+                      diagVec = diagVecV_IT;
+                      mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                      tauind = tauind + 1;
+                      diagVec = diagVecV_T;
+                      mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                      tauind = tauind + 1;
+                    }
+                  }
+                }
+
+        }
+
+        return(mean_diag_kins_vec);
+}
+
+
+arma::ivec updatefixrhoidx0(arma::fvec & t_tau0Vec, float tol){
+        arma::ivec fixrhoidx0Vec(g_covarianceidxMat.n_rows);
+        arma::uvec covarianceidxVec;
+        float tau0_x1, tau0_x2, tau0_x3, tau0_x2_x3, tau0temp;
+        for(int i=0; i<g_covarianceidxMat.n_rows; i++){
+                covarianceidxVec = (g_covarianceidxMat.row(i) - 1).t();
+                tau0_x1 = t_tau0Vec((covarianceidxVec(0)));
+                tau0_x2 = t_tau0Vec((covarianceidxVec(1)));
+                tau0_x3 = t_tau0Vec((covarianceidxVec(2)));
+                tau0_x2_x3 = std::sqrt(tau0_x2 * tau0_x3);
+                tau0temp = (1 - 1.01 * tol) * tau0_x2_x3;
+                if(std::abs(tau0_x1) > tau0temp){
+                        fixrhoidx0Vec(i) = 1;
+                }else{
+                        fixrhoidx0Vec(i) = 0;
+                }
+        }
+        return(fixrhoidx0Vec);
+}
+
+
+arma::ivec tauUpdateValue(arma::fvec & t_tau0Vec){
+        arma::ivec fixrhoidx0Vec(g_covarianceidxMat.n_rows);
+        arma::uvec covarianceidxVec;
+        float tau0_x1, tau0_x2, tau0_x3, tau0_x2_x3, tau0temp;
+        for(int i=0; i<g_covarianceidxMat.n_rows; i++){
+                covarianceidxVec = (g_covarianceidxMat.row(i) - 1).t();
+                tau0_x1 = t_tau0Vec((covarianceidxVec(0)));
+                tau0_x2 = t_tau0Vec((covarianceidxVec(1)));
+                tau0_x3 = t_tau0Vec((covarianceidxVec(2)));
+                tau0_x2_x3 = std::sqrt(tau0_x2 * tau0_x3);
+                if(std::abs(tau0_x1) > tau0_x2_x3){
+                        fixrhoidx0Vec(i) = 0;
+                }else{
+                        fixrhoidx0Vec(i) = 1;
+                }
+        }
+        return(fixrhoidx0Vec);
+}
+
+
+// [[Rcpp::export]]
+Rcpp::List getAIScore_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, arma::ivec & fixtauVec,
+arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
+int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){
+	fixtauVec.print("fixtauVec");
+
+        int q2 = arma::sum(fixtauVec==0);
+        arma::uvec idxtau = arma::find(fixtauVec==0);
+        arma::fvec tau0;
+        unsigned int k1 = g_num_Kmat;
+        arma::fmat AI(k1,k1);
+        arma::fvec YPAPY(k1);
+        YPAPY.zeros();
+        arma::fvec Trace(k1);
+        Trace.zeros();
+        std::cout << "k1 " << k1 << std::endl;
+        arma::fmat Sigma_iXt = Sigma_iX.t();
+        arma::fmat Xmatt = Xmat.t();
+
+        //Sigma_iY.print("Sigma_iY");
+        //Sigma_iX.print("Sigma_iX");
+        //cov.print("cov");
+        //Sigma_iXt.print("Sigma_iXt");
+        //Yvec.print("Yvec");
+
+        arma::fvec PY1 = Sigma_iY - Sigma_iX * (cov * (Sigma_iXt * Yvec));
+
+        //PY1.print("PY1");
+        //arma::fvec APY = getCrossprodMatAndKin(PY1);
+        //float YPAPY = dot(PY1, APY);
+        //arma::fvec A0PY = PY1; ////Quantitative
+        //float YPA0PY = dot(PY1, A0PY); ////Quantitative
+        //arma::fvec Trace = GetTrace_q(Sigma_iX, Xmat, wVec, tauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff);
+        unsigned int n = PY1.n_elem;
+        //arma::fvec PA0PY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, A0PY, maxiterPCG, tolPCG);
+        //arma::fvec PA0PY = PA0PY_1 - Sigma_iX * (cov1 * (Sigma_iXt * PA0PY_1));
+        arma::fvec PAPY_1, PAPY,  APY;
+        arma::fmat APYmat(n, k1);
+
+        //if(q2>0){
+        //
+	arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+
+
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                for(int i=0; i<k1; i++){
+                    if(fixtauVec(i) == 0){
+                        if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+				if(g_isGRM){
+                                        APY = getCrossprodMatAndKin(PY1, LOCO);
+                                }else{
+					if(Kmat_vec.size() > 0){
+                                        	APY = Kmat_vec[0]*PY1;
+                                 	}			
+				}	
+                        }else{
+				if(g_isGRM){
+                                	if(Kmat_vec.size() > 0){
+                                        	APY = Kmat_vec[i-2]*PY1;
+                                	}
+				}else{
+					if(Kmat_vec.size() > 0){
+                                                APY = Kmat_vec[i-1]*PY1;
+                                        }	
+				}	
+                        }
+                        APYmat.col(i) = APY;
+                        PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG, LOCO);
+                        PAPY = PAPY_1 - Sigma_iX * (cov * (Sigma_iXt * PAPY_1));
+                        for(int j=0; j<=i; j++){
+                                AI(i,j) = arma::dot(APYmat.col(j), PAPY);
+                                if(j !=i){
+                                        AI(j,i) = AI(i,j);
+                                }
+                        }
+                        YPAPY(i) = arma::dot(PY1, APYmat.col(i));
+                     }
+                }
+        }else{
+               Ibvec = g_I_longl_mat.t() * PY1;
+                std::cout << "Ibvec.n_elem " << Ibvec.n_elem << std::endl;
+
+                if(g_isGRM){
+                        GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                }
+
+                std::cout << "g_I_longl_mat.n_rows " << g_I_longl_mat.n_rows << std::endl;
+               if(g_T_longl_mat.n_rows == 0){
+                  for(int i=0; i<k1; i++){
+                    if(fixtauVec(i) == 0){
+                        if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+				if(g_isGRM){
+                                  std::cout << "GRM_I_bvec.n_elem " << GRM_I_bvec.n_elem << std::endl;
+                                  APY = g_I_longl_mat * GRM_I_bvec;
+				}else{
+				  APY = g_I_longl_mat * Ibvec;
+				}	
+                        }else if (i == 2){
+				if(g_isGRM){
+                                  APY = g_I_longl_mat * Ibvec;
+				}else{
+				  if(Kmat_vec.size() > 0){
+					V_I_bvec = Kmat_vec[0]*Ibvec;
+					APY = g_I_longl_mat * V_I_bvec;
+				  }	  
+				}	
+                                //APY = Kmat_vec[i-2]*PY1;
+                        }else{
+			     if(g_isGRM){	
+                                if(Kmat_vec.size() > 0){
+                                        V_I_bvec = Kmat_vec[i-3]*Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }
+			     }else{
+				if(Kmat_vec.size() > 0){
+                                        V_I_bvec = Kmat_vec[i-2]*Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }
+			     }		     
+
+                        }
+                        APYmat.col(i) = APY;
+			PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG, LOCO);
+                        PAPY = PAPY_1 - Sigma_iX * (cov * (Sigma_iXt * PAPY_1));
+                        for(int j=0; j<=i; j++){
+                                AI(i,j) = arma::dot(APYmat.col(j), PAPY);
+                                if(j !=i){
+                                        AI(j,i) = AI(i,j);
+                                }
+                        }
+                        YPAPY(i) = arma::dot(PY1, APYmat.col(i));
+                     }
+                  }
+
+                }else{
+                  Tbvec = g_T_longl_mat.t() * PY1;
+                  if(g_isGRM){
+                    GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                  }
+
+                  unsigned int kmatind = 0;
+                  for(int i=0; i<k1; i++){
+                    if(fixtauVec(i) == 0){
+		     if(g_isGRM){	    
+                        if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+                                APY = g_I_longl_mat * GRM_I_bvec;
+                        }else if(i == 2){
+                                APY = (g_T_longl_mat * GRM_I_bvec) + (g_I_longl_mat * GRM_T_bvec);
+                        }else if(i == 3){
+                                APY = g_T_longl_mat * GRM_T_bvec;
+
+                        }else if(i == 4){
+                                APY = g_I_longl_mat * Ibvec;
+                        }else if(i == 5){
+
+                                APY = (g_T_longl_mat * Ibvec) + (g_I_longl_mat * Tbvec);
+
+                        }else if(i == 6){
+                                APY = g_T_longl_mat * Tbvec;
+
+                        }else{
+                                if(i % 3 == 1){
+                                        V_I_bvec = Kmat_vec[kmatind] * Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }else if(i % 3 == 2){
+                                        V_T_bvec = Kmat_vec[kmatind] * Tbvec;
+                                        APY = (g_T_longl_mat * V_I_bvec) + (g_I_longl_mat * V_T_bvec);
+                                }else if(i % 3 == 0){
+                                        APY = g_T_longl_mat * V_T_bvec;
+                                        kmatind = kmatind + 1;
+
+                                }
+                        }
+		     }else{ //if(g_isGRM){
+			if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+                                APY = g_I_longl_mat * Ibvec;
+                        }else if(i == 2){
+                                APY = (g_T_longl_mat * Ibvec) + (g_I_longl_mat * Tbvec);
+                        }else if(i == 3){
+                                APY = g_T_longl_mat * Tbvec;
+
+                        }else{
+                                if(i % 3 == 1){
+                                        V_I_bvec = Kmat_vec[kmatind] * Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }else if(i % 3 == 2){
+                                        V_T_bvec = Kmat_vec[kmatind] * Tbvec;
+                                        APY = (g_T_longl_mat * V_I_bvec) + (g_I_longl_mat * V_T_bvec);
+                                }else if(i % 3 == 0){
+                                        APY = g_T_longl_mat * V_T_bvec;
+                                        kmatind = kmatind + 1;
+
+                                }
+                        }     
+
+
+
+		     }//else for if(g_isGRM){	     
+                        APYmat.col(i) = APY;
+                        PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG, LOCO);
+                        PAPY = PAPY_1 - Sigma_iX * (cov * (Sigma_iXt * PAPY_1));
+                        for(int j=0; j<=i; j++){
+                                AI(i,j) = arma::dot(APYmat.col(j), PAPY);
+                                if(j !=i){
+                                        AI(j,i) = AI(i,j);
+                                }
+                        }
+			                        YPAPY(i) = arma::dot(PY1, APYmat.col(i));
+                     }
+                  }
+
+                }
+        }
+
+        AI.print("AI");
+	YPAPY.print("YPAPY");
+        arma::fmat AI_update = AI.submat(idxtau, idxtau);
+        arma::fvec YPAPY_update = YPAPY.elem(idxtau);
+	YPAPY.print("YPAPY");
+
+        //vector with length=q2
+        Trace = GetTrace_multiV(Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO);
+        //YPAPY_update.print("YPAPY_update");
+        Trace.print("Trace");
+        //arma::fvec PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG);
+        //arma::fvec PAPY = PAPY_1 - Sigma_iX * (cov1 * (Sigma_iXt * PAPY_1));
+        return Rcpp::List::create(Named("YPAPY") = YPAPY_update, Named("Trace") = Trace,Named("PY") = PY1,Named("AI") = AI_update);
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec & fixtauVec, arma::fmat& cov1,  int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){
+
+        set_seed(200);
+
+        int q2 = arma::sum(fixtauVec==0);
+        arma::uvec idxtau = arma::find(fixtauVec==0);
+
+        idxtau.print("idxtau");
+
+        arma::fmat Sigma_iXt = Sigma_iX.t();
+        int Nnomissing = wVec.n_elem;;
+        //unsigned int k = Kmat_vec.size();
+        //unsigned int k1 = k + 2;
+        unsigned int  k1 = g_num_Kmat;
+        arma::fmat temp_mat(nrun, k1);
+        arma::fmat temp_mat_update(nrun, q2);
+        arma::fvec temp_vec(nrun);
+        arma::fvec temp_vec_double(Nnomissing);
+        temp_mat.zeros();
+        temp_mat_update.zeros();
+
+        arma::fvec Sigma_iu;
+        arma::fvec Pu;
+        arma::fmat Au_mat(Nnomissing, k1);
+        arma::fvec uVec;
+	Rcpp::NumericVector uVec0;
+
+        int nrun_trace_start = 0;
+        int nrun_trace_end = nrun;
+        arma::fvec traceCV(q2);
+        traceCV.fill(traceCVcutoff + 0.1);
+
+        arma::uvec covarianceidxVec;
+        arma::fvec traceCVsub;
+        arma::uvec indexsubvec =  { 1, 2 };
+        if(g_covarianceidxMat.n_cols > 0){
+             covarianceidxVec = arma::vectorise(g_covarianceidxMat.cols(indexsubvec));
+             covarianceidxVec = covarianceidxVec - 1;
+        }
+        bool isConverge = false;
+        //while((traceCV > cutoff_trace) | (traceCV0 > cutoff_trace)){
+        //while( arma::any(traceCV > traceCVcutoff) ){
+        //
+        //
+	arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+        while( !isConverge ){
+                for(int i = nrun_trace_start; i < nrun_trace_end; i++){
+
+                        uVec0 = nb(Nnomissing);
+                        uVec = as<arma::fvec>(uVec0);
+                        uVec = uVec*2 - 1;
+
+			//std::cout << "GetTrace_multiV Here 1" << std::endl;
+                        Sigma_iu = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, uVec, maxiterPCG, tolPCG, LOCO);
+                        Pu = Sigma_iu - Sigma_iX * (cov1 *  (Sigma_iXt * uVec));
+
+                        if(fixtauVec(0) == 0)   {
+                                Au_mat.col(0) = uVec;
+                                temp_mat(i,0) = dot(Au_mat.col(0), Pu);
+                        }
+                        // conversion for ops with sp_mat
+                     if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                        if(fixtauVec(1) == 0){
+                                if(g_isGRM){
+                                        temp_vec_double = getCrossprodMatAndKin(uVec, LOCO);
+                                }else{
+					if(Kmat_vec.size() > 0){
+						temp_vec_double = 0.0+Kmat_vec[0] * uVec;
+					}	
+                                }
+                                Au_mat.col(1) = temp_vec_double;
+                                temp_mat(i,1) = dot(temp_vec_double, Pu);
+                        }
+
+
+			if(g_isGRM){
+                          for(int j=2; j<k1;j++){
+                                if(fixtauVec(j) == 0){
+                                        Au_mat.col(j) = 0.0+Kmat_vec[j-2] * uVec;
+                                        temp_mat(i,j) = dot(Au_mat.col(j), Pu);
+                                }
+                          } // end for j in 2:k1
+			}else{
+			  for(int j=2; j<k1;j++){
+                                if(fixtauVec(j) == 0){
+                                        Au_mat.col(j) = 0.0+Kmat_vec[j-1] * uVec;
+                                        temp_mat(i,j) = dot(Au_mat.col(j), Pu);
+                                }
+                          } // end for j in 1:k1	
+
+			}	
+                   }else{
+                        Ibvec = g_I_longl_mat.t() * uVec;
+			//std::cout << "GetTrace_multiV Here 2" << std::endl;
+                        if(g_isGRM){
+                                GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                        }else{
+				GRM_I_bvec = Ibvec;
+			}	
+                        if(g_T_longl_mat.n_rows == 0){
+			   if(g_isGRM){	
+                                if(fixtauVec(1) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * GRM_I_bvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(2) == 0){
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                for(int j=3; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                V_I_bvec = Kmat_vec[j-3] * Ibvec;
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                }
+			   }else{
+
+                                if(fixtauVec(1) == 0){
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                for(int j=2; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                V_I_bvec = Kmat_vec[j-2] * Ibvec;
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                }		
+			   }	   
+                        }else{
+                             Tbvec = g_T_longl_mat.t() * uVec;
+                             if(g_isGRM){
+                                        GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                                if(fixtauVec(1) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * GRM_I_bvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(2) == 0)   {
+                                        temp_vec_double = (g_I_longl_mat * GRM_T_bvec) + (g_T_longl_mat * GRM_I_bvec);
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(3) == 0)   {
+                                        temp_vec_double = g_T_longl_mat * GRM_T_bvec;
+                                        Au_mat.col(3) = temp_vec_double;
+                                        temp_mat(i,3) = dot(temp_vec_double, Pu);
+                                }
+
+                                 if(fixtauVec(4) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(4) = temp_vec_double;
+                                        temp_mat(i,4) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(5) == 0)   {
+                                        temp_vec_double = (g_I_longl_mat * Tbvec) + (g_T_longl_mat * Ibvec);
+                                        Au_mat.col(5) = temp_vec_double;
+                                        temp_mat(i,5) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(6) == 0)   {
+                                        temp_vec_double = g_T_longl_mat * Tbvec;
+                                        Au_mat.col(6) = temp_vec_double;
+                                        temp_mat(i,6) = dot(temp_vec_double, Pu);
+                                }
+
+
+                                int j = 7;
+                                while(j < k1){
+                                        V_I_bvec = Kmat_vec[j-7] * Ibvec;
+                                        V_T_bvec = Kmat_vec[j-7] * Tbvec;
+                                //for(int j=7; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = (g_I_longl_mat * V_T_bvec) + (g_T_longl_mat * V_I_bvec);
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_T_longl_mat * V_T_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+
+                                        }
+                                        j = j + 1;
+                                }
+
+                        }else{// if(g_isGRM){
+
+
+                                 if(fixtauVec(1) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(2) == 0)   {
+                                        temp_vec_double = (g_I_longl_mat * Tbvec) + (g_T_longl_mat * Ibvec);
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(3) == 0)   {
+                                        temp_vec_double = g_T_longl_mat * Tbvec;
+                                        Au_mat.col(3) = temp_vec_double;
+                                        temp_mat(i,3) = dot(temp_vec_double, Pu);
+                                }
+
+
+                                int j = 4;
+                                while(j < k1){
+                                        V_I_bvec = Kmat_vec[j-4] * Ibvec;
+                                        V_T_bvec = Kmat_vec[j-4] * Tbvec;
+                                //for(int j=7; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = (g_I_longl_mat * V_T_bvec) + (g_T_longl_mat * V_I_bvec);
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_T_longl_mat * V_T_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+
+                                        }
+                                        j = j + 1;
+                                }
+
+
+
+			}//}else{// if(g_isGRM){	
+		}		
+
+	}
+
+
+
+                        uVec.clear();
+                        Pu.clear();
+                        Sigma_iu.clear();
+
+                } // end for i
+                temp_mat_update = temp_mat.cols(idxtau);
+
+                std::cout << "dim temp_mat_update" << temp_mat_update.n_rows << " " << temp_mat_update.n_cols << std::endl;;
+                // update trace cv vector
+                for(int k=0; k<q2; k++){
+                        temp_vec = temp_mat_update.col(k);
+                        traceCV(k) = calCV(temp_vec);
+                }
+                //traceCV.print("traceCV");
+                //traceCVcutoff = 1.0;
+                // if not converge, increase nrun_trace and rerun
+                //temp_mat.print("temp_mat");
+                //
+
+                if(g_covarianceidxMat.n_cols > 0){
+                        traceCVsub = traceCV.elem(covarianceidxVec);
+                        //if(arma::any(traceCVsub > traceCVcutoff)){
+                        if(arma::any(traceCV > traceCVcutoff)){
+                                isConverge = false;
+                        }else{
+                                isConverge = true;
+                        }
+                }else{
+                        if( arma::any(traceCV > traceCVcutoff) ){
+                                isConverge = false;
+                        }else{
+                                isConverge = true;
+                        }
+                }
+
+
+
+                if( !isConverge){
+                        nrun_trace_start = nrun_trace_end;
+                        nrun_trace_end = nrun_trace_end + 10;
+                        temp_mat.resize(nrun_trace_end,k1);
+                        temp_mat_update.resize(nrun_trace_end,q2);
+                        //std::cout << "arma::mean(temp_mat0): " << arma::mean(temp_mat0) << std::endl;
+                        Rcout << "CV for trace random estimator using "<< nrun_trace_start << " runs is " << traceCV <<  " > " << traceCVcutoff << std::endl;
+                        Rcout << "try " << nrun_trace_end << "runs" << std::endl;
+                } // end if arma::any(traceCV > traceCVcutoff)
+
+        } // end while  arma::any(traceCV > traceCVcutoff)
+        Au_mat.clear();
+        Pu.clear();
+        Sigma_iu.clear();
+        uVec.clear();
+        temp_vec.clear();
+
+        arma::fvec traVec(q2);
+        for(int i=0; i<q2; i++){
+                traVec(i) = arma::mean(temp_mat_update.col(i));
+        }
+        temp_mat.clear();
+        temp_mat_update.clear();
+        return(traVec);
+}
+
+
+
+// [[Rcpp::export]]
+Rcpp::List getCoefficients_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, int maxiterPCG, float tolPCG, bool LOCO){
+
+        int Nnomissing = wVec.n_elem;
+        arma::fvec Sigma_iY;
+	std::cout << "before Sigma_iY" << std::endl;
+	std::cout << "Yvec.n_elem " << Yvec.n_elem << std::endl;
+        Sigma_iY = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, Yvec, maxiterPCG, tolPCG, LOCO);
+        std::cout << "after Sigma_iY" << std::endl;
+        int colNumX = Xmat.n_cols;
+        arma::fmat Sigma_iX(Nnomissing,colNumX);
+        arma::fvec XmatVecTemp;
+        for(int i = 0; i < colNumX; i++){
+                XmatVecTemp = Xmat.col(i);
+                Sigma_iX.col(i) = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG, LOCO);
+
+        }
+        arma::fmat Xmatt = Xmat.t();
+        //arma::fmat cov = inv_sympd(Xmatt * Sigma_iX);
+        arma::fmat cov;
+        try {
+          cov = arma::inv_sympd(arma::symmatu(Xmatt * Sigma_iX));
+        } catch (const std::exception& e) {
+          cov = arma::pinv(arma::symmatu(Xmatt * Sigma_iX));
+          cout << "inv_sympd failed, inverted with pinv" << endl;
+        }
+	cov.print("cov"); 	
+        arma::fmat Sigma_iXt = Sigma_iX.t();
+	//Sigma_iXt.print("Sigma_iXt");
+	//Yvec.print("Yvec");
+        arma::fvec SigmaiXtY = Sigma_iXt * Yvec;
+        arma::fvec alpha = cov * SigmaiXtY;
+	
+        arma::fvec eta = Yvec - tauVec(0) * (Sigma_iY - Sigma_iX * alpha) / wVec;
+        return Rcpp::List::create(Named("Sigma_iY") = Sigma_iY, Named("Sigma_iX") = Sigma_iX, Named("cov") = cov, Named("alpha") = alpha, Named("eta") = eta);
+}
+
+
+// [[Rcpp::export]]
+void setminMAC_VarianceRatio(float t_minMACVarRatio, float t_maxMACVarRatio, bool t_isVarianceRatioinGeno){
+        ptr_gNULLGENOobj->g_minMACVarRatio = t_minMACVarRatio;
+        ptr_gNULLGENOobj->g_maxMACVarRatio = t_maxMACVarRatio;
+        ptr_gNULLGENOobj->isVarRatio = t_isVarianceRatioinGeno;
+        std::cout << "ptr_gNULLGENOobj->g_minMACVarRatio " << ptr_gNULLGENOobj->g_minMACVarRatio << std::endl;
+        std::cout << "ptr_gNULLGENOobj->g_maxMACVarRatio " << ptr_gNULLGENOobj->g_maxMACVarRatio << std::endl;
+}
+
+
+// [[Rcpp::export]]
+arma::fvec get_GRMdiagVec(){
+  int mMarker = gettotalMarker();
+  int MminMAF = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+        //cout << "MminMAF=" << MminMAF << endl;
+
+  arma::fvec diagGRMVec = (*ptr_gNULLGENOobj->Get_Diagof_StdGeno())/MminMAF;
+  return(diagGRMVec);
+}
+
+// [[Rcpp::export]]
+void setminMAFforGRM(float minMAFforGRM){
+  ptr_gNULLGENOobj->minMAFtoConstructGRM = minMAFforGRM;
+}
+
+// [[Rcpp::export]]
+void setmaxMissingRateforGRM(float maxMissingforGRM){
+  ptr_gNULLGENOobj->maxMissingRate = maxMissingforGRM;
+}
+
+
+// [[Rcpp::export]]
+void set_Diagof_StdGeno_LOCO(){
+
+
+  int Nnomissing = ptr_gNULLGENOobj->getNnomissing();
+  int chrlength = ptr_gNULLGENOobj->startIndexVec.n_elem;
+  (ptr_gNULLGENOobj->mtx_DiagStd_LOCO).zeros(Nnomissing, chrlength);
+  (ptr_gNULLGENOobj->Msub_MAFge_minMAFtoConstructGRM_byChr).zeros(chrlength);
+//  std::cout << "debug1" << std::endl;
+    int starti, endi;
+    arma::fvec * temp = &ptr_gNULLGENOobj->m_OneSNP_StdGeno;
+for(size_t k=0; k< chrlength; k++){
+   starti = ptr_gNULLGENOobj->startIndexVec[k];
+   endi = ptr_gNULLGENOobj->endIndexVec[k];
+//  std::cout << "debug2" << std::endl;
+  if((starti != -1) && (endi != -1)){
+        for(int i=starti; i<= endi; i++){
+                        ptr_gNULLGENOobj->Get_OneSNP_StdGeno(i, temp);
+                        (ptr_gNULLGENOobj->mtx_DiagStd_LOCO).col(k) = (ptr_gNULLGENOobj->mtx_DiagStd_LOCO).col(k) + (*temp) % (*temp);
+                        ptr_gNULLGENOobj->Msub_MAFge_minMAFtoConstructGRM_byChr[k] = ptr_gNULLGENOobj->Msub_MAFge_minMAFtoConstructGRM_byChr[k] + 1;
+
+        }
+  (ptr_gNULLGENOobj->mtx_DiagStd_LOCO).col(k) = *ptr_gNULLGENOobj->Get_Diagof_StdGeno() -  (ptr_gNULLGENOobj->mtx_DiagStd_LOCO).col(k);
+  }
+}
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec get_DiagofKin(){
+    int Nnomissing = ptr_gNULLGENOobj->getNnomissing();
+    arma::fvec x(Nnomissing);
+
+    if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+           x  = (*ptr_gNULLGENOobj->Get_Diagof_StdGeno());
+           int MminMAF = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+           x = x/MminMAF;
+    }else{
+           x  = arma::ones<arma::fvec>(Nnomissing);
+    }
+    return(x);
+}
+
+
+
+
+
+//http://gallery.rcpp.org/articles/parallel-inner-product/
+struct CorssProd_usingSubMarker : public Worker
+{
+        // source vectors
+        arma::fcolvec & m_bVec;
+        unsigned int m_N;
+        unsigned int m_M_Submarker;
+        unsigned int m_M;
+        arma::ivec subMarkerIndex ;
+
+        // product that I have accumulated
+        arma::fvec m_bout;
+
+
+        // constructors
+        CorssProd_usingSubMarker(arma::fcolvec & y)
+                : m_bVec(y) {
+
+                //m_Msub = ptr_gNULLGENOobj->getMsub();
+                subMarkerIndex = getSubMarkerIndex();
+                m_M_Submarker = subMarkerIndex.n_elem;
+                m_N = ptr_gNULLGENOobj->getNnomissing();
+                m_bout.zeros(m_N);
+        }
+        CorssProd_usingSubMarker(const CorssProd_usingSubMarker& CorssProd_usingSubMarker, Split)
+                : m_bVec(CorssProd_usingSubMarker.m_bVec)
+        {
+
+                m_N = CorssProd_usingSubMarker.m_N;
+                //m_M = CorssProd_usingSubMarker.m_M;
+                m_M_Submarker = CorssProd_usingSubMarker.m_M_Submarker;
+                subMarkerIndex = CorssProd_usingSubMarker.subMarkerIndex;
+                m_bout.zeros(m_N);
+
+        }
+
+           // process just the elements of the range I've been asked to
+        void operator()(std::size_t begin, std::size_t end) {
+                arma::fvec vec;
+                float val1;
+                int j;
+                for(unsigned int i = begin; i < end; i++){
+                        j = subMarkerIndex[i];
+//                      std::cout << "j: " << j << std::endl;
+                        ptr_gNULLGENOobj->Get_OneSNP_StdGeno(j, &vec);
+                        val1 = dot(vec,  m_bVec);
+                        m_bout += val1 * (vec);
+                }
+        }
+
+        // join my value with that of another InnerProduct
+        void join(const  CorssProd_usingSubMarker & rhs) {
+        m_bout += rhs.m_bout;
+        }
+};
+
+
+
+// [[Rcpp::export]]
+arma::fvec parallelCrossProd_usingSubMarker(arma::fcolvec & bVec) {
+
+  // declare the InnerProduct instance that takes a pointer to the vector data
+        int m_M_Submarker = getSubMarkerNum();
+        CorssProd_usingSubMarker CorssProd_usingSubMarker(bVec);
+        parallelReduce(0, m_M_Submarker, CorssProd_usingSubMarker);
+        return CorssProd_usingSubMarker.m_bout/m_M_Submarker;
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec getCrossprodMatAndKin_usingSubMarker(arma::fcolvec& bVec){
+
+        arma::fvec crossProdVec = parallelCrossProd_usingSubMarker(bVec) ;
+
+        return(crossProdVec);
+}
+
+
+
+//The code below is from http://gallery.rcpp.org/articles/parallel-inner-product/
+struct InnerProduct : public Worker
+{
+   // source vectors
+   std::vector<float> x;
+   std::vector<float> y;
+
+   // product that I have accumulated
+   float product;
+
+   // constructors
+   InnerProduct(const std::vector<float> x, const std::vector<float> y)
+      : x(x), y(y), product(0) {}
+   InnerProduct(const InnerProduct& innerProduct, Split)
+      : x(innerProduct.x), y(innerProduct.y), product(0) {}
+
+   // process just the elements of the range I've been asked to
+   void operator()(std::size_t begin, std::size_t end) {
+      product += std::inner_product(x.begin() + begin,
+                                    x.begin() + end,
+                                    y.begin() + begin,
+                                    0.0);
+   }
+
+   // join my value with that of another InnerProduct
+   void join(const InnerProduct& rhs) {
+     product += rhs.product;
+   }
+};
+
+
+
+// [[Rcpp::export]]
+float parallelInnerProduct(std::vector<float> &x, std::vector<float> &y) {
+
+   int xsize = x.size();
+   // declare the InnerProduct instance that takes a pointer to the vector data
+   InnerProduct innerProduct(x, y);
+
+   // call paralleReduce to start the work
+   parallelReduce(0, x.size(), innerProduct);
+
+   // return the computed product
+   return innerProduct.product/xsize;
+}
+
+// [[Rcpp::export]]
+Rcpp::List createSparseKin(arma::fvec& markerIndexVec, float relatednessCutoff, arma::fvec& wVec,  arma::fvec& tauVec){
+
+        int nSubMarker = markerIndexVec.n_elem;
+        int Ntotal = wVec.n_elem;
+        std::vector<unsigned int>     iIndexVec;
+        std::vector<unsigned int>     iIndexVec2;
+        std::vector<unsigned int>     jIndexVec;
+        std::vector<unsigned int>     jIndexVec2;
+        std::vector<unsigned int>     allIndexVec;
+        std::vector<float>     kinValueVec;
+        std::vector<float>     kinValueVec2;
+        std::vector<float> stdGenoMultiMarkers;
+        stdGenoMultiMarkers.resize(Ntotal*nSubMarker);
+
+        //std::cout << "createSparseKin1" << std::endl;
+        size_t sizeTemp;
+        float kinValue;
+        float kinValueTemp;
+
+        Get_MultiMarkersBySample_StdGeno(markerIndexVec, stdGenoMultiMarkers);
+        std::cout << "createSparseKin2" << std::endl;
+        arma::fmat stdGenoMultiMarkersMat(&stdGenoMultiMarkers.front(), nSubMarker, Ntotal);
+
+
+
+        for(unsigned int i=0; i< Ntotal; i++){
+              for(unsigned int j = i; j < Ntotal; j++){
+                        //kinValueTemp = arma::dot(stdGenoMultiMarkersMat.row(i), stdGenoMultiMarkersMat.row(j));
+                        if(j > i){
+                                kinValueTemp = arma::dot(stdGenoMultiMarkersMat.col(i), stdGenoMultiMarkersMat.col(j));
+                                kinValueTemp = kinValueTemp/nSubMarker;
+                                if(kinValueTemp >= relatednessCutoff){
+                                        iIndexVec.push_back(i);
+                                        jIndexVec.push_back(j);
+
+                                }
+                        }else{
+                                iIndexVec.push_back(i);
+                                jIndexVec.push_back(j);
+                        }
+                }
+        }
+
+        arma::fvec * temp = &(ptr_gNULLGENOobj->m_OneSNP_StdGeno);
+        size_t ni = iIndexVec.size();
+        kinValueVec.resize(ni);
+        std::fill(kinValueVec.begin(), kinValueVec.end(), 0);
+
+        int Mmarker = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+                //ptr_gNULLGENOobj->getM();
+        for(size_t i=0; i< Mmarker; i++){
+                ptr_gNULLGENOobj->Get_OneSNP_StdGeno(i, temp);
+                for(size_t j=0; j < ni; j++){
+                        kinValueVec[j] = kinValueVec[j] + (((*temp)[iIndexVec[j]])*((*temp)[jIndexVec[j]]))/Mmarker;
+                }
+
+        }
+
+
+        for(size_t j=0; j < ni; j++){
+                if(kinValueVec[j] >= relatednessCutoff){
+        //      std::cout << "kinValueVec[j]: " << kinValueVec[j] << std::endl;
+                        kinValueVec[j] = tauVec(1)*kinValueVec[j];
+                        iIndexVec2.push_back(iIndexVec[j]+1);
+                        jIndexVec2.push_back(jIndexVec[j]+1);
+                        if(iIndexVec[j] == jIndexVec[j]){
+                                kinValueVec[j] = kinValueVec[j] + tauVec(0)/(wVec(iIndexVec[j]));
+                        }
+                        kinValueVec2.push_back(kinValueVec[j]);
+                }
+
+        }
+
+        return Rcpp::List::create(Named("iIndex") = iIndexVec2, Named("jIndex") = jIndexVec2, Named("kinValue") = kinValueVec2);
+}
+
+
+
+
+// [[Rcpp::export]]
+Rcpp::List refineKin(float relatednessCutoff){
+        std::vector<unsigned int>     iIndexVec2;
+        std::vector<unsigned int>     jIndexVec2;
+//      std::vector<float>     kinValueVec;
+        std::vector<float>     kinValueVec2;
+ //       std::vector<float>     kinValueVec_orig; //for test original kinship
+
+        arma::fvec * temp = &(ptr_gNULLGENOobj->m_OneSNP_StdGeno);
+        (*temp).clear();
+        size_t ni = ptr_gNULLGENOobj->indiceVec.size();
+        std::cout << "ni: " << ni << std::endl;
+
+        initKinValueVecFinal(ni);
+
+        int Mmarker = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+
+        arma::fvec kinValueVecTemp2;
+        arma::fvec GRMvec;
+        GRMvec.set_size(ni);
+        for(size_t i=0; i< Mmarker; i++){
+                float freqv = ptr_gNULLGENOobj->alleleFreqVec[i];
+
+                ptr_gNULLGENOobj->Get_OneSNP_Geno(i);
+                float invstdv = ptr_gNULLGENOobj->invstdvVec[i];
+                ptr_gNULLGENOobj->setSparseKinLookUpArr(freqv, invstdv);
+
+
+                parallelcalsparseGRM(GRMvec);
+                parallelsumTwoVec(GRMvec);
+                (*temp).clear();
+        }
+
+
+
+        int a1;
+        int a2;
+        for(size_t j=0; j < ni; j++){
+                ptr_gNULLGENOobj->kinValueVecFinal[j] = (ptr_gNULLGENOobj->kinValueVecFinal[j]) /(Mmarker);
+                if((ptr_gNULLGENOobj->kinValueVecFinal[j]) >= relatednessCutoff){
+                                 a1 = (ptr_gNULLGENOobj->indiceVec)[j].first + 1;
+                                 a2 = (ptr_gNULLGENOobj->indiceVec)[j].second + 1;
+                                 iIndexVec2.push_back(a1);
+                                 jIndexVec2.push_back(a2);
+
+                        kinValueVec2.push_back((ptr_gNULLGENOobj->kinValueVecFinal)[j]);
+                }
+
+        }
+
+
+
+        std::cout << "kinValueVec2.size(): " << kinValueVec2.size() << std::endl;
+        return Rcpp::List::create(Named("iIndex") = iIndexVec2, Named("jIndex") = jIndexVec2, Named("kinValue") = kinValueVec2);
+}
+
+// [[Rcpp::export]]
+arma::fmat getColfromStdGenoMultiMarkersMat(arma::uvec & a){
+        return((ptr_gNULLGENOobj->stdGenoMultiMarkersMat).cols(a));
+}
+
+// [[Rcpp::export]]
+int getNColStdGenoMultiMarkersMat(){
+        return((ptr_gNULLGENOobj->stdGenoMultiMarkersMat).n_cols);
+}
+
+// [[Rcpp::export]]
+int getNRowStdGenoMultiMarkersMat(){
+        return((ptr_gNULLGENOobj->stdGenoMultiMarkersMat).n_rows);
+}
+
+
+// [[Rcpp::export]]
+void setSubMarkerIndex(arma::ivec &subMarkerIndexRandom){
+        ptr_gNULLGENOobj->subMarkerIndex = subMarkerIndexRandom;
+        int Nnomissing = ptr_gNULLGENOobj->getNnomissing();
+        (ptr_gNULLGENOobj->stdGenoMultiMarkersMat).set_size(subMarkerIndexRandom.n_elem, Nnomissing);
+}
+
+// [[Rcpp::export]]
+void setRelatednessCutoff(float a){
+        ptr_gNULLGENOobj->relatednessCutoff = a;
+}
+
+
+// [[Rcpp::export]]
+double innerProduct(Rcpp::NumericVector x, Rcpp::NumericVector y) {
+   return std::inner_product(x.begin(), x.end(), y.begin(), 0.0);
+}
+
+
+// [[Rcpp::export]]
+arma::fvec getDiagOfSigma_noV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+        int Nnomissing = wVec.n_elem;
+        arma::fvec diagVec(Nnomissing);
+        arma::sp_fvec diagVecV0;
+        arma::fvec diagVecG, diagVecV, diagVecG_I, diagVecG_T, diagVecG_IT,diagVecV_I, diagVecV_T, diagVecV_IT;
+        unsigned int tauind = 0;
+
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+          if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+             diagVec = tauVec(0)/wVec;
+             tauind = tauind + 1;
+             diagVecG = g_spGRM.diag();
+             diagVec = diagVec + tauVec(tauind) * diagVecG;
+             tauind = tauind + 1;
+          }else{ //if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+            diagVec = tauVec(1) + tauVec(0)/wVec;
+            tauind = tauind + 2;
+          }
+
+
+        }else{ //if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                diagVec = tauVec(0)/wVec;
+                tauind = tauind + 1;
+                diagVecG = g_spGRM.diag();
+                diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVec + tauVec(tauind) * diagVecG_I;
+                tauind = tauind + 1;
+
+                if(g_T_longl_mat.n_rows > 0){
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_IT;
+                  tauind = tauind + 1;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_T;
+                  tauind = tauind + 1;
+                }
+
+        }
+
+        for(unsigned int i=0; i< Nnomissing; i++){
+                if(diagVec(i) < 1e-4){
+                        diagVec(i) = 1e-4 ;
+                }
+        }
+
+        return(diagVec);
+}
+
+// [[Rcpp::export]]
+arma::fcolvec getCrossprod_noV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+
+        arma::fcolvec crossProdVec;
+        // Added by SLEE, 04/16/2017
+        if(tauVec(1) == 0 && tauVec.n_elem == 2){
+                crossProdVec = tauVec(0)*(bVec % (1/wVec));
+                return(crossProdVec);
+        }
+        //
+        arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+
+        unsigned int tau_ind = 0;
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){ //it must have specified GRM
+                  crossProd1 = getCrossprodMatAndKin(bVec, LOCO);
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+        }else{
+
+                  Ibvec = g_I_longl_mat.t() * bVec;
+
+                  GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                  crossProd1 = g_I_longl_mat * GRM_I_bvec;
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+
+
+                if(g_T_longl_mat.n_rows > 0){
+                        Tbvec = g_T_longl_mat.t() * bVec;
+                        GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                        crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                        crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdGRM_TGIb + crossProdGRM_IGTb);
+                        tau_ind = tau_ind + 1;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * GRM_T_bvec);
+                        tau_ind = tau_ind + 1;
+                }
+
+        }
+
+        return(crossProdVec);
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec getPCG1ofSigmaAndVector_noV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO){
+    // Start Timers
+    //double wall0 = get_wall_time();
+    //double cpu0  = get_cpu_time();
+    int Nnomissing = wVec.n_elem;
+    arma::fvec xVec(Nnomissing);
+    xVec.zeros();
+
+    if(g_isStoreSigma){
+        std::cout << " arma::spsolve(g_spSigma, bVec) 0" << std::endl;
+        //xVec = arma::spsolve(g_spSigma, bVec);
+        xVec = arma::spsolve(g_spSigma_noV, bVec);
+        std::cout << " arma::spsolve(g_spSigma, bVec) 1" << std::endl;
+    }else{
+        arma::fvec rVec = bVec;
+        arma::fvec r1Vec;
+        arma::fvec crossProdVec(Nnomissing);
+        arma::fvec zVec(Nnomissing);
+        arma::fvec minvVec(Nnomissing);
+        minvVec = 1/getDiagOfSigma_noV(wVec, tauVec, LOCO);
+        zVec = minvVec % rVec;
+
+        float sumr2 = sum(rVec % rVec);
+        arma::fvec z1Vec(Nnomissing);
+        arma::fvec pVec = zVec;
+
+        int iter = 0;
+
+        while (sumr2 > tolPCG && iter < maxiterPCG) {
+                iter = iter + 1;
+                arma::fcolvec ApVec = getCrossprod_noV(pVec, wVec, tauVec, LOCO);
+                arma::fvec preA = (rVec.t() * zVec)/(pVec.t() * ApVec);
+
+                float a = preA(0);
+                xVec = xVec + a * pVec;
+                r1Vec = rVec - a * ApVec;
+                z1Vec = minvVec % r1Vec;
+
+                arma::fvec Prebet = (z1Vec.t() * r1Vec)/(zVec.t() * rVec);
+                float bet = Prebet(0);
+                pVec = z1Vec+ bet*pVec;
+                zVec = z1Vec;
+                rVec = r1Vec;
+                sumr2 = sum(rVec % rVec);
+        }
+
+        if (iter >= maxiterPCG){
+                cout << "pcg did not converge. You may increase maxiter number." << endl;
+
+        }
+        cout << "iter from getPCG1ofSigmaAndVector " << iter << endl;
+}
+        return(xVec);
+}
+
+
+// [[Rcpp::export]]
+arma::fvec  getSigma_G_noV(arma::fvec& wVec, arma::fvec& tauVec,arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO){
+        arma::fvec Sigma_iG;
+        Sigma_iG = getPCG1ofSigmaAndVector_noV(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO);
+        return(Sigma_iG);
+}
+
+
+// [[Rcpp::export]]
+void set_useGRMtoFitNULL(bool useGRMtoFitNULL){
+        g_isGRM = useGRMtoFitNULL;
+}
+
+
+// [[Rcpp::export]]
+void set_isSparseGRM(bool t_isSparseGRM){
+        g_isSparseGRM = t_isSparseGRM;
+}
+
+
+// [[Rcpp::export]]
+void set_store_sigma(bool isstoreSigma){
+        //g_longl_vec = arma::conv_to< arma::fvec >::from(longlVec);
+        g_isStoreSigma = isstoreSigma;
+}
+
+// [[Rcpp::export]]
+void set_num_Kmat(int t_num_Kmat){
+        //g_longl_vec = arma::conv_to< arma::fvec >::from(longlVec);
+        g_num_Kmat = t_num_Kmat;
+}
+
+
+// [[Rcpp::export]]
+int get_numofV(){
+        int k = Kmat_vec.size();
+        return(k);
+}
+
+
+// [[Rcpp::export]]
+arma::umat set_covarianceidx_Mat(){
+        //unsigned int k = Kmat_vec.size();
+        unsigned int k = g_num_Kmat;
+
+        unsigned int q = (k+1)/3;
+        g_covarianceidxMat.set_size(q, 3);
+        g_covarianceidxMat.zeros();
+        arma::uvec g_covarianceidxVec(3);
+        for(unsigned int j=0; j < q; j++){
+                g_covarianceidxVec = {j*3+3, j*3+2, j*3+4};
+                g_covarianceidxMat.row(j) = g_covarianceidxVec.t();
+        }
+        g_covarianceidxMat_col1 = g_covarianceidxMat.col(0) - 1;
+        g_covarianceidxMat_col2 = g_covarianceidxMat.col(1) - 1;
+        g_covarianceidxMat_col3 = g_covarianceidxMat.col(2) - 1;
+
+        arma::uvec indexsubvec =  { 1, 2 };
+        g_covarianceidxMat_notcol1 = arma::vectorise(g_covarianceidxMat.cols(indexsubvec));
+
+        g_covarianceidxMat_notcol1 = g_covarianceidxMat_notcol1 - 1;
+
+        return(g_covarianceidxMat);
+}
+
+/*
+// [[Rcpp::export]]
+void set_Vmat_vec_longlVar(){
+        std::cout << "here" << std::endl;
+        int k  = Kmat_vec.size();
+        arma::sp_fmat spGRM_longl_0;
+        arma::sp_fmat spGRM_longl;
+        for(int j=0; j < 1+k; j++){
+          if(j == 0){
+            spGRM_longl_0 = g_spGRM;
+          }else{
+            //spGRM_longl = Kmat_vec[j-1];
+            //spGRM_longl_0 = arma::conv_to< arma::sp_mat >::from(Kmat_vec[j-1]);
+            spGRM_longl_0 = Kmat_vec[j-1];
+          }
+          //spGRM_longl_0 = g_longl_vec.t() % (spGRM_longl_0.each_row());
+          for(int q=0; q < spGRM_longl_0.n_rows; q++){
+          //for(int q=0; q < spGRM_longl.n_rows; q++){
+                 spGRM_longl_0.row(q) = g_longl_vec.t() % spGRM_longl_0.row(q);
+          }
+          //spGRM_longl = arma::conv_to< arma::sp_fmat >::from(spGRM_longl_0);
+          //Kmat_vec.push_back(spGRM_longl);
+          Kmat_vec.push_back(spGRM_longl_0);
+
+          //spGRM_longl_0 = spGRM_longl_0 % g_longl_vec;
+          //spGRM_longl_0 = g_longl_vec.t() % (spGRM_longl_0.t().each_row());
+          //spGRM_longl_0 = spGRM_longl_0.t();
+          for(int q=0; q < spGRM_longl_0.n_cols; q++){
+                 spGRM_longl_0.col(q) = spGRM_longl_0.col(q) % g_longl_vec;
+                 //spGRM_longl.col(q) = spGRM_longl.col(q) % g_longl_vec;
+          }
+          //spGRM_longl = arma::conv_to< arma::sp_fmat >::from(spGRM_longl_0);
+          //Kmat_vec.push_back(spGRM_longl);
+          Kmat_vec.push_back(spGRM_longl_0);
+          std::cout << "x here" << std::endl;
+          //spGRM_longl_0.clear();
+          spGRM_longl.clear();
+        }
+}
+i
+
+*/
+
+// [[Rcpp::export]]
+void closeGenoFile_plink()
+{
+    if(g_isGRM && !g_isSparseGRM){	
+  //genoToTest_plainDosage.test_genoGZfile.close();
+        for (int i = 0; i < ptr_gNULLGENOobj->numofGenoArray; i++){
+                (*ptr_gNULLGENOobj->genoVecofPointers[i]).clear();
+                delete ptr_gNULLGENOobj->genoVecofPointers[i];
+        }
+
+        ptr_gNULLGENOobj->genoVecofPointers.clear();
+
+        //ptr_gNULLGENOobj->genoVec.clear();
+        ptr_gNULLGENOobj->invstdvVec.clear();
+        ptr_gNULLGENOobj->ptrsubSampleInGeno.clear();
+        ptr_gNULLGENOobj->alleleFreqVec.clear();
+        ptr_gNULLGENOobj->m_OneSNP_Geno.clear();
+        ptr_gNULLGENOobj->m_OneSNP_StdGeno.clear();
+        ptr_gNULLGENOobj->m_DiagStd.clear();
+        printf("closed the plinkFile!\n");
+    }	
+}
+
+
+// [[Rcpp::export]]
+int gettotalMarker(){
+        int numMarker = ptr_gNULLGENOobj->getM();
+        return(numMarker);
+}
+
+// [[Rcpp::export]]
+arma::fvec getAlleleFreqVec(){
+        return(ptr_gNULLGENOobj->alleleFreqVec);
+}
+
+// [[Rcpp::export]]
+arma::ivec getMACVec(){
+        return(ptr_gNULLGENOobj->MACVec);
+}
+
+
+// [[Rcpp::export]]
+arma::ivec getMACVec_forVarRatio(){
+        return(ptr_gNULLGENOobj->MACVec_forVarRatio);
+}
+
+// [[Rcpp::export]]
+arma::ivec getIndexVec_forVarRatio(){
+        return(ptr_gNULLGENOobj->markerIndexVec_forVarRatio);
+}
+
+// [[Rcpp::export]]
+bool getIsVarRatioGeno(){
+        return(ptr_gNULLGENOobj->isVarRatio);
+}
+// [[Rcpp::export]]
+arma::ivec getSubMarkerIndex(){
+        return(ptr_gNULLGENOobj->subMarkerIndex);
+}
+
+// [[Rcpp::export]]
+std::vector<bool> getQCdMarkerIndex(){
+        return(ptr_gNULLGENOobj->MarkerswithMAFge_minMAFtoConstructGRM_indVec);
+}
+
+
+// [[Rcpp::export]]
+int getSubMarkerNum(){
+        return(ptr_gNULLGENOobj->subMarkerIndex.n_elem);
+}
+
+
+void initKinValueVecFinal(int ni){
+        ptr_gNULLGENOobj->kinValueVecFinal.resize(ni);
+        std::fill(ptr_gNULLGENOobj->kinValueVecFinal.begin(), ptr_gNULLGENOobj->kinValueVecFinal.end(), 0);
+};
+
+// [[Rcpp::export]]
+int getNnomissingOut(){
+        return(ptr_gNULLGENOobj->getNnomissing());
+}
+
+
+// [[Rcpp::export]]
+int getMsub_MAFge_minMAFtoConstructGRM(){
+        return(ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_in());
+}
+
+// [[Rcpp::export]]
+int getMsub_MAFge_minMAFtoConstructGRM_singleChr(){
+        return(ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_singleChr_in());
+}
+
+
+// [[Rcpp::export]]
+void Get_MultiMarkersBySample_StdGeno_Mat(){
+        //ptr_gNULLGENOobj->subMarkerIndex
+        //int m_M_Submarker = markerIndexVec.n_elem;
+        int m_M_Submarker = getSubMarkerNum();
+        //arma::fvec stdGenoMultiMarkers;
+        int Nnomissing = ptr_gNULLGENOobj->getNnomissing();
+          //int nSubMarker = markerIndexVec.n_elem;
+          //int Ntotal = ptr_gNULLGENOobj->getNnomissing();
+        //std::vector<float> stdGenoMultiMarkers;
+        //stdGenoMultiMarkers.resize(Nnomissing*m_M_Submarker);
+
+        int indexOfVectorPointer;
+        int SNPIdxinVec;
+        size_t Start_idx;
+        size_t ind= 0;
+        size_t indtotal = 0;
+        unsigned char geno1;
+        float freq;
+        float invStd;
+        int flag;
+        int SNPIdx;
+
+//      std::cout << "createSparseKin1d" << std::endl;
+        for(size_t k=0; k< m_M_Submarker; k++){
+                ind = 0;
+                flag = 0;
+                //SNPIdx = markerIndexVec[k];
+                SNPIdx = (ptr_gNULLGENOobj->subMarkerIndex)[k];
+                indexOfVectorPointer = SNPIdx/(ptr_gNULLGENOobj->numMarkersofEachArray);
+                SNPIdxinVec = SNPIdx % (ptr_gNULLGENOobj->numMarkersofEachArray);
+                Start_idx = (ptr_gNULLGENOobj->m_size_of_esi) * SNPIdxinVec;
+                freq = (ptr_gNULLGENOobj->alleleFreqVec)[SNPIdx];
+                invStd = (ptr_gNULLGENOobj->invstdvVec)[SNPIdx];
+                if(k == 0){
+                        std::cout << "freq: " << freq << " invStd: " << invStd << "  SNPIdx: " << SNPIdx << std::endl;
+                }
+
+                while(flag == 0){
+//              std::cout << "createSparseKin1e" << std::endl;
+                for(size_t i=Start_idx; i< Start_idx+(ptr_gNULLGENOobj->m_size_of_esi); i++){
+                        geno1 = (ptr_gNULLGENOobj->genoVecofPointers)[indexOfVectorPointer]->at(i);
+                        //std::cout << "createSparseKin1f" << std::endl;
+
+                        for(int j=0; j<4; j++){
+                        int b = geno1 & 1 ;
+                        geno1 = geno1 >> 1;
+                        int a = geno1 & 1 ;
+                        (ptr_gNULLGENOobj->stdGenoMultiMarkersMat)(k, ind) = ((2-(a+b)) - 2*freq)* invStd;
+//                      std::cout << "k,ind " << k << " " << ind << std::endl;
+//                      std::cout << "(ptr_gNULLGENOobj->stdGenoMultiMarkersMat)(k, ind) " << (ptr_gNULLGENOobj->stdGenoMultiMarkersMat)(k, ind) << std::endl;
+
+//                        stdGenoMultiMarkers[ind*m_M_Submarker+k] = ((2-(a+b)) - 2*freq)* invStd;;
+//                      if(k == 0){
+    //                    std::cout << "ind*m_M_Submarker+k: " << ind*m_M_Submarker+k << " stdGenoMultiMarkers[ind*m_M_Submarker+k]: " << stdGenoMultiMarkers[ind*m_M_Submarker+k] <<  std::endl;
+  //              }
+
+
+                        indtotal++;
+                        ind++;
+                        geno1 = geno1 >> 1;
+
+                                if(ind == Nnomissing){
+                                        flag = 1;
+                                        break;
+                                }
+                        }// end of for(int j=0; j<4; j++){
+                    }// end of for(size_t i=Start_idx
+                } //end of while(flag == 0){
+
+        }
+
+        std::cout << "stdGenoMultiMarkersMat.n_rows: " << ptr_gNULLGENOobj->stdGenoMultiMarkersMat.n_rows << std::endl;
+        std::cout << "stdGenoMultiMarkersMat.n_cols: " << ptr_gNULLGENOobj->stdGenoMultiMarkersMat.n_cols << std::endl;
+//      arma::fmat stdGenoMultiMarkersMat(&stdGenoMultiMarkers.front(), m_M_Submarker, Nnomissing);
+
+//      return(stdGenoMultiMarkersMat);
+        //std::cout << "stdGenoMultiMarkers[Nnomissing*m_M_Submarker-1] " << stdGenoMultiMarkers[Nnomissing*m_M_Submarker-1] << std::endl;
+
+}
+
+
+// [[Rcpp::export]]
+void Get_MultiMarkersBySample_StdGeno(arma::fvec& markerIndexVec, std::vector<float> &stdGenoMultiMarkers){
+
+//      std::cout << "createSparseKin1c" << std::endl;
+        int indexOfVectorPointer;
+        int SNPIdxinVec;
+        size_t Start_idx;
+        size_t ind= 0;
+        size_t indtotal = 0;
+        unsigned char geno1;
+        float freq;
+        float invStd;
+        int flag;
+        int SNPIdx;
+
+        int m_M_Submarker = markerIndexVec.n_elem;
+        //arma::fvec stdGenoMultiMarkers;
+        int Nnomissing = ptr_gNULLGENOobj->getNnomissing();
+
+
+//      std::cout << "createSparseKin1d" << std::endl;
+        for(size_t k=0; k< m_M_Submarker; k++){
+                ind = 0;
+                flag = 0;
+                SNPIdx = markerIndexVec[k];
+                indexOfVectorPointer = SNPIdx/(ptr_gNULLGENOobj->numMarkersofEachArray);
+                SNPIdxinVec = SNPIdx % (ptr_gNULLGENOobj->numMarkersofEachArray);
+                Start_idx = (ptr_gNULLGENOobj->m_size_of_esi) * SNPIdxinVec;
+                freq = (ptr_gNULLGENOobj->alleleFreqVec)[SNPIdx];
+                invStd = (ptr_gNULLGENOobj->invstdvVec)[SNPIdx];
+                //if(k == 0){
+                //      std::cout << "freq: " << freq << " invStd: " << invStd << "  SNPIdx: " << SNPIdx << std::endl;
+                //}
+
+                while(flag == 0){
+//              std::cout << "createSparseKin1e" << std::endl;
+                for(size_t i=Start_idx; i< Start_idx+(ptr_gNULLGENOobj->m_size_of_esi); i++){
+                        geno1 = (ptr_gNULLGENOobj->genoVecofPointers)[indexOfVectorPointer]->at(i);
+                        //std::cout << "createSparseKin1f" << std::endl;
+
+                        for(int j=0; j<4; j++){
+                        int b = geno1 & 1 ;
+                        geno1 = geno1 >> 1;
+                        int a = geno1 & 1 ;
+                        stdGenoMultiMarkers[ind*m_M_Submarker+k] = ((2-(a+b)) - 2*freq)* invStd;;
+//                      stdGenoMultiMarkers[ind*m_M_Submarker+k] = 2-(a+b);
+//                      if(k == 0){
+    //                    std::cout << "ind*m_M_Submarker+k: " << ind*m_M_Submarker+k << " stdGenoMultiMarkers[ind*m_M_Submarker+k]: " << stdGenoMultiMarkers[ind*m_M_Submarker+k] <<  std::endl;
+  //              }
+
+
+                        indtotal++;
+                        ind++;
+                        geno1 = geno1 >> 1;
+
+                                if(ind == Nnomissing){
+                                        flag = 1;
+                                        break;
+                                }
+                        }// end of for(int j=0; j<4; j++){
+                    }// end of for(size_t i=Start_idx
+                } //end of while(flag == 0){
+
+        }
+
+        //std::cout << "stdGenoMultiMarkers[Nnomissing*m_M_Submarker-1] " << stdGenoMultiMarkers[Nnomissing*m_M_Submarker-1] << std::endl;
+
+}
+
+
+
+
+//http://gallery.rcpp.org/articles/parallel-inner-product/
+struct CorssProd : public Worker
+{
+        // source vectors
+        arma::fcolvec & m_bVec;
+        unsigned int m_N;
+        unsigned int m_M;
+
+        // product that I have accumulated
+        arma::fvec m_bout;
+        int Msub_mafge1perc;
+
+        // constructors
+        CorssProd(arma::fcolvec & y)
+                : m_bVec(y) {
+
+                m_M = ptr_gNULLGENOobj->getM();
+                m_N = ptr_gNULLGENOobj->getNnomissing();
+                m_bout.zeros(m_N);
+                Msub_mafge1perc=0;
+                //ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+        }
+        CorssProd(const CorssProd& CorssProd, Split)
+                : m_bVec(CorssProd.m_bVec)
+        {
+
+                m_N = CorssProd.m_N;
+                m_M = CorssProd.m_M;
+                m_bout.zeros(m_N);
+                Msub_mafge1perc=0;
+                //CorssProd.Msub_mafge1perc;
+
+        }
+        // process just the elements of the range I've been asked to
+        void operator()(std::size_t begin, std::size_t end) {
+                arma::fvec vec;
+                for(unsigned int i = begin; i < end; i++){
+                        //if(ptr_gNULLGENOobj->alleleFreqVec[i] >= minMAFtoConstructGRM && ptr_gNULLGENOobj->alleleFreqVec[i] <= 1-minMAFtoConstructGRM){
+                                ptr_gNULLGENOobj->Get_OneSNP_StdGeno(i, &vec);
+                                float val1 = dot(vec,  m_bVec);
+                                m_bout += val1 * (vec) ;
+                                Msub_mafge1perc += 1;
+                        //}
+                        //std::cout << "i: " << i << std::endl;
+                        //for(unsigned int j = 0; j < 10; j++){
+                        //      std::cout << "m_bVec[j] " << m_bVec[j] << std::endl;
+                        //      std::cout << "vec[j] " << vec[j] << std::endl;
+                        //}
+
+                        //m_bout += val1 * (vec) / m_M;
+                }
+        }
+
+        // join my value with that of another InnerProduct
+        void join(const CorssProd & rhs) {
+                m_bout += rhs.m_bout;
+                Msub_mafge1perc += rhs.Msub_mafge1perc;
+        }
+};
+
+
+
+//http://gallery.rcpp.org/articles/parallel-inner-product/
+struct CorssProd_LOCO : public Worker
+{
+        // source vectors
+        arma::fcolvec & m_bVec;
+        unsigned int m_N;
+        unsigned int m_Msub;
+        unsigned int m_M;
+        int startIndex;
+        int endIndex;
+        // product that I have accumulated
+        arma::fvec m_bout;
+        unsigned int m_Msub_mafge1perc;
+
+        // constructors
+        CorssProd_LOCO(arma::fcolvec & y)
+                : m_bVec(y) {
+
+                m_Msub = ptr_gNULLGENOobj->getMsub(); //LOCO
+                startIndex = ptr_gNULLGENOobj->getStartIndex();
+                endIndex = ptr_gNULLGENOobj->getEndIndex();
+                m_M = ptr_gNULLGENOobj->getM(); //LOCO
+                m_N = ptr_gNULLGENOobj->getNnomissing();
+                m_bout.zeros(m_N);
+                m_Msub_mafge1perc=0;
+                //ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+        }
+        CorssProd_LOCO(const CorssProd_LOCO& CorssProd_LOCO, Split)
+                : m_bVec(CorssProd_LOCO.m_bVec)
+        {
+
+                m_N = CorssProd_LOCO.m_N;
+                m_M = CorssProd_LOCO.m_M;
+                m_Msub = CorssProd_LOCO.m_Msub;
+                startIndex = ptr_gNULLGENOobj->getStartIndex();
+                endIndex = ptr_gNULLGENOobj->getEndIndex();
+                m_bout.zeros(m_N);
+                m_Msub_mafge1perc=0;
+                //ptr_gNULLGENOobj->getnumberofMarkers_byChr(uint chr);
+        }
+
+           // process just the elements of the range I've been asked to
+        void operator()(std::size_t begin, std::size_t end) {
+                arma::fvec vec;
+                float val1;
+                for(unsigned int i = begin; i < end; i++){
+                        ptr_gNULLGENOobj->Get_OneSNP_StdGeno(i, &vec);
+                //      if(i >= startIndex && i <= endIndex){
+                //              val1 = 0;
+                                        //if(endIndex == 4){
+                                        //              cout << "i: " << i << endl;
+                                        //}
+                //      }else{
+                        val1 = dot(vec,  m_bVec);
+                        m_Msub_mafge1perc += 1;
+                //      }
+                        m_bout += val1 * (vec);
+                }
+        }
+
+        // join my value with that of another InnerProduct
+        void join(const CorssProd_LOCO & rhs) {
+        m_bout += rhs.m_bout;
+        m_Msub_mafge1perc += rhs.m_Msub_mafge1perc;
+        }
+};
+
+
+// [[Rcpp::export]]
+arma::fvec parallelCrossProd(arma::fcolvec & bVec) {
+
+  // declare the InnerProduct instance that takes a pointer to the vector data
+        //int M = ptr_gNULLGENOobj->getM();
+        //int Msub_mafge1perc = ptr_gNULLGENOobj->getMmafge1perc();
+        int Msub_mafge1perc = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+        CorssProd CorssProd(bVec);
+
+  // call paralleReduce to start the work
+        parallelReduce(0, Msub_mafge1perc, CorssProd);
+
+        //cout << "print test; M: " << M << endl;
+        //for(int i=0; i<10; ++i)
+        //{
+        //        cout << (CorssProd.m_bout)[i] << ' ' << endl;
+        //        cout << bVec[i] << ' ' << endl;
+        //        cout << (CorssProd.m_bout/M)[i] << ' ' << endl;
+        //}
+        ////cout << endl;
+  // return the computed product
+        //std::cout << "number of markers with maf ge " << minMAFtoConstructGRM << " is " << CorssProd.Msub_mafge1perc << std::endl;
+        return CorssProd.m_bout/(CorssProd.Msub_mafge1perc);
+        //return CorssProd.m_bout;
+}
+
+// [[Rcpp::export]]
+float innerProductFun(std::vector<float> &x, std::vector<float> & y) {
+   return std::inner_product(x.begin(), x.end(), y.begin(), 0.0);
+}
+
+
+
+
+// [[Rcpp::export]]
+arma::fvec parallelCrossProd_full(arma::fcolvec & bVec, int & markerNum) {
+
+  // declare the InnerProduct instance that takes a pointer to the vector data
+        //int M = ptr_gNULLGENOobj->getM();
+        //
+        int Msub_mafge1perc = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+        CorssProd CorssProd(bVec);
+
+        //std::cout << "Msub_mafge1perc ok  " << Msub_mafge1perc << std::endl;
+  // call paralleReduce to start the work
+        parallelReduce(0, Msub_mafge1perc, CorssProd);
+        markerNum = CorssProd.Msub_mafge1perc;
+        //std::cout << "markerNum " << markerNum << std::endl;
+
+        //cout << "print test; M: " << M << endl;
+        //for(int i=0; i<10; ++i)
+        //{
+        //        cout << (CorssProd.m_bout)[i] << ' ' << endl;
+        //        cout << bVec[i] << ' ' << endl;
+        //        cout << (CorssProd.m_bout/M)[i] << ' ' << endl;
+        //}
+        ////cout << endl;
+  // return the computed product
+        //std::cout << "number of markers with maf ge " << minMAFtoConstructGRM << " is " << CorssProd.Msub_mafge1perc << std::endl;
+        return CorssProd.m_bout;
+        //return CorssProd.m_bout;
+}
+
+
+// [[Rcpp::export]]
+arma::fvec parallelCrossProd_LOCO(arma::fcolvec & bVec) {
+
+  // declare the InnerProduct instance that takes a pointer to the vector data
+        //int Msub = ptr_gNULLGENOobj->getMsub();
+        //int M = ptr_gNULLGENOobj->getM();
+        int numberMarker_full = 0;
+        arma::fvec outvec = parallelCrossProd_full(bVec, numberMarker_full);
+
+        //CorssProd_LOCO CorssProd_LOCO(bVec);
+        CorssProd CorssProd(bVec);
+  // call paralleReduce to start the work
+        int startIndex = ptr_gNULLGENOobj->getStartIndex();
+        int endIndex = ptr_gNULLGENOobj->getEndIndex();
+
+        parallelReduce(startIndex, endIndex+1, CorssProd);
+
+
+
+        outvec = outvec - CorssProd.m_bout;
+
+        /*
+        for(int i=0; i<10; ++i)
+        {
+                std::cout << (outvec)[i] << ' ';
+        }
+        std::cout << std::endl;
+*/
+
+        int markerNum = numberMarker_full - CorssProd.Msub_mafge1perc;
+        //std::cout << "markerNum: " << markerNum << std::endl;
+        // return the computed product
+        //cout << "Msub: " << Msub << endl;
+        //for(int i=0; i<100; ++i)
+        //{
+        //      cout << (CorssProd_LOCO.m_bout/Msub)[i] << ' ';
+        //}
+        //cout << endl;
+        //return CorssProd_LOCO.m_bout/Msub;
+        //return CorssProd_LOCO.m_bout/(CorssProd_LOCO.m_Msub_mafge1perc);
+        return outvec/markerNum;
+}
+
+// [[Rcpp::depends(RcppParallel)]]
+// [[Rcpp::plugins(cpp11)]]
+struct indicesRelatedSamples : public RcppParallel::Worker {
+
+  int  Ntotal;
+  tbb::concurrent_vector< std::pair<int, int> > &output;
+
+  indicesRelatedSamples(int Ntotal, tbb::concurrent_vector< std::pair<int, int> > &output) :
+    Ntotal(Ntotal), output(output) {}
+
+
+  void operator()(std::size_t begin, size_t end) {
+    int m_M_Submarker = getSubMarkerNum();
+    for(std::size_t k=begin; k < end; k++) {
+      int i = (int)(k / Ntotal);
+      int j = (int)(k % Ntotal);
+      if((j <= i)){
+                        i = Ntotal - i - 2;
+                        j = Ntotal - j - 1;
+      }
+      //std::cout << "i,j,k debug: " << i << " " << j << " " << k << std::endl;
+      float kinValueTemp = arma::dot((ptr_gNULLGENOobj->stdGenoMultiMarkersMat).col(i), (ptr_gNULLGENOobj->stdGenoMultiMarkersMat).col(j));
+      kinValueTemp = kinValueTemp/m_M_Submarker;
+      if(kinValueTemp >=  ptr_gNULLGENOobj->relatednessCutoff) {
+        output.push_back( std::pair<int, int>(i, j) );
+      }
+    }
+  }
+
+};
+
+
+// [[Rcpp::export]]
+void printComb(int N){
+  int x = N*(N-1)/2 - 1;
+  for(std::size_t k=0; k < x; k++) {
+      int i = k / N;
+      int j = k % N;
+      if((j < i)){
+                        i = N - i - 2;
+                        j = N - j - 1;
+      }
+     std::cout << "i,j " << i << "," << j << std::endl;
+  }
+
+}
+
+
+// [[Rcpp::export]]
+void findIndiceRelatedSample(){
+
+  int Ntotal = ptr_gNULLGENOobj->getNnomissing();
+//  tbb::concurrent_vector< std::pair<float, float> > output;
+
+//  indicesRelatedSamples indicesRelatedSamples(Ntotal,output);
+  indicesRelatedSamples indicesRelatedSamples(Ntotal,ptr_gNULLGENOobj->indiceVec);
+
+  long int Ntotal2 = (long int)Ntotal;
+
+  long int totalCombination = Ntotal2*(Ntotal2-1)/2 - 1;
+  std::cout << "Ntotal: " << Ntotal << std::endl;
+  std::cout << std::numeric_limits<int>::max() << std::endl;
+  std::cout << std::numeric_limits<long int>::max() << std::endl;
+  std::cout << std::numeric_limits<long long int>::max() << std::endl;
+  std::cout << "totalCombination: " << totalCombination << std::endl;
+  long int x = 1000001;
+  int b = (int)(x / Ntotal);
+  int a = (int)(x % Ntotal);
+  std::cout << "a " << a << std::endl;
+  std::cout << "b " << b << std::endl;
+
+  parallelFor(0, totalCombination, indicesRelatedSamples);
+
+//  arma::fmat xout(output.size()+Ntotal,2);
+
+//  for(int i=0; i<output.size(); i++) {
+//    xout(i,0) = output[i].first;
+//    xout(i,1) = output[i].second;
+//  }
+//  for(int i=output.size(); i < output.size()+Ntotal; i++) {
+//    xout(i,0) = i - output.size();
+//    xout(i,1) = xout(i,0);
+//  }
+
+/*
+  for(int i=0; i < Ntotal; i++){
+    (ptr_gNULLGENOobj->indiceVec).push_back( std::pair<int, int>(i, i) );
+  }
+*/
+
+//  return(xout);
+}
+
+
+struct sparseGRMUsingOneMarker : public Worker {
+   // input matrix to read from
+  // arma::imat & iMat;
+   // output matrix to write to
+   arma::fvec & GRMvec;
+
+   //int M = ptr_gNULLGENOobj->getM();
+   // initialize from Rcpp input and output matrixes (the RMatrix class
+   // can be automatically converted to from the Rcpp matrix type)
+//   sparseGRMUsingOneMarker(arma::imat & iMat, arma::fvec &GRMvec)
+//      : iMat(iMat), GRMvec(GRMvec) {}
+
+
+  sparseGRMUsingOneMarker(arma::fvec &GRMvec)
+      : GRMvec(GRMvec) {}
+
+
+   // function call operator that work for the specified range (begin/end)
+   void operator()(std::size_t begin, std::size_t end) {
+      for (std::size_t i = begin; i < end; i++) {
+            // rows we will operate on
+//            int iint = iMat(i,0);
+//            int jint = iMat(i,1);
+           int iint = (ptr_gNULLGENOobj->indiceVec)[i].first;
+           int jint = (ptr_gNULLGENOobj->indiceVec)[i].second;
+/*
+            float ival = ptr_gNULLGENOobj->m_OneSNP_StdGeno(iint);
+            float jval = ptr_gNULLGENOobj->m_OneSNP_StdGeno(jint);
+            // write to output matrix
+            //rmat(i,j) = sqrt(.5 * (d1 + d2));
+            GRMvec(i) = ival*jval/M;
+*/
+        //use Look-Up table for calucate GRMvec(i)
+            int ival = ptr_gNULLGENOobj->m_OneSNP_Geno(iint);
+            int jval = ptr_gNULLGENOobj->m_OneSNP_Geno(jint);
+            GRMvec(i) = ptr_gNULLGENOobj->sKinLookUpArr[ival][jval];
+
+      }
+   }
+};
+
+
+// [[Rcpp::export]]
+void parallelcalsparseGRM(arma::fvec &GRMvec) {
+
+//  int n1 = ptr_gNULLGENOobj->indiceVec.size();
+  // allocate the output matrix
+  //GRMvec.set_size(n1);
+//  std::cout << "OKKK3: "  << std::endl;
+//  sparseGRMUsingOneMarker sparseGRMUsingOneMarker(iMat, GRMvec);
+  sparseGRMUsingOneMarker sparseGRMUsingOneMarker(GRMvec);
+//  std::cout << "OKKK4: "  << std::endl;
+
+//  std::cout << "n1 " << n1 << std::endl;
+//  std::cout << "iMat.n_cols " << iMat.n_cols << std::endl;
+  // call parallelFor to do the work
+//  parallelFor(0, iMat.n_rows, sparseGRMUsingOneMarker);
+  parallelFor(0, (ptr_gNULLGENOobj->indiceVec).size(), sparseGRMUsingOneMarker);
+
+  // return the output matrix
+  // return GRMvec;
+}
+
+struct sumTwoVec : public Worker
+{
+   // source vectors
+   arma::fvec &x;
+
+   arma::fvec &sumVec;
+
+   //int M = ptr_gNULLGENOobj->getM();
+   // constructors
+   sumTwoVec(arma::fvec &x,arma::fvec &sumVec)
+      : x(x), sumVec(sumVec) {}
+
+     // function call operator that work for the specified range (begin/end)
+   void operator()(std::size_t begin, std::size_t end) {
+      for (std::size_t i = begin; i < end; i++) {
+            // rows we will operate on
+            sumVec(i) = x(i)+(ptr_gNULLGENOobj->kinValueVecFinal)[i];
+            (ptr_gNULLGENOobj->kinValueVecFinal)[i] = sumVec(i);
+      }
+   }
+
+};
+
+// [[Rcpp::export]]
+void  parallelsumTwoVec(arma::fvec &x) {
+  int n1 = x.n_elem;
+  // allocate the output matrix
+  arma::fvec sumVec;
+  sumVec.set_size(n1);
+
+  sumTwoVec sumTwoVec(x, sumVec);
+
+  // call parallelFor to do the work
+  parallelFor(0, x.n_elem, sumTwoVec);
+
+}
+
+
+
+// [[Rcpp::export]]
+void setgenoNULL(){
+	ptr_gNULLGENOobj = new NullGENO::NullGenoClass();
+}
+// [[Rcpp::export]]
+void setgeno(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int> & subSampleInGeno, std::vector<bool> & indicatorGenoSamplesWithPheno, float memoryChunk, bool isDiagofKinSetAsOne)
+{
+        int start_s=clock();
+
+	//ptr_gNULLGENOobj = new NullGENO::NullGenoClass(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne
+//			);
+
+
+        ptr_gNULLGENOobj->setGenoObj(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne);
+        //ptr_gNULLGENOobj->printAlleleFreqVec();
+        //ptr_gNULLGENOobj->printGenoVec();
+        int stop_s=clock();
+        cout << "time: " << (stop_s-start_s)/double(CLOCKS_PER_SEC)*1000 << endl;
+}
+
+
+
+
+// [[Rcpp::export]]
+arma::ivec Get_OneSNP_Geno(int SNPIdx)
+{
+
+        arma::ivec temp = * ptr_gNULLGENOobj->Get_OneSNP_Geno(SNPIdx);
+        return(temp);
+
+}
+
+// [[Rcpp::export]]
+arma::ivec Get_OneSNP_Geno_forVarRatio(int SNPIdx)
+{
+
+        arma::ivec temp = * ptr_gNULLGENOobj->Get_OneSNP_Geno_forVarRatio(SNPIdx);
+        return(temp);
+
+}
+// [[Rcpp::export]]
+arma::fvec Get_OneSNP_StdGeno(int SNPIdx)
+{
+        arma::fvec temp;
+        ptr_gNULLGENOobj->Get_OneSNP_StdGeno(SNPIdx, & temp);
+        return(temp);
+
+}
+
+/*
+// [[Rcpp::export]]
+void set_var_weights(arma::vec & t_var_weights){
+	arma::fvec t_var_weights_f = arma::conv_to< arma::fvec >::from(t_var_weights); 
+	g_var_weights = t_var_weights_f;
+}
+*/
diff --git a/src/Main.hpp b/src/Main.hpp
index a82c3e1b..84630c3f 100644
--- a/src/Main.hpp
+++ b/src/Main.hpp
@@ -1,10 +1,13 @@
 #ifndef MAIN_HPP
 #define MAIN_HPP
 
+#define ARMA_USE_SUPERLU 1
 // [[Rcpp::depends(RcppArmadillo)]]
 #include <RcppArmadillo.h>
 
 
+void set_dup_sample_index(arma::uvec & t_dup_sample_Index);
+
 void setAssocTest_GlobalVarsInCPP(std::string t_impute_method,
                 double t_missing_cutoff,
                                double t_min_maf_marker,
@@ -154,9 +157,6 @@ void setSAIGEobjInCPP(arma::mat & t_XVX,
         bool t_flagSparseGRM,
 	bool t_isFastTest,
 	double t_pval_cutoff_for_fastTest,
-        arma::umat & t_locationMat,
-        arma::vec & t_valueVec,
-        int t_dimNum,
         bool t_isCondition,
         std::vector<uint32_t> & t_condition_genoIndex,
 	bool t_is_Firth_beta,
@@ -359,4 +359,179 @@ int writeOutfile_singleInGroup(bool t_isMoreOutput,
 uint32_t Unified_getSampleSizeinGeno(std::string & t_genoType);
 uint32_t Unified_getSampleSizeinAnalysis(std::string & t_genoType);
 
+
+void setupSparseGRM_new(arma::sp_mat & t_spGRM);
+
+void set_I_longl_mat(arma::sp_mat & t_Ilongmat, arma::vec & t_I_longl_vec);
+
+void set_T_longl_mat(arma::sp_mat & t_Tlongmat, arma::vec & t_T_longl_vec);
+
+arma::fvec getCrossprodMatAndKin(arma::fcolvec& bVec, bool LOCO);
+
+arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+
+arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+
+void gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec);
+
+arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO);
+
+
+void set_seed(unsigned int seed);
+
+Rcpp::NumericVector nb(int n);
+
+void setStartEndIndex(int startIndex, int endIndex, int chromIndex);
+
+void setStartEndIndexVec( arma::ivec & startIndex_vec,  arma::ivec & endIndex_vec);
+
+float calCV(arma::fvec& xVec);
+
+arma::fmat getSigma_X_multiV(arma::fvec& wVec, arma::fvec& tauVec,arma::fmat& Xmat, int maxiterPCG, float tolPCG, bool LOCO);
+
+arma::fvec  getSigma_G_multiV(arma::fvec& wVec, arma::fvec& tauVec,arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO);
+
+Rcpp::List fitglmmaiRPCG_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec &wVec,  arma::fvec & tauVec, arma::ivec & fixtauVec, arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
+int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOCO);
+
+arma::fvec getMeanDiagofKmat(bool LOCO);
+
+arma::ivec updatefixrhoidx0(arma::fvec & t_tau0Vec, float tol);
+
+arma::ivec tauUpdateValue(arma::fvec & t_tau0Vec);
+
+Rcpp::List getAIScore_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, arma::ivec & fixtauVec,
+arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
+int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO);
+
+
+arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec & fixtauVec, arma::fmat& cov1,  int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO);
+
+
+Rcpp::List getCoefficients_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, int maxiterPCG, float tolPCG, bool LOCO);
+
+
+void setminMAC_VarianceRatio(float t_minMACVarRatio, float t_maxMACVarRatio, bool t_isVarianceRatioinGeno);
+
+
+arma::fvec get_GRMdiagVec();
+
+
+void setminMAFforGRM(float minMAFforGRM);
+
+
+void setmaxMissingRateforGRM(float maxMissingforGRM);
+
+
+void set_Diagof_StdGeno_LOCO();
+
+
+arma::fvec get_DiagofKin();
+
+arma::fvec parallelCrossProd_usingSubMarker(arma::fcolvec & bVec);
+
+arma::fvec getCrossprodMatAndKin_usingSubMarker(arma::fcolvec& bVec);
+
+float parallelInnerProduct(std::vector<float> &x, std::vector<float> &y);
+
+Rcpp::List createSparseKin(arma::fvec& markerIndexVec, float relatednessCutoff, arma::fvec& wVec,  arma::fvec& tauVec);
+
+
+Rcpp::List refineKin(float relatednessCutoff);
+
+arma::fmat getColfromStdGenoMultiMarkersMat(arma::uvec & a);
+
+int getNColStdGenoMultiMarkersMat();
+
+int getNRowStdGenoMultiMarkersMat();
+
+void setSubMarkerIndex(arma::ivec &subMarkerIndexRandom);
+
+void setRelatednessCutoff(float a);
+
+double innerProduct(Rcpp::NumericVector x, Rcpp::NumericVector y) ;
+
+arma::fvec getDiagOfSigma_noV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+
+arma::fcolvec getCrossprod_noV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+
+arma::fvec getPCG1ofSigmaAndVector_noV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO);
+
+arma::fvec  getSigma_G_noV(arma::fvec& wVec, arma::fvec& tauVec,arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO);
+
+
+void set_useGRMtoFitNULL(bool useGRMtoFitNULL);
+
+void set_isSparseGRM(bool t_isSparseGRM);
+
+void set_store_sigma(bool isstoreSigma);
+
+void set_num_Kmat(int t_num_Kmat);
+
+int get_numofV();
+
+arma::umat set_covarianceidx_Mat();
+
+//void set_Vmat_vec_longlVar();
+
+void closeGenoFile_plink();
+
+int gettotalMarker();
+
+arma::fvec getAlleleFreqVec();
+
+arma::ivec getMACVec();
+
+arma::ivec getMACVec_forVarRatio();
+
+arma::ivec getIndexVec_forVarRatio();
+
+bool getIsVarRatioGeno();
+
+arma::ivec getSubMarkerIndex();
+
+std::vector<bool> getQCdMarkerIndex();
+
+int getSubMarkerNum();
+
+void initKinValueVecFinal(int ni);
+
+int getNnomissingOut();
+
+int getMsub_MAFge_minMAFtoConstructGRM();
+
+int getMsub_MAFge_minMAFtoConstructGRM_singleChr();
+
+void Get_MultiMarkersBySample_StdGeno_Mat();
+
+void Get_MultiMarkersBySample_StdGeno(arma::fvec& markerIndexVec, std::vector<float> &stdGenoMultiMarkers);
+
+
+arma::fvec parallelCrossProd(arma::fcolvec & bVec);
+
+float innerProductFun(std::vector<float> &x, std::vector<float> & y);
+
+arma::fvec parallelCrossProd_full(arma::fcolvec & bVec, int & markerNum);
+
+arma::fvec parallelCrossProd_LOCO(arma::fcolvec & bVec);
+
+void printComb(int N);
+
+void findIndiceRelatedSample();
+
+void parallelcalsparseGRM(arma::fvec &GRMvec);
+
+void  parallelsumTwoVec(arma::fvec &x);
+
+void setgenoNULL();
+
+void setgeno(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int> & subSampleInGeno, std::vector<bool> & indicatorGenoSamplesWithPheno, float memoryChunk, bool isDiagofKinSetAsOne);
+
+arma::ivec Get_OneSNP_Geno(int SNPIdx);
+
+arma::ivec Get_OneSNP_Geno_forVarRatio(int SNPIdx);
+
+arma::fvec Get_OneSNP_StdGeno(int SNPIdx);
+
+
 #endif
diff --git a/src/Makevars b/src/Makevars
index 49b8697a..29e56993 100644
--- a/src/Makevars
+++ b/src/Makevars
@@ -12,7 +12,8 @@ PKG_LIBS += $(shell ${R_HOME}/bin/Rscript -e "RcppParallel::RcppParallelLibs()")
 
 #OBJECTS = RcppExports.o SAIGE_fitGLMM_fast.o getMem.o VCF.o BGEN.o PLINK.o SAIGE_test.o SPA_binary.o SPA.o SPA_survival.o UTIL.o Main.o test.o CCT.o 
 #OBJECTS = RcppExports.o SAIGE_fitGLMM_fast.o getMem.o VCF.o BGEN.o PLINK.o SAIGE_test.o SPA_binary.o SPA.o SPA_survival.o UTIL.o Main.o test.o CCT.o Binary_HyperGeo.o Binary_ComputeExact.o Binary_global.o Binary_ComputeExactSKATO.o Binary_resampling.o Binary_Permu_SKAT.o ER_binary_func.o LDmat.o 
-OBJECTS = RcppExports.o SAIGE_fitGLMM_fast_multiV.o getMem.o VCF.o BGEN.o PLINK.o SAIGE_test.o SPA_binary.o SPA.o SPA_survival.o UTIL.o Main.o test.o CCT.o Binary_HyperGeo.o Binary_ComputeExact.o Binary_global.o Binary_ComputeExactSKATO.o Binary_resampling.o Binary_Permu_SKAT.o ER_binary_func.o LDmat.o 
+#OBJECTS = RcppExports.o SAIGE_fitGLMM_fast_multiV.o getMem.o VCF.o BGEN.o PLINK.o SAIGE_test.o SPA_binary.o SPA.o SPA_survival.o UTIL.o Main.o test.o CCT.o Binary_HyperGeo.o Binary_ComputeExact.o Binary_global.o Binary_ComputeExactSKATO.o Binary_resampling.o Binary_Permu_SKAT.o ER_binary_func.o LDmat.o 
+OBJECTS = RcppExports.o GENO_null.o getMem.o VCF.o BGEN.o PLINK.o SAIGE_test.o SPA_binary.o SPA.o SPA_survival.o UTIL.o Main.o test.o CCT.o Binary_HyperGeo.o Binary_ComputeExact.o Binary_global.o Binary_ComputeExactSKATO.o Binary_resampling.o Binary_Permu_SKAT.o ER_binary_func.o LDmat.o 
 
 all: $(SHLIB)
 $(SHLIB): ${OBJECTS} Makevars
diff --git a/src/RcppExports.cpp b/src/RcppExports.cpp
index c5da5c6f..d2635815 100644
--- a/src/RcppExports.cpp
+++ b/src/RcppExports.cpp
@@ -203,8 +203,8 @@ BEGIN_RCPP
 END_RCPP
 }
 // setSAIGEobjInCPP
-void setSAIGEobjInCPP(arma::mat& t_XVX, arma::mat& t_XXVX_inv, arma::mat& t_XV, arma::mat& t_XVX_inv_XV, arma::mat& t_Sigma_iXXSigma_iX, arma::mat& t_X, arma::vec& t_S_a, arma::vec& t_res, arma::vec& t_mu2, arma::vec& t_mu, arma::vec& t_varRatio_sparse, arma::vec& t_varRatio_null, arma::vec& t_cateVarRatioMinMACVecExclude, arma::vec& t_cateVarRatioMaxMACVecInclude, double t_SPA_Cutoff, arma::vec& t_tauvec, std::string t_traitType, arma::vec& t_y, std::string t_impute_method, bool t_flagSparseGRM, bool t_isFastTest, double t_pval_cutoff_for_fastTest, arma::umat& t_locationMat, arma::vec& t_valueVec, int t_dimNum, bool t_isCondition, std::vector<uint32_t>& t_condition_genoIndex, bool t_is_Firth_beta, double t_pCutoffforFirth, arma::vec& t_offset, arma::vec& t_resout);
-RcppExport SEXP _SAIGE_setSAIGEobjInCPP(SEXP t_XVXSEXP, SEXP t_XXVX_invSEXP, SEXP t_XVSEXP, SEXP t_XVX_inv_XVSEXP, SEXP t_Sigma_iXXSigma_iXSEXP, SEXP t_XSEXP, SEXP t_S_aSEXP, SEXP t_resSEXP, SEXP t_mu2SEXP, SEXP t_muSEXP, SEXP t_varRatio_sparseSEXP, SEXP t_varRatio_nullSEXP, SEXP t_cateVarRatioMinMACVecExcludeSEXP, SEXP t_cateVarRatioMaxMACVecIncludeSEXP, SEXP t_SPA_CutoffSEXP, SEXP t_tauvecSEXP, SEXP t_traitTypeSEXP, SEXP t_ySEXP, SEXP t_impute_methodSEXP, SEXP t_flagSparseGRMSEXP, SEXP t_isFastTestSEXP, SEXP t_pval_cutoff_for_fastTestSEXP, SEXP t_locationMatSEXP, SEXP t_valueVecSEXP, SEXP t_dimNumSEXP, SEXP t_isConditionSEXP, SEXP t_condition_genoIndexSEXP, SEXP t_is_Firth_betaSEXP, SEXP t_pCutoffforFirthSEXP, SEXP t_offsetSEXP, SEXP t_resoutSEXP) {
+void setSAIGEobjInCPP(arma::mat& t_XVX, arma::mat& t_XXVX_inv, arma::mat& t_XV, arma::mat& t_XVX_inv_XV, arma::mat& t_Sigma_iXXSigma_iX, arma::mat& t_X, arma::vec& t_S_a, arma::vec& t_res, arma::vec& t_mu2, arma::vec& t_mu, arma::vec& t_varRatio_sparse, arma::vec& t_varRatio_null, arma::vec& t_cateVarRatioMinMACVecExclude, arma::vec& t_cateVarRatioMaxMACVecInclude, double t_SPA_Cutoff, arma::vec& t_tauvec, std::string t_traitType, arma::vec& t_y, std::string t_impute_method, bool t_flagSparseGRM, bool t_isFastTest, double t_pval_cutoff_for_fastTest, bool t_isCondition, std::vector<uint32_t>& t_condition_genoIndex, bool t_is_Firth_beta, double t_pCutoffforFirth, arma::vec& t_offset, arma::vec& t_resout, arma::sp_mat& t_SigmaMat_sp);
+RcppExport SEXP _SAIGE_setSAIGEobjInCPP(SEXP t_XVXSEXP, SEXP t_XXVX_invSEXP, SEXP t_XVSEXP, SEXP t_XVX_inv_XVSEXP, SEXP t_Sigma_iXXSigma_iXSEXP, SEXP t_XSEXP, SEXP t_S_aSEXP, SEXP t_resSEXP, SEXP t_mu2SEXP, SEXP t_muSEXP, SEXP t_varRatio_sparseSEXP, SEXP t_varRatio_nullSEXP, SEXP t_cateVarRatioMinMACVecExcludeSEXP, SEXP t_cateVarRatioMaxMACVecIncludeSEXP, SEXP t_SPA_CutoffSEXP, SEXP t_tauvecSEXP, SEXP t_traitTypeSEXP, SEXP t_ySEXP, SEXP t_impute_methodSEXP, SEXP t_flagSparseGRMSEXP, SEXP t_isFastTestSEXP, SEXP t_pval_cutoff_for_fastTestSEXP, SEXP t_isConditionSEXP, SEXP t_condition_genoIndexSEXP, SEXP t_is_Firth_betaSEXP, SEXP t_pCutoffforFirthSEXP, SEXP t_offsetSEXP, SEXP t_resoutSEXP, SEXP t_SigmaMat_spSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< arma::mat& >::type t_XVX(t_XVXSEXP);
@@ -229,28 +229,14 @@ BEGIN_RCPP
     Rcpp::traits::input_parameter< bool >::type t_flagSparseGRM(t_flagSparseGRMSEXP);
     Rcpp::traits::input_parameter< bool >::type t_isFastTest(t_isFastTestSEXP);
     Rcpp::traits::input_parameter< double >::type t_pval_cutoff_for_fastTest(t_pval_cutoff_for_fastTestSEXP);
-    Rcpp::traits::input_parameter< arma::umat& >::type t_locationMat(t_locationMatSEXP);
-    Rcpp::traits::input_parameter< arma::vec& >::type t_valueVec(t_valueVecSEXP);
-    Rcpp::traits::input_parameter< int >::type t_dimNum(t_dimNumSEXP);
     Rcpp::traits::input_parameter< bool >::type t_isCondition(t_isConditionSEXP);
     Rcpp::traits::input_parameter< std::vector<uint32_t>& >::type t_condition_genoIndex(t_condition_genoIndexSEXP);
     Rcpp::traits::input_parameter< bool >::type t_is_Firth_beta(t_is_Firth_betaSEXP);
     Rcpp::traits::input_parameter< double >::type t_pCutoffforFirth(t_pCutoffforFirthSEXP);
     Rcpp::traits::input_parameter< arma::vec& >::type t_offset(t_offsetSEXP);
     Rcpp::traits::input_parameter< arma::vec& >::type t_resout(t_resoutSEXP);
-    setSAIGEobjInCPP(t_XVX, t_XXVX_inv, t_XV, t_XVX_inv_XV, t_Sigma_iXXSigma_iX, t_X, t_S_a, t_res, t_mu2, t_mu, t_varRatio_sparse, t_varRatio_null, t_cateVarRatioMinMACVecExclude, t_cateVarRatioMaxMACVecInclude, t_SPA_Cutoff, t_tauvec, t_traitType, t_y, t_impute_method, t_flagSparseGRM, t_isFastTest, t_pval_cutoff_for_fastTest, t_locationMat, t_valueVec, t_dimNum, t_isCondition, t_condition_genoIndex, t_is_Firth_beta, t_pCutoffforFirth, t_offset, t_resout);
-    return R_NilValue;
-END_RCPP
-}
-// setSparseSigmaInCPP
-void setSparseSigmaInCPP(int r, arma::umat& t_locationMatinR, arma::vec& t_valueVecinR);
-RcppExport SEXP _SAIGE_setSparseSigmaInCPP(SEXP rSEXP, SEXP t_locationMatinRSEXP, SEXP t_valueVecinRSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type r(rSEXP);
-    Rcpp::traits::input_parameter< arma::umat& >::type t_locationMatinR(t_locationMatinRSEXP);
-    Rcpp::traits::input_parameter< arma::vec& >::type t_valueVecinR(t_valueVecinRSEXP);
-    setSparseSigmaInCPP(r, t_locationMatinR, t_valueVecinR);
+    Rcpp::traits::input_parameter< arma::sp_mat& >::type t_SigmaMat_sp(t_SigmaMat_spSEXP);
+    setSAIGEobjInCPP(t_XVX, t_XXVX_inv, t_XV, t_XVX_inv_XV, t_Sigma_iXXSigma_iX, t_X, t_S_a, t_res, t_mu2, t_mu, t_varRatio_sparse, t_varRatio_null, t_cateVarRatioMinMACVecExclude, t_cateVarRatioMaxMACVecInclude, t_SPA_Cutoff, t_tauvec, t_traitType, t_y, t_impute_method, t_flagSparseGRM, t_isFastTest, t_pval_cutoff_for_fastTest, t_isCondition, t_condition_genoIndex, t_is_Firth_beta, t_pCutoffforFirth, t_offset, t_resout, t_SigmaMat_sp);
     return R_NilValue;
 END_RCPP
 }
@@ -454,585 +440,526 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
-// addNewKat
-void addNewKat(arma::sp_mat& t_Kmat);
-RcppExport SEXP _SAIGE_addNewKat(SEXP t_KmatSEXP) {
+// set_dup_sample_index
+void set_dup_sample_index(arma::uvec& t_dup_sample_Index);
+RcppExport SEXP _SAIGE_set_dup_sample_index(SEXP t_dup_sample_IndexSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::sp_mat& >::type t_Kmat(t_KmatSEXP);
-    addNewKat(t_Kmat);
+    Rcpp::traits::input_parameter< arma::uvec& >::type t_dup_sample_Index(t_dup_sample_IndexSEXP);
+    set_dup_sample_index(t_dup_sample_Index);
     return R_NilValue;
 END_RCPP
 }
-// getProdTauKmat
-arma::sp_fmat getProdTauKmat(arma::fvec& tauVec);
-RcppExport SEXP _SAIGE_getProdTauKmat(SEXP tauVecSEXP) {
+// setupSparseGRM_new
+void setupSparseGRM_new(arma::sp_mat& t_spGRM);
+RcppExport SEXP _SAIGE_setupSparseGRM_new(SEXP t_spGRMSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(getProdTauKmat(tauVec));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< arma::sp_mat& >::type t_spGRM(t_spGRMSEXP);
+    setupSparseGRM_new(t_spGRM);
+    return R_NilValue;
 END_RCPP
 }
-// getMeanDiagofKmat
-arma::fvec getMeanDiagofKmat();
-RcppExport SEXP _SAIGE_getMeanDiagofKmat() {
+// set_I_longl_mat
+void set_I_longl_mat(arma::sp_mat& t_Ilongmat, arma::vec& t_I_longl_vec);
+RcppExport SEXP _SAIGE_set_I_longl_mat(SEXP t_IlongmatSEXP, SEXP t_I_longl_vecSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getMeanDiagofKmat());
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< arma::sp_mat& >::type t_Ilongmat(t_IlongmatSEXP);
+    Rcpp::traits::input_parameter< arma::vec& >::type t_I_longl_vec(t_I_longl_vecSEXP);
+    set_I_longl_mat(t_Ilongmat, t_I_longl_vec);
+    return R_NilValue;
 END_RCPP
 }
-// get_numofV
-int get_numofV();
-RcppExport SEXP _SAIGE_get_numofV() {
+// set_T_longl_mat
+void set_T_longl_mat(arma::sp_mat& t_Tlongmat, arma::vec& t_T_longl_vec);
+RcppExport SEXP _SAIGE_set_T_longl_mat(SEXP t_TlongmatSEXP, SEXP t_T_longl_vecSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(get_numofV());
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< arma::sp_mat& >::type t_Tlongmat(t_TlongmatSEXP);
+    Rcpp::traits::input_parameter< arma::vec& >::type t_T_longl_vec(t_T_longl_vecSEXP);
+    set_T_longl_mat(t_Tlongmat, t_T_longl_vec);
+    return R_NilValue;
 END_RCPP
 }
-// set_longlVar_vec
-void set_longlVar_vec(arma::vec& longlVec);
-RcppExport SEXP _SAIGE_set_longlVar_vec(SEXP longlVecSEXP) {
+// getCrossprodMatAndKin
+arma::fvec getCrossprodMatAndKin(arma::fcolvec& bVec, bool LOCO);
+RcppExport SEXP _SAIGE_getCrossprodMatAndKin(SEXP bVecSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::vec& >::type longlVec(longlVecSEXP);
-    set_longlVar_vec(longlVec);
-    return R_NilValue;
+    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getCrossprodMatAndKin(bVec, LOCO));
+    return rcpp_result_gen;
 END_RCPP
 }
-// set_covarianceidx_Mat
-arma::umat set_covarianceidx_Mat();
-RcppExport SEXP _SAIGE_set_covarianceidx_Mat() {
+// getCrossprod_multiV
+arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+RcppExport SEXP _SAIGE_getCrossprod_multiV(SEXP bVecSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(set_covarianceidx_Mat());
+    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getCrossprod_multiV(bVec, wVec, tauVec, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// set_Vmat_vec_longlVar
-void set_Vmat_vec_longlVar();
-RcppExport SEXP _SAIGE_set_Vmat_vec_longlVar() {
+// getDiagOfSigma_multiV
+arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+RcppExport SEXP _SAIGE_getDiagOfSigma_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    set_Vmat_vec_longlVar();
-    return R_NilValue;
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getDiagOfSigma_multiV(wVec, tauVec, LOCO));
+    return rcpp_result_gen;
 END_RCPP
 }
-// closeGenoFile_plink
-void closeGenoFile_plink();
-RcppExport SEXP _SAIGE_closeGenoFile_plink() {
+// gen_sp_Sigma_multiV
+void gen_sp_Sigma_multiV(arma::fvec& wVec, arma::fvec& tauVec);
+RcppExport SEXP _SAIGE_gen_sp_Sigma_multiV(SEXP wVecSEXP, SEXP tauVecSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    closeGenoFile_plink();
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    gen_sp_Sigma_multiV(wVec, tauVec);
     return R_NilValue;
 END_RCPP
 }
-// gettotalMarker
-int gettotalMarker();
-RcppExport SEXP _SAIGE_gettotalMarker() {
+// getPCG1ofSigmaAndVector_multiV
+arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO);
+RcppExport SEXP _SAIGE_getPCG1ofSigmaAndVector_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP bVecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(gettotalMarker());
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type bVec(bVecSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getPCG1ofSigmaAndVector_multiV(wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getAlleleFreqVec
-arma::fvec getAlleleFreqVec();
-RcppExport SEXP _SAIGE_getAlleleFreqVec() {
+// set_seed
+void set_seed(unsigned int seed);
+RcppExport SEXP _SAIGE_set_seed(SEXP seedSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getAlleleFreqVec());
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< unsigned int >::type seed(seedSEXP);
+    set_seed(seed);
+    return R_NilValue;
 END_RCPP
 }
-// getMACVec
-arma::ivec getMACVec();
-RcppExport SEXP _SAIGE_getMACVec() {
+// nb
+Rcpp::NumericVector nb(int n);
+RcppExport SEXP _SAIGE_nb(SEXP nSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getMACVec());
+    Rcpp::traits::input_parameter< int >::type n(nSEXP);
+    rcpp_result_gen = Rcpp::wrap(nb(n));
     return rcpp_result_gen;
 END_RCPP
 }
-// getMACVec_forVarRatio
-arma::ivec getMACVec_forVarRatio();
-RcppExport SEXP _SAIGE_getMACVec_forVarRatio() {
+// setStartEndIndex
+void setStartEndIndex(int startIndex, int endIndex, int chromIndex);
+RcppExport SEXP _SAIGE_setStartEndIndex(SEXP startIndexSEXP, SEXP endIndexSEXP, SEXP chromIndexSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getMACVec_forVarRatio());
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< int >::type startIndex(startIndexSEXP);
+    Rcpp::traits::input_parameter< int >::type endIndex(endIndexSEXP);
+    Rcpp::traits::input_parameter< int >::type chromIndex(chromIndexSEXP);
+    setStartEndIndex(startIndex, endIndex, chromIndex);
+    return R_NilValue;
 END_RCPP
 }
-// getIndexVec_forVarRatio
-arma::ivec getIndexVec_forVarRatio();
-RcppExport SEXP _SAIGE_getIndexVec_forVarRatio() {
+// setStartEndIndexVec
+void setStartEndIndexVec(arma::ivec& startIndex_vec, arma::ivec& endIndex_vec);
+RcppExport SEXP _SAIGE_setStartEndIndexVec(SEXP startIndex_vecSEXP, SEXP endIndex_vecSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::ivec& >::type startIndex_vec(startIndex_vecSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type endIndex_vec(endIndex_vecSEXP);
+    setStartEndIndexVec(startIndex_vec, endIndex_vec);
+    return R_NilValue;
+END_RCPP
+}
+// calCV
+float calCV(arma::fvec& xVec);
+RcppExport SEXP _SAIGE_calCV(SEXP xVecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getIndexVec_forVarRatio());
+    Rcpp::traits::input_parameter< arma::fvec& >::type xVec(xVecSEXP);
+    rcpp_result_gen = Rcpp::wrap(calCV(xVec));
     return rcpp_result_gen;
 END_RCPP
 }
-// getIsVarRatioGeno
-bool getIsVarRatioGeno();
-RcppExport SEXP _SAIGE_getIsVarRatioGeno() {
+// getSigma_X_multiV
+arma::fmat getSigma_X_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fmat& Xmat, int maxiterPCG, float tolPCG, bool LOCO);
+RcppExport SEXP _SAIGE_getSigma_X_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP XmatSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getIsVarRatioGeno());
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getSigma_X_multiV(wVec, tauVec, Xmat, maxiterPCG, tolPCG, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getSubMarkerIndex
-arma::ivec getSubMarkerIndex();
-RcppExport SEXP _SAIGE_getSubMarkerIndex() {
+// getSigma_G_multiV
+arma::fvec getSigma_G_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO);
+RcppExport SEXP _SAIGE_getSigma_G_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP GvecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getSubMarkerIndex());
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type Gvec(GvecSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getSigma_G_multiV(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getQCdMarkerIndex
-std::vector<bool> getQCdMarkerIndex();
-RcppExport SEXP _SAIGE_getQCdMarkerIndex() {
+// fitglmmaiRPCG_multiV
+Rcpp::List fitglmmaiRPCG_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec& fixtauVec, arma::fvec& Sigma_iY, arma::fmat& Sigma_iX, arma::fmat& cov, int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOCO);
+RcppExport SEXP _SAIGE_fitglmmaiRPCG_multiV(SEXP YvecSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP fixtauVecSEXP, SEXP Sigma_iYSEXP, SEXP Sigma_iXSEXP, SEXP covSEXP, SEXP nrunSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP tolSEXP, SEXP traceCVcutoffSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getQCdMarkerIndex());
+    Rcpp::traits::input_parameter< arma::fvec& >::type Yvec(YvecSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type fixtauVec(fixtauVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type Sigma_iY(Sigma_iYSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Sigma_iX(Sigma_iXSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type cov(covSEXP);
+    Rcpp::traits::input_parameter< int >::type nrun(nrunSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< float >::type traceCVcutoff(traceCVcutoffSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(fitglmmaiRPCG_multiV(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, tol, traceCVcutoff, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getSubMarkerNum
-int getSubMarkerNum();
-RcppExport SEXP _SAIGE_getSubMarkerNum() {
+// getMeanDiagofKmat
+arma::fvec getMeanDiagofKmat(bool LOCO);
+RcppExport SEXP _SAIGE_getMeanDiagofKmat(SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getSubMarkerNum());
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getMeanDiagofKmat(LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getNnomissingOut
-int getNnomissingOut();
-RcppExport SEXP _SAIGE_getNnomissingOut() {
+// getAIScore_multiV
+Rcpp::List getAIScore_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec& fixtauVec, arma::fvec& Sigma_iY, arma::fmat& Sigma_iX, arma::fmat& cov, int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO);
+RcppExport SEXP _SAIGE_getAIScore_multiV(SEXP YvecSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP fixtauVecSEXP, SEXP Sigma_iYSEXP, SEXP Sigma_iXSEXP, SEXP covSEXP, SEXP nrunSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP traceCVcutoffSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getNnomissingOut());
+    Rcpp::traits::input_parameter< arma::fvec& >::type Yvec(YvecSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type fixtauVec(fixtauVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type Sigma_iY(Sigma_iYSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Sigma_iX(Sigma_iXSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type cov(covSEXP);
+    Rcpp::traits::input_parameter< int >::type nrun(nrunSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type traceCVcutoff(traceCVcutoffSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getAIScore_multiV(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getMsub_MAFge_minMAFtoConstructGRM
-int getMsub_MAFge_minMAFtoConstructGRM();
-RcppExport SEXP _SAIGE_getMsub_MAFge_minMAFtoConstructGRM() {
+// GetTrace_multiV
+arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec& fixtauVec, arma::fmat& cov1, int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO);
+RcppExport SEXP _SAIGE_GetTrace_multiV(SEXP Sigma_iXSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP fixtauVecSEXP, SEXP cov1SEXP, SEXP nrunSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP traceCVcutoffSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getMsub_MAFge_minMAFtoConstructGRM());
+    Rcpp::traits::input_parameter< arma::fmat >::type Sigma_iX(Sigma_iXSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type fixtauVec(fixtauVecSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type cov1(cov1SEXP);
+    Rcpp::traits::input_parameter< int >::type nrun(nrunSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type traceCVcutoff(traceCVcutoffSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(GetTrace_multiV(Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getMsub_MAFge_minMAFtoConstructGRM_singleChr
-int getMsub_MAFge_minMAFtoConstructGRM_singleChr();
-RcppExport SEXP _SAIGE_getMsub_MAFge_minMAFtoConstructGRM_singleChr() {
+// getCoefficients_multiV
+Rcpp::List getCoefficients_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, int maxiterPCG, float tolPCG, bool LOCO);
+RcppExport SEXP _SAIGE_getCoefficients_multiV(SEXP YvecSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getMsub_MAFge_minMAFtoConstructGRM_singleChr());
+    Rcpp::traits::input_parameter< arma::fvec& >::type Yvec(YvecSEXP);
+    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
+    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getCoefficients_multiV(Yvec, Xmat, wVec, tauVec, maxiterPCG, tolPCG, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// Get_MultiMarkersBySample_StdGeno_Mat
-void Get_MultiMarkersBySample_StdGeno_Mat();
-RcppExport SEXP _SAIGE_Get_MultiMarkersBySample_StdGeno_Mat() {
+// setminMAC_VarianceRatio
+void setminMAC_VarianceRatio(float t_minMACVarRatio, float t_maxMACVarRatio, bool t_isVarianceRatioinGeno);
+RcppExport SEXP _SAIGE_setminMAC_VarianceRatio(SEXP t_minMACVarRatioSEXP, SEXP t_maxMACVarRatioSEXP, SEXP t_isVarianceRatioinGenoSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Get_MultiMarkersBySample_StdGeno_Mat();
+    Rcpp::traits::input_parameter< float >::type t_minMACVarRatio(t_minMACVarRatioSEXP);
+    Rcpp::traits::input_parameter< float >::type t_maxMACVarRatio(t_maxMACVarRatioSEXP);
+    Rcpp::traits::input_parameter< bool >::type t_isVarianceRatioinGeno(t_isVarianceRatioinGenoSEXP);
+    setminMAC_VarianceRatio(t_minMACVarRatio, t_maxMACVarRatio, t_isVarianceRatioinGeno);
     return R_NilValue;
 END_RCPP
 }
-// Get_MultiMarkersBySample_StdGeno
-void Get_MultiMarkersBySample_StdGeno(arma::fvec& markerIndexVec, std::vector<float>& stdGenoMultiMarkers);
-RcppExport SEXP _SAIGE_Get_MultiMarkersBySample_StdGeno(SEXP markerIndexVecSEXP, SEXP stdGenoMultiMarkersSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type markerIndexVec(markerIndexVecSEXP);
-    Rcpp::traits::input_parameter< std::vector<float>& >::type stdGenoMultiMarkers(stdGenoMultiMarkersSEXP);
-    Get_MultiMarkersBySample_StdGeno(markerIndexVec, stdGenoMultiMarkers);
-    return R_NilValue;
-END_RCPP
-}
-// parallelCrossProd
-arma::fvec parallelCrossProd(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_parallelCrossProd(SEXP bVecSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(parallelCrossProd(bVec));
-    return rcpp_result_gen;
-END_RCPP
-}
-// innerProductFun
-float innerProductFun(std::vector<float>& x, std::vector<float>& y);
-RcppExport SEXP _SAIGE_innerProductFun(SEXP xSEXP, SEXP ySEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::vector<float>& >::type x(xSEXP);
-    Rcpp::traits::input_parameter< std::vector<float>& >::type y(ySEXP);
-    rcpp_result_gen = Rcpp::wrap(innerProductFun(x, y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// parallelCrossProd_full
-arma::fvec parallelCrossProd_full(arma::fcolvec& bVec, int& markerNum);
-RcppExport SEXP _SAIGE_parallelCrossProd_full(SEXP bVecSEXP, SEXP markerNumSEXP) {
+// get_GRMdiagVec
+arma::fvec get_GRMdiagVec();
+RcppExport SEXP _SAIGE_get_GRMdiagVec() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    Rcpp::traits::input_parameter< int& >::type markerNum(markerNumSEXP);
-    rcpp_result_gen = Rcpp::wrap(parallelCrossProd_full(bVec, markerNum));
+    rcpp_result_gen = Rcpp::wrap(get_GRMdiagVec());
     return rcpp_result_gen;
 END_RCPP
 }
-// parallelCrossProd_LOCO
-arma::fvec parallelCrossProd_LOCO(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_parallelCrossProd_LOCO(SEXP bVecSEXP) {
+// setminMAFforGRM
+void setminMAFforGRM(float minMAFforGRM);
+RcppExport SEXP _SAIGE_setminMAFforGRM(SEXP minMAFforGRMSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(parallelCrossProd_LOCO(bVec));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< float >::type minMAFforGRM(minMAFforGRMSEXP);
+    setminMAFforGRM(minMAFforGRM);
+    return R_NilValue;
 END_RCPP
 }
-// setupSparseGRM
-void setupSparseGRM(int r, arma::umat& locationMatinR, arma::vec& valueVecinR);
-RcppExport SEXP _SAIGE_setupSparseGRM(SEXP rSEXP, SEXP locationMatinRSEXP, SEXP valueVecinRSEXP) {
+// setmaxMissingRateforGRM
+void setmaxMissingRateforGRM(float maxMissingforGRM);
+RcppExport SEXP _SAIGE_setmaxMissingRateforGRM(SEXP maxMissingforGRMSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type r(rSEXP);
-    Rcpp::traits::input_parameter< arma::umat& >::type locationMatinR(locationMatinRSEXP);
-    Rcpp::traits::input_parameter< arma::vec& >::type valueVecinR(valueVecinRSEXP);
-    setupSparseGRM(r, locationMatinR, valueVecinR);
+    Rcpp::traits::input_parameter< float >::type maxMissingforGRM(maxMissingforGRMSEXP);
+    setmaxMissingRateforGRM(maxMissingforGRM);
     return R_NilValue;
 END_RCPP
 }
-// setupSparseGRM_new
-void setupSparseGRM_new(arma::sp_mat& t_spGRM);
-RcppExport SEXP _SAIGE_setupSparseGRM_new(SEXP t_spGRMSEXP) {
+// set_Diagof_StdGeno_LOCO
+void set_Diagof_StdGeno_LOCO();
+RcppExport SEXP _SAIGE_set_Diagof_StdGeno_LOCO() {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::sp_mat& >::type t_spGRM(t_spGRMSEXP);
-    setupSparseGRM_new(t_spGRM);
+    set_Diagof_StdGeno_LOCO();
     return R_NilValue;
 END_RCPP
 }
-// getCrossprodMatAndKin
-arma::fvec getCrossprodMatAndKin(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_getCrossprodMatAndKin(SEXP bVecSEXP) {
+// get_DiagofKin
+arma::fvec get_DiagofKin();
+RcppExport SEXP _SAIGE_get_DiagofKin() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(getCrossprodMatAndKin(bVec));
+    rcpp_result_gen = Rcpp::wrap(get_DiagofKin());
     return rcpp_result_gen;
 END_RCPP
 }
-// getCrossprodMatAndKin_LOCO
-arma::fvec getCrossprodMatAndKin_LOCO(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_getCrossprodMatAndKin_LOCO(SEXP bVecSEXP) {
+// parallelCrossProd_usingSubMarker
+arma::fvec parallelCrossProd_usingSubMarker(arma::fcolvec& bVec);
+RcppExport SEXP _SAIGE_parallelCrossProd_usingSubMarker(SEXP bVecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(getCrossprodMatAndKin_LOCO(bVec));
-    return rcpp_result_gen;
-END_RCPP
-}
-// printComb
-void printComb(int N);
-RcppExport SEXP _SAIGE_printComb(SEXP NSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type N(NSEXP);
-    printComb(N);
-    return R_NilValue;
-END_RCPP
-}
-// findIndiceRelatedSample
-void findIndiceRelatedSample();
-RcppExport SEXP _SAIGE_findIndiceRelatedSample() {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    findIndiceRelatedSample();
-    return R_NilValue;
-END_RCPP
-}
-// parallelcalsparseGRM
-void parallelcalsparseGRM(arma::fvec& GRMvec);
-RcppExport SEXP _SAIGE_parallelcalsparseGRM(SEXP GRMvecSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type GRMvec(GRMvecSEXP);
-    parallelcalsparseGRM(GRMvec);
-    return R_NilValue;
-END_RCPP
-}
-// parallelsumTwoVec
-void parallelsumTwoVec(arma::fvec& x);
-RcppExport SEXP _SAIGE_parallelsumTwoVec(SEXP xSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type x(xSEXP);
-    parallelsumTwoVec(x);
-    return R_NilValue;
-END_RCPP
-}
-// setgeno
-void setgeno(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int>& subSampleInGeno, std::vector<bool>& indicatorGenoSamplesWithPheno, float memoryChunk, bool isDiagofKinSetAsOne);
-RcppExport SEXP _SAIGE_setgeno(SEXP bedfileSEXP, SEXP bimfileSEXP, SEXP famfileSEXP, SEXP subSampleInGenoSEXP, SEXP indicatorGenoSamplesWithPhenoSEXP, SEXP memoryChunkSEXP, SEXP isDiagofKinSetAsOneSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type bedfile(bedfileSEXP);
-    Rcpp::traits::input_parameter< std::string >::type bimfile(bimfileSEXP);
-    Rcpp::traits::input_parameter< std::string >::type famfile(famfileSEXP);
-    Rcpp::traits::input_parameter< std::vector<int>& >::type subSampleInGeno(subSampleInGenoSEXP);
-    Rcpp::traits::input_parameter< std::vector<bool>& >::type indicatorGenoSamplesWithPheno(indicatorGenoSamplesWithPhenoSEXP);
-    Rcpp::traits::input_parameter< float >::type memoryChunk(memoryChunkSEXP);
-    Rcpp::traits::input_parameter< bool >::type isDiagofKinSetAsOne(isDiagofKinSetAsOneSEXP);
-    setgeno(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne);
-    return R_NilValue;
-END_RCPP
-}
-// Get_OneSNP_Geno
-arma::ivec Get_OneSNP_Geno(int SNPIdx);
-RcppExport SEXP _SAIGE_Get_OneSNP_Geno(SEXP SNPIdxSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type SNPIdx(SNPIdxSEXP);
-    rcpp_result_gen = Rcpp::wrap(Get_OneSNP_Geno(SNPIdx));
+    rcpp_result_gen = Rcpp::wrap(parallelCrossProd_usingSubMarker(bVec));
     return rcpp_result_gen;
 END_RCPP
 }
-// Get_OneSNP_Geno_forVarRatio
-arma::ivec Get_OneSNP_Geno_forVarRatio(int SNPIdx);
-RcppExport SEXP _SAIGE_Get_OneSNP_Geno_forVarRatio(SEXP SNPIdxSEXP) {
+// getCrossprodMatAndKin_usingSubMarker
+arma::fvec getCrossprodMatAndKin_usingSubMarker(arma::fcolvec& bVec);
+RcppExport SEXP _SAIGE_getCrossprodMatAndKin_usingSubMarker(SEXP bVecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type SNPIdx(SNPIdxSEXP);
-    rcpp_result_gen = Rcpp::wrap(Get_OneSNP_Geno_forVarRatio(SNPIdx));
+    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
+    rcpp_result_gen = Rcpp::wrap(getCrossprodMatAndKin_usingSubMarker(bVec));
     return rcpp_result_gen;
 END_RCPP
 }
-// Get_OneSNP_StdGeno
-arma::fvec Get_OneSNP_StdGeno(int SNPIdx);
-RcppExport SEXP _SAIGE_Get_OneSNP_StdGeno(SEXP SNPIdxSEXP) {
+// parallelInnerProduct
+float parallelInnerProduct(std::vector<float>& x, std::vector<float>& y);
+RcppExport SEXP _SAIGE_parallelInnerProduct(SEXP xSEXP, SEXP ySEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type SNPIdx(SNPIdxSEXP);
-    rcpp_result_gen = Rcpp::wrap(Get_OneSNP_StdGeno(SNPIdx));
+    Rcpp::traits::input_parameter< std::vector<float>& >::type x(xSEXP);
+    Rcpp::traits::input_parameter< std::vector<float>& >::type y(ySEXP);
+    rcpp_result_gen = Rcpp::wrap(parallelInnerProduct(x, y));
     return rcpp_result_gen;
 END_RCPP
 }
-// getDiagOfSigma_multiV
-arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
-RcppExport SEXP _SAIGE_getDiagOfSigma_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP LOCOSEXP) {
+// createSparseKin
+Rcpp::List createSparseKin(arma::fvec& markerIndexVec, float relatednessCutoff, arma::fvec& wVec, arma::fvec& tauVec);
+RcppExport SEXP _SAIGE_createSparseKin(SEXP markerIndexVecSEXP, SEXP relatednessCutoffSEXP, SEXP wVecSEXP, SEXP tauVecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::fvec& >::type markerIndexVec(markerIndexVecSEXP);
+    Rcpp::traits::input_parameter< float >::type relatednessCutoff(relatednessCutoffSEXP);
     Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
     Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getDiagOfSigma_multiV(wVec, tauVec, LOCO));
+    rcpp_result_gen = Rcpp::wrap(createSparseKin(markerIndexVec, relatednessCutoff, wVec, tauVec));
     return rcpp_result_gen;
 END_RCPP
 }
-// getCrossprod_multiV
-arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
-RcppExport SEXP _SAIGE_getCrossprod_multiV(SEXP bVecSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP LOCOSEXP) {
+// refineKin
+Rcpp::List refineKin(float relatednessCutoff);
+RcppExport SEXP _SAIGE_refineKin(SEXP relatednessCutoffSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getCrossprod_multiV(bVec, wVec, tauVec, LOCO));
+    Rcpp::traits::input_parameter< float >::type relatednessCutoff(relatednessCutoffSEXP);
+    rcpp_result_gen = Rcpp::wrap(refineKin(relatednessCutoff));
     return rcpp_result_gen;
 END_RCPP
 }
-// gen_sp_GRM
-arma::sp_mat gen_sp_GRM();
-RcppExport SEXP _SAIGE_gen_sp_GRM() {
+// getColfromStdGenoMultiMarkersMat
+arma::fmat getColfromStdGenoMultiMarkersMat(arma::uvec& a);
+RcppExport SEXP _SAIGE_getColfromStdGenoMultiMarkersMat(SEXP aSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(gen_sp_GRM());
+    Rcpp::traits::input_parameter< arma::uvec& >::type a(aSEXP);
+    rcpp_result_gen = Rcpp::wrap(getColfromStdGenoMultiMarkersMat(a));
     return rcpp_result_gen;
 END_RCPP
 }
-// gen_sp_Sigma_multiV
-arma::sp_mat gen_sp_Sigma_multiV(arma::fvec& wVec, arma::fvec& tauVec);
-RcppExport SEXP _SAIGE_gen_sp_Sigma_multiV(SEXP wVecSEXP, SEXP tauVecSEXP) {
+// getNColStdGenoMultiMarkersMat
+int getNColStdGenoMultiMarkersMat();
+RcppExport SEXP _SAIGE_getNColStdGenoMultiMarkersMat() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(gen_sp_Sigma_multiV(wVec, tauVec));
+    rcpp_result_gen = Rcpp::wrap(getNColStdGenoMultiMarkersMat());
     return rcpp_result_gen;
 END_RCPP
 }
-// gen_spsolve_v4_multiV
-arma::fvec gen_spsolve_v4_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& yvec);
-RcppExport SEXP _SAIGE_gen_spsolve_v4_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP yvecSEXP) {
+// getNRowStdGenoMultiMarkersMat
+int getNRowStdGenoMultiMarkersMat();
+RcppExport SEXP _SAIGE_getNRowStdGenoMultiMarkersMat() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type yvec(yvecSEXP);
-    rcpp_result_gen = Rcpp::wrap(gen_spsolve_v4_multiV(wVec, tauVec, yvec));
+    rcpp_result_gen = Rcpp::wrap(getNRowStdGenoMultiMarkersMat());
     return rcpp_result_gen;
 END_RCPP
 }
-// setisUsePrecondM
-void setisUsePrecondM(bool isUseSparseSigmaforPCG);
-RcppExport SEXP _SAIGE_setisUsePrecondM(SEXP isUseSparseSigmaforPCGSEXP) {
+// setSubMarkerIndex
+void setSubMarkerIndex(arma::ivec& subMarkerIndexRandom);
+RcppExport SEXP _SAIGE_setSubMarkerIndex(SEXP subMarkerIndexRandomSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< bool >::type isUseSparseSigmaforPCG(isUseSparseSigmaforPCGSEXP);
-    setisUsePrecondM(isUseSparseSigmaforPCG);
+    Rcpp::traits::input_parameter< arma::ivec& >::type subMarkerIndexRandom(subMarkerIndexRandomSEXP);
+    setSubMarkerIndex(subMarkerIndexRandom);
     return R_NilValue;
 END_RCPP
 }
-// setisUseSparseSigmaforInitTau
-void setisUseSparseSigmaforInitTau(bool isUseSparseSigmaforInitTau0);
-RcppExport SEXP _SAIGE_setisUseSparseSigmaforInitTau(SEXP isUseSparseSigmaforInitTau0SEXP) {
+// setRelatednessCutoff
+void setRelatednessCutoff(float a);
+RcppExport SEXP _SAIGE_setRelatednessCutoff(SEXP aSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< bool >::type isUseSparseSigmaforInitTau0(isUseSparseSigmaforInitTau0SEXP);
-    setisUseSparseSigmaforInitTau(isUseSparseSigmaforInitTau0);
+    Rcpp::traits::input_parameter< float >::type a(aSEXP);
+    setRelatednessCutoff(a);
     return R_NilValue;
 END_RCPP
 }
-// setisUseSparseSigmaforNullModelFitting
-void setisUseSparseSigmaforNullModelFitting(bool isUseSparseSigmaforModelFitting0);
-RcppExport SEXP _SAIGE_setisUseSparseSigmaforNullModelFitting(SEXP isUseSparseSigmaforModelFitting0SEXP) {
+// innerProduct
+double innerProduct(Rcpp::NumericVector x, Rcpp::NumericVector y);
+RcppExport SEXP _SAIGE_innerProduct(SEXP xSEXP, SEXP ySEXP) {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< bool >::type isUseSparseSigmaforModelFitting0(isUseSparseSigmaforModelFitting0SEXP);
-    setisUseSparseSigmaforNullModelFitting(isUseSparseSigmaforModelFitting0);
-    return R_NilValue;
+    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type x(xSEXP);
+    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type y(ySEXP);
+    rcpp_result_gen = Rcpp::wrap(innerProduct(x, y));
+    return rcpp_result_gen;
 END_RCPP
 }
-// getPCG1ofSigmaAndVector_multiV
-arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO);
-RcppExport SEXP _SAIGE_getPCG1ofSigmaAndVector_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP bVecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
+// getDiagOfSigma_noV
+arma::fvec getDiagOfSigma_noV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+RcppExport SEXP _SAIGE_getDiagOfSigma_noV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
     Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type bVec(bVecSEXP);
-    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
     Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getPCG1ofSigmaAndVector_multiV(wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO));
+    rcpp_result_gen = Rcpp::wrap(getDiagOfSigma_noV(wVec, tauVec, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// set_seed
-void set_seed(unsigned int seed);
-RcppExport SEXP _SAIGE_set_seed(SEXP seedSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< unsigned int >::type seed(seedSEXP);
-    set_seed(seed);
-    return R_NilValue;
-END_RCPP
-}
-// nb
-Rcpp::NumericVector nb(int n);
-RcppExport SEXP _SAIGE_nb(SEXP nSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type n(nSEXP);
-    rcpp_result_gen = Rcpp::wrap(nb(n));
-    return rcpp_result_gen;
-END_RCPP
-}
-// setStartEndIndex
-void setStartEndIndex(int startIndex, int endIndex, int chromIndex);
-RcppExport SEXP _SAIGE_setStartEndIndex(SEXP startIndexSEXP, SEXP endIndexSEXP, SEXP chromIndexSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type startIndex(startIndexSEXP);
-    Rcpp::traits::input_parameter< int >::type endIndex(endIndexSEXP);
-    Rcpp::traits::input_parameter< int >::type chromIndex(chromIndexSEXP);
-    setStartEndIndex(startIndex, endIndex, chromIndex);
-    return R_NilValue;
-END_RCPP
-}
-// setStartEndIndexVec
-void setStartEndIndexVec(arma::ivec& startIndex_vec, arma::ivec& endIndex_vec);
-RcppExport SEXP _SAIGE_setStartEndIndexVec(SEXP startIndex_vecSEXP, SEXP endIndex_vecSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::ivec& >::type startIndex_vec(startIndex_vecSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type endIndex_vec(endIndex_vecSEXP);
-    setStartEndIndexVec(startIndex_vec, endIndex_vec);
-    return R_NilValue;
-END_RCPP
-}
-// calCV
-float calCV(arma::fvec& xVec);
-RcppExport SEXP _SAIGE_calCV(SEXP xVecSEXP) {
+// getCrossprod_noV
+arma::fcolvec getCrossprod_noV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO);
+RcppExport SEXP _SAIGE_getCrossprod_noV(SEXP bVecSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type xVec(xVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(calCV(xVec));
+    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
+    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
+    rcpp_result_gen = Rcpp::wrap(getCrossprod_noV(bVec, wVec, tauVec, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getSigma_X_multiV
-arma::fmat getSigma_X_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fmat& Xmat, int maxiterPCG, float tolPCG, bool LOCO);
-RcppExport SEXP _SAIGE_getSigma_X_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP XmatSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
+// getPCG1ofSigmaAndVector_noV
+arma::fvec getPCG1ofSigmaAndVector_noV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO);
+RcppExport SEXP _SAIGE_getPCG1ofSigmaAndVector_noV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP bVecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
     Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
+    Rcpp::traits::input_parameter< arma::fvec& >::type bVec(bVecSEXP);
     Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
     Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
     Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getSigma_X_multiV(wVec, tauVec, Xmat, maxiterPCG, tolPCG, LOCO));
+    rcpp_result_gen = Rcpp::wrap(getPCG1ofSigmaAndVector_noV(wVec, tauVec, bVec, maxiterPCG, tolPCG, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// getSigma_G_multiV
-arma::fvec getSigma_G_multiV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO);
-RcppExport SEXP _SAIGE_getSigma_G_multiV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP GvecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
+// getSigma_G_noV
+arma::fvec getSigma_G_noV(arma::fvec& wVec, arma::fvec& tauVec, arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO);
+RcppExport SEXP _SAIGE_getSigma_G_noV(SEXP wVecSEXP, SEXP tauVecSEXP, SEXP GvecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
@@ -1042,442 +969,359 @@ BEGIN_RCPP
     Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
     Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
     Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getSigma_G_multiV(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO));
+    rcpp_result_gen = Rcpp::wrap(getSigma_G_noV(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO));
     return rcpp_result_gen;
 END_RCPP
 }
-// parallelCrossProd_usingSubMarker
-arma::fvec parallelCrossProd_usingSubMarker(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_parallelCrossProd_usingSubMarker(SEXP bVecSEXP) {
+// set_useGRMtoFitNULL
+void set_useGRMtoFitNULL(bool useGRMtoFitNULL);
+RcppExport SEXP _SAIGE_set_useGRMtoFitNULL(SEXP useGRMtoFitNULLSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(parallelCrossProd_usingSubMarker(bVec));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< bool >::type useGRMtoFitNULL(useGRMtoFitNULLSEXP);
+    set_useGRMtoFitNULL(useGRMtoFitNULL);
+    return R_NilValue;
 END_RCPP
 }
-// getCrossprodMatAndKin_usingSubMarker
-arma::fvec getCrossprodMatAndKin_usingSubMarker(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_getCrossprodMatAndKin_usingSubMarker(SEXP bVecSEXP) {
+// set_isSparseGRM
+void set_isSparseGRM(bool t_isSparseGRM);
+RcppExport SEXP _SAIGE_set_isSparseGRM(SEXP t_isSparseGRMSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(getCrossprodMatAndKin_usingSubMarker(bVec));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< bool >::type t_isSparseGRM(t_isSparseGRMSEXP);
+    set_isSparseGRM(t_isSparseGRM);
+    return R_NilValue;
 END_RCPP
 }
-// parallelInnerProduct
-float parallelInnerProduct(std::vector<float>& x, std::vector<float>& y);
-RcppExport SEXP _SAIGE_parallelInnerProduct(SEXP xSEXP, SEXP ySEXP) {
+// set_store_sigma
+void set_store_sigma(bool isstoreSigma);
+RcppExport SEXP _SAIGE_set_store_sigma(SEXP isstoreSigmaSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::vector<float>& >::type x(xSEXP);
-    Rcpp::traits::input_parameter< std::vector<float>& >::type y(ySEXP);
-    rcpp_result_gen = Rcpp::wrap(parallelInnerProduct(x, y));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< bool >::type isstoreSigma(isstoreSigmaSEXP);
+    set_store_sigma(isstoreSigma);
+    return R_NilValue;
 END_RCPP
 }
-// calGRMValueforSamplePair
-float calGRMValueforSamplePair(arma::ivec& sampleidsVec);
-RcppExport SEXP _SAIGE_calGRMValueforSamplePair(SEXP sampleidsVecSEXP) {
+// set_num_Kmat
+void set_num_Kmat(int t_num_Kmat);
+RcppExport SEXP _SAIGE_set_num_Kmat(SEXP t_num_KmatSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::ivec& >::type sampleidsVec(sampleidsVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(calGRMValueforSamplePair(sampleidsVec));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< int >::type t_num_Kmat(t_num_KmatSEXP);
+    set_num_Kmat(t_num_Kmat);
+    return R_NilValue;
 END_RCPP
 }
-// createSparseKin
-Rcpp::List createSparseKin(arma::fvec& markerIndexVec, float relatednessCutoff, arma::fvec& wVec, arma::fvec& tauVec);
-RcppExport SEXP _SAIGE_createSparseKin(SEXP markerIndexVecSEXP, SEXP relatednessCutoffSEXP, SEXP wVecSEXP, SEXP tauVecSEXP) {
+// get_numofV
+int get_numofV();
+RcppExport SEXP _SAIGE_get_numofV() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type markerIndexVec(markerIndexVecSEXP);
-    Rcpp::traits::input_parameter< float >::type relatednessCutoff(relatednessCutoffSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(createSparseKin(markerIndexVec, relatednessCutoff, wVec, tauVec));
+    rcpp_result_gen = Rcpp::wrap(get_numofV());
     return rcpp_result_gen;
 END_RCPP
 }
-// getColfromStdGenoMultiMarkersMat
-arma::fmat getColfromStdGenoMultiMarkersMat(arma::uvec& a);
-RcppExport SEXP _SAIGE_getColfromStdGenoMultiMarkersMat(SEXP aSEXP) {
+// set_covarianceidx_Mat
+arma::umat set_covarianceidx_Mat();
+RcppExport SEXP _SAIGE_set_covarianceidx_Mat() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::uvec& >::type a(aSEXP);
-    rcpp_result_gen = Rcpp::wrap(getColfromStdGenoMultiMarkersMat(a));
+    rcpp_result_gen = Rcpp::wrap(set_covarianceidx_Mat());
     return rcpp_result_gen;
 END_RCPP
 }
-// getNColStdGenoMultiMarkersMat
-int getNColStdGenoMultiMarkersMat();
-RcppExport SEXP _SAIGE_getNColStdGenoMultiMarkersMat() {
+// closeGenoFile_plink
+void closeGenoFile_plink();
+RcppExport SEXP _SAIGE_closeGenoFile_plink() {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getNColStdGenoMultiMarkersMat());
-    return rcpp_result_gen;
+    closeGenoFile_plink();
+    return R_NilValue;
 END_RCPP
 }
-// getNRowStdGenoMultiMarkersMat
-int getNRowStdGenoMultiMarkersMat();
-RcppExport SEXP _SAIGE_getNRowStdGenoMultiMarkersMat() {
+// gettotalMarker
+int gettotalMarker();
+RcppExport SEXP _SAIGE_gettotalMarker() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(getNRowStdGenoMultiMarkersMat());
+    rcpp_result_gen = Rcpp::wrap(gettotalMarker());
     return rcpp_result_gen;
 END_RCPP
 }
-// setSubMarkerIndex
-void setSubMarkerIndex(arma::ivec& subMarkerIndexRandom);
-RcppExport SEXP _SAIGE_setSubMarkerIndex(SEXP subMarkerIndexRandomSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::ivec& >::type subMarkerIndexRandom(subMarkerIndexRandomSEXP);
-    setSubMarkerIndex(subMarkerIndexRandom);
-    return R_NilValue;
-END_RCPP
-}
-// setRelatednessCutoff
-void setRelatednessCutoff(float a);
-RcppExport SEXP _SAIGE_setRelatednessCutoff(SEXP aSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< float >::type a(aSEXP);
-    setRelatednessCutoff(a);
-    return R_NilValue;
-END_RCPP
-}
-// innerProduct
-double innerProduct(NumericVector x, NumericVector y);
-RcppExport SEXP _SAIGE_innerProduct(SEXP xSEXP, SEXP ySEXP) {
+// getAlleleFreqVec
+arma::fvec getAlleleFreqVec();
+RcppExport SEXP _SAIGE_getAlleleFreqVec() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
-    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
-    rcpp_result_gen = Rcpp::wrap(innerProduct(x, y));
+    rcpp_result_gen = Rcpp::wrap(getAlleleFreqVec());
     return rcpp_result_gen;
 END_RCPP
 }
-// refineKin
-Rcpp::List refineKin(float relatednessCutoff);
-RcppExport SEXP _SAIGE_refineKin(SEXP relatednessCutoffSEXP) {
+// getMACVec
+arma::ivec getMACVec();
+RcppExport SEXP _SAIGE_getMACVec() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< float >::type relatednessCutoff(relatednessCutoffSEXP);
-    rcpp_result_gen = Rcpp::wrap(refineKin(relatednessCutoff));
+    rcpp_result_gen = Rcpp::wrap(getMACVec());
     return rcpp_result_gen;
 END_RCPP
 }
-// shortenList
-Rcpp::List shortenList(arma::imat& iMat, arma::fvec& kinValueVecTemp, float relatednessCutoff, arma::fvec& wVec, arma::fvec& tauVec);
-RcppExport SEXP _SAIGE_shortenList(SEXP iMatSEXP, SEXP kinValueVecTempSEXP, SEXP relatednessCutoffSEXP, SEXP wVecSEXP, SEXP tauVecSEXP) {
+// getMACVec_forVarRatio
+arma::ivec getMACVec_forVarRatio();
+RcppExport SEXP _SAIGE_getMACVec_forVarRatio() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::imat& >::type iMat(iMatSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type kinValueVecTemp(kinValueVecTempSEXP);
-    Rcpp::traits::input_parameter< float >::type relatednessCutoff(relatednessCutoffSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(shortenList(iMat, kinValueVecTemp, relatednessCutoff, wVec, tauVec));
+    rcpp_result_gen = Rcpp::wrap(getMACVec_forVarRatio());
     return rcpp_result_gen;
 END_RCPP
 }
-// testTime
-arma::fvec testTime(int i, arma::fcolvec& m_bVec);
-RcppExport SEXP _SAIGE_testTime(SEXP iSEXP, SEXP m_bVecSEXP) {
+// getIndexVec_forVarRatio
+arma::ivec getIndexVec_forVarRatio();
+RcppExport SEXP _SAIGE_getIndexVec_forVarRatio() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type i(iSEXP);
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type m_bVec(m_bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(testTime(i, m_bVec));
+    rcpp_result_gen = Rcpp::wrap(getIndexVec_forVarRatio());
     return rcpp_result_gen;
 END_RCPP
 }
-// gen_sp_v2
-arma::sp_mat gen_sp_v2(const arma::sp_mat& a);
-RcppExport SEXP _SAIGE_gen_sp_v2(SEXP aSEXP) {
+// getIsVarRatioGeno
+bool getIsVarRatioGeno();
+RcppExport SEXP _SAIGE_getIsVarRatioGeno() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::sp_mat& >::type a(aSEXP);
-    rcpp_result_gen = Rcpp::wrap(gen_sp_v2(a));
+    rcpp_result_gen = Rcpp::wrap(getIsVarRatioGeno());
     return rcpp_result_gen;
 END_RCPP
 }
-// gen_spsolve_v2
-arma::vec gen_spsolve_v2(const arma::sp_mat& a);
-RcppExport SEXP _SAIGE_gen_spsolve_v2(SEXP aSEXP) {
+// getSubMarkerIndex
+arma::ivec getSubMarkerIndex();
+RcppExport SEXP _SAIGE_getSubMarkerIndex() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::sp_mat& >::type a(aSEXP);
-    rcpp_result_gen = Rcpp::wrap(gen_spsolve_v2(a));
+    rcpp_result_gen = Rcpp::wrap(getSubMarkerIndex());
     return rcpp_result_gen;
 END_RCPP
 }
-// gen_spsolve_inR
-arma::vec gen_spsolve_inR(const arma::sp_mat& a, arma::vec& y);
-RcppExport SEXP _SAIGE_gen_spsolve_inR(SEXP aSEXP, SEXP ySEXP) {
+// getQCdMarkerIndex
+std::vector<bool> getQCdMarkerIndex();
+RcppExport SEXP _SAIGE_getQCdMarkerIndex() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::sp_mat& >::type a(aSEXP);
-    Rcpp::traits::input_parameter< arma::vec& >::type y(ySEXP);
-    rcpp_result_gen = Rcpp::wrap(gen_spsolve_inR(a, y));
+    rcpp_result_gen = Rcpp::wrap(getQCdMarkerIndex());
     return rcpp_result_gen;
 END_RCPP
 }
-// get_DiagofKin
-arma::fvec get_DiagofKin();
-RcppExport SEXP _SAIGE_get_DiagofKin() {
+// getSubMarkerNum
+int getSubMarkerNum();
+RcppExport SEXP _SAIGE_getSubMarkerNum() {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(get_DiagofKin());
+    rcpp_result_gen = Rcpp::wrap(getSubMarkerNum());
     return rcpp_result_gen;
 END_RCPP
 }
-// getstdgenoVectorScalorProduct
-void getstdgenoVectorScalorProduct(int jth, float y, arma::fvec& prodVec);
-RcppExport SEXP _SAIGE_getstdgenoVectorScalorProduct(SEXP jthSEXP, SEXP ySEXP, SEXP prodVecSEXP) {
+// getNnomissingOut
+int getNnomissingOut();
+RcppExport SEXP _SAIGE_getNnomissingOut() {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< int >::type jth(jthSEXP);
-    Rcpp::traits::input_parameter< float >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type prodVec(prodVecSEXP);
-    getstdgenoVectorScalorProduct(jth, y, prodVec);
-    return R_NilValue;
+    rcpp_result_gen = Rcpp::wrap(getNnomissingOut());
+    return rcpp_result_gen;
 END_RCPP
 }
-// sumPz
-void sumPz(arma::fvec& Pbvec, arma::fvec& Ubvec, unsigned int mmchunksize);
-RcppExport SEXP _SAIGE_sumPz(SEXP PbvecSEXP, SEXP UbvecSEXP, SEXP mmchunksizeSEXP) {
+// getMsub_MAFge_minMAFtoConstructGRM
+int getMsub_MAFge_minMAFtoConstructGRM();
+RcppExport SEXP _SAIGE_getMsub_MAFge_minMAFtoConstructGRM() {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type Pbvec(PbvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type Ubvec(UbvecSEXP);
-    Rcpp::traits::input_parameter< unsigned int >::type mmchunksize(mmchunksizeSEXP);
-    sumPz(Pbvec, Ubvec, mmchunksize);
-    return R_NilValue;
+    rcpp_result_gen = Rcpp::wrap(getMsub_MAFge_minMAFtoConstructGRM());
+    return rcpp_result_gen;
 END_RCPP
 }
-// mmGetPb_MbyN
-void mmGetPb_MbyN(unsigned int cthchunk, unsigned int mmchunksize, arma::fvec& bvec, arma::fvec& Pbvec, arma::fvec& kinbvec);
-RcppExport SEXP _SAIGE_mmGetPb_MbyN(SEXP cthchunkSEXP, SEXP mmchunksizeSEXP, SEXP bvecSEXP, SEXP PbvecSEXP, SEXP kinbvecSEXP) {
+// getMsub_MAFge_minMAFtoConstructGRM_singleChr
+int getMsub_MAFge_minMAFtoConstructGRM_singleChr();
+RcppExport SEXP _SAIGE_getMsub_MAFge_minMAFtoConstructGRM_singleChr() {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< unsigned int >::type cthchunk(cthchunkSEXP);
-    Rcpp::traits::input_parameter< unsigned int >::type mmchunksize(mmchunksizeSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type bvec(bvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type Pbvec(PbvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type kinbvec(kinbvecSEXP);
-    mmGetPb_MbyN(cthchunk, mmchunksize, bvec, Pbvec, kinbvec);
-    return R_NilValue;
+    rcpp_result_gen = Rcpp::wrap(getMsub_MAFge_minMAFtoConstructGRM_singleChr());
+    return rcpp_result_gen;
 END_RCPP
 }
-// mmGetPb_NbyM
-void mmGetPb_NbyM(unsigned int cthchunk, unsigned int mmchunksize, arma::fvec& bvec, arma::fvec& Pbvec);
-RcppExport SEXP _SAIGE_mmGetPb_NbyM(SEXP cthchunkSEXP, SEXP mmchunksizeSEXP, SEXP bvecSEXP, SEXP PbvecSEXP) {
+// Get_MultiMarkersBySample_StdGeno_Mat
+void Get_MultiMarkersBySample_StdGeno_Mat();
+RcppExport SEXP _SAIGE_Get_MultiMarkersBySample_StdGeno_Mat() {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< unsigned int >::type cthchunk(cthchunkSEXP);
-    Rcpp::traits::input_parameter< unsigned int >::type mmchunksize(mmchunksizeSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type bvec(bvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type Pbvec(PbvecSEXP);
-    mmGetPb_NbyM(cthchunk, mmchunksize, bvec, Pbvec);
+    Get_MultiMarkersBySample_StdGeno_Mat();
     return R_NilValue;
 END_RCPP
 }
-// muliplyMailman
-void muliplyMailman(arma::fvec& bvec, arma::fvec& Gbvec, arma::fvec& kinbvec);
-RcppExport SEXP _SAIGE_muliplyMailman(SEXP bvecSEXP, SEXP GbvecSEXP, SEXP kinbvecSEXP) {
+// Get_MultiMarkersBySample_StdGeno
+void Get_MultiMarkersBySample_StdGeno(arma::fvec& markerIndexVec, std::vector<float>& stdGenoMultiMarkers);
+RcppExport SEXP _SAIGE_Get_MultiMarkersBySample_StdGeno(SEXP markerIndexVecSEXP, SEXP stdGenoMultiMarkersSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type bvec(bvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type Gbvec(GbvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type kinbvec(kinbvecSEXP);
-    muliplyMailman(bvec, Gbvec, kinbvec);
+    Rcpp::traits::input_parameter< arma::fvec& >::type markerIndexVec(markerIndexVecSEXP);
+    Rcpp::traits::input_parameter< std::vector<float>& >::type stdGenoMultiMarkers(stdGenoMultiMarkersSEXP);
+    Get_MultiMarkersBySample_StdGeno(markerIndexVec, stdGenoMultiMarkers);
     return R_NilValue;
 END_RCPP
 }
-// muliplyMailman_NbyM
-void muliplyMailman_NbyM(arma::fvec& bvec, arma::fvec& tGbvec);
-RcppExport SEXP _SAIGE_muliplyMailman_NbyM(SEXP bvecSEXP, SEXP tGbvecSEXP) {
+// parallelCrossProd
+arma::fvec parallelCrossProd(arma::fcolvec& bVec);
+RcppExport SEXP _SAIGE_parallelCrossProd(SEXP bVecSEXP) {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type bvec(bvecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tGbvec(tGbvecSEXP);
-    muliplyMailman_NbyM(bvec, tGbvec);
-    return R_NilValue;
+    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
+    rcpp_result_gen = Rcpp::wrap(parallelCrossProd(bVec));
+    return rcpp_result_gen;
 END_RCPP
 }
-// freqOverStd
-void freqOverStd(arma::fcolvec& freqOverStdVec);
-RcppExport SEXP _SAIGE_freqOverStd(SEXP freqOverStdVecSEXP) {
+// innerProductFun
+float innerProductFun(std::vector<float>& x, std::vector<float>& y);
+RcppExport SEXP _SAIGE_innerProductFun(SEXP xSEXP, SEXP ySEXP) {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fcolvec& >::type freqOverStdVec(freqOverStdVecSEXP);
-    freqOverStd(freqOverStdVec);
-    return R_NilValue;
+    Rcpp::traits::input_parameter< std::vector<float>& >::type x(xSEXP);
+    Rcpp::traits::input_parameter< std::vector<float>& >::type y(ySEXP);
+    rcpp_result_gen = Rcpp::wrap(innerProductFun(x, y));
+    return rcpp_result_gen;
 END_RCPP
 }
-// getCrossprodMatAndKin_mailman
-arma::fvec getCrossprodMatAndKin_mailman(arma::fcolvec& bVec);
-RcppExport SEXP _SAIGE_getCrossprodMatAndKin_mailman(SEXP bVecSEXP) {
+// parallelCrossProd_full
+arma::fvec parallelCrossProd_full(arma::fcolvec& bVec, int& markerNum);
+RcppExport SEXP _SAIGE_parallelCrossProd_full(SEXP bVecSEXP, SEXP markerNumSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
-    rcpp_result_gen = Rcpp::wrap(getCrossprodMatAndKin_mailman(bVec));
+    Rcpp::traits::input_parameter< int& >::type markerNum(markerNumSEXP);
+    rcpp_result_gen = Rcpp::wrap(parallelCrossProd_full(bVec, markerNum));
     return rcpp_result_gen;
 END_RCPP
 }
-// get_GRMdiagVec
-arma::fvec get_GRMdiagVec();
-RcppExport SEXP _SAIGE_get_GRMdiagVec() {
+// parallelCrossProd_LOCO
+arma::fvec parallelCrossProd_LOCO(arma::fcolvec& bVec);
+RcppExport SEXP _SAIGE_parallelCrossProd_LOCO(SEXP bVecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(get_GRMdiagVec());
+    Rcpp::traits::input_parameter< arma::fcolvec& >::type bVec(bVecSEXP);
+    rcpp_result_gen = Rcpp::wrap(parallelCrossProd_LOCO(bVec));
     return rcpp_result_gen;
 END_RCPP
 }
-// setminMAFforGRM
-void setminMAFforGRM(float minMAFforGRM);
-RcppExport SEXP _SAIGE_setminMAFforGRM(SEXP minMAFforGRMSEXP) {
+// printComb
+void printComb(int N);
+RcppExport SEXP _SAIGE_printComb(SEXP NSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< float >::type minMAFforGRM(minMAFforGRMSEXP);
-    setminMAFforGRM(minMAFforGRM);
+    Rcpp::traits::input_parameter< int >::type N(NSEXP);
+    printComb(N);
     return R_NilValue;
 END_RCPP
 }
-// setmaxMissingRateforGRM
-void setmaxMissingRateforGRM(float maxMissingforGRM);
-RcppExport SEXP _SAIGE_setmaxMissingRateforGRM(SEXP maxMissingforGRMSEXP) {
+// findIndiceRelatedSample
+void findIndiceRelatedSample();
+RcppExport SEXP _SAIGE_findIndiceRelatedSample() {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< float >::type maxMissingforGRM(maxMissingforGRMSEXP);
-    setmaxMissingRateforGRM(maxMissingforGRM);
+    findIndiceRelatedSample();
     return R_NilValue;
 END_RCPP
 }
-// set_Diagof_StdGeno_LOCO
-void set_Diagof_StdGeno_LOCO();
-RcppExport SEXP _SAIGE_set_Diagof_StdGeno_LOCO() {
+// parallelcalsparseGRM
+void parallelcalsparseGRM(arma::fvec& GRMvec);
+RcppExport SEXP _SAIGE_parallelcalsparseGRM(SEXP GRMvecSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    set_Diagof_StdGeno_LOCO();
+    Rcpp::traits::input_parameter< arma::fvec& >::type GRMvec(GRMvecSEXP);
+    parallelcalsparseGRM(GRMvec);
     return R_NilValue;
 END_RCPP
 }
-// setminMAC_VarianceRatio
-void setminMAC_VarianceRatio(float t_minMACVarRatio, float t_maxMACVarRatio, bool t_isVarianceRatioinGeno);
-RcppExport SEXP _SAIGE_setminMAC_VarianceRatio(SEXP t_minMACVarRatioSEXP, SEXP t_maxMACVarRatioSEXP, SEXP t_isVarianceRatioinGenoSEXP) {
+// parallelsumTwoVec
+void parallelsumTwoVec(arma::fvec& x);
+RcppExport SEXP _SAIGE_parallelsumTwoVec(SEXP xSEXP) {
 BEGIN_RCPP
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< float >::type t_minMACVarRatio(t_minMACVarRatioSEXP);
-    Rcpp::traits::input_parameter< float >::type t_maxMACVarRatio(t_maxMACVarRatioSEXP);
-    Rcpp::traits::input_parameter< bool >::type t_isVarianceRatioinGeno(t_isVarianceRatioinGenoSEXP);
-    setminMAC_VarianceRatio(t_minMACVarRatio, t_maxMACVarRatio, t_isVarianceRatioinGeno);
+    Rcpp::traits::input_parameter< arma::fvec& >::type x(xSEXP);
+    parallelsumTwoVec(x);
     return R_NilValue;
 END_RCPP
 }
-// getCoefficients_multiV
-Rcpp::List getCoefficients_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, int maxiterPCG, float tolPCG, bool LOCO);
-RcppExport SEXP _SAIGE_getCoefficients_multiV(SEXP YvecSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP LOCOSEXP) {
+// setgenoNULL
+void setgenoNULL();
+RcppExport SEXP _SAIGE_setgenoNULL() {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type Yvec(YvecSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
-    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getCoefficients_multiV(Yvec, Xmat, wVec, tauVec, maxiterPCG, tolPCG, LOCO));
-    return rcpp_result_gen;
+    setgenoNULL();
+    return R_NilValue;
 END_RCPP
 }
-// GetTrace_multiV
-arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec& fixtauVec, arma::fmat& cov1, int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO);
-RcppExport SEXP _SAIGE_GetTrace_multiV(SEXP Sigma_iXSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP fixtauVecSEXP, SEXP cov1SEXP, SEXP nrunSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP traceCVcutoffSEXP, SEXP LOCOSEXP) {
+// setgeno
+void setgeno(std::string bedfile, std::string bimfile, std::string famfile, std::vector<int>& subSampleInGeno, std::vector<bool>& indicatorGenoSamplesWithPheno, float memoryChunk, bool isDiagofKinSetAsOne);
+RcppExport SEXP _SAIGE_setgeno(SEXP bedfileSEXP, SEXP bimfileSEXP, SEXP famfileSEXP, SEXP subSampleInGenoSEXP, SEXP indicatorGenoSamplesWithPhenoSEXP, SEXP memoryChunkSEXP, SEXP isDiagofKinSetAsOneSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type bedfile(bedfileSEXP);
+    Rcpp::traits::input_parameter< std::string >::type bimfile(bimfileSEXP);
+    Rcpp::traits::input_parameter< std::string >::type famfile(famfileSEXP);
+    Rcpp::traits::input_parameter< std::vector<int>& >::type subSampleInGeno(subSampleInGenoSEXP);
+    Rcpp::traits::input_parameter< std::vector<bool>& >::type indicatorGenoSamplesWithPheno(indicatorGenoSamplesWithPhenoSEXP);
+    Rcpp::traits::input_parameter< float >::type memoryChunk(memoryChunkSEXP);
+    Rcpp::traits::input_parameter< bool >::type isDiagofKinSetAsOne(isDiagofKinSetAsOneSEXP);
+    setgeno(bedfile, bimfile, famfile, subSampleInGeno, indicatorGenoSamplesWithPheno, memoryChunk, isDiagofKinSetAsOne);
+    return R_NilValue;
+END_RCPP
+}
+// Get_OneSNP_Geno
+arma::ivec Get_OneSNP_Geno(int SNPIdx);
+RcppExport SEXP _SAIGE_Get_OneSNP_Geno(SEXP SNPIdxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fmat >::type Sigma_iX(Sigma_iXSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type fixtauVec(fixtauVecSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type cov1(cov1SEXP);
-    Rcpp::traits::input_parameter< int >::type nrun(nrunSEXP);
-    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type traceCVcutoff(traceCVcutoffSEXP);
-    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(GetTrace_multiV(Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO));
+    Rcpp::traits::input_parameter< int >::type SNPIdx(SNPIdxSEXP);
+    rcpp_result_gen = Rcpp::wrap(Get_OneSNP_Geno(SNPIdx));
     return rcpp_result_gen;
 END_RCPP
 }
-// getAIScore_multiV
-Rcpp::List getAIScore_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec& fixtauVec, arma::fvec& Sigma_iY, arma::fmat& Sigma_iX, arma::fmat& cov, int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO);
-RcppExport SEXP _SAIGE_getAIScore_multiV(SEXP YvecSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP fixtauVecSEXP, SEXP Sigma_iYSEXP, SEXP Sigma_iXSEXP, SEXP covSEXP, SEXP nrunSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP traceCVcutoffSEXP, SEXP LOCOSEXP) {
+// Get_OneSNP_Geno_forVarRatio
+arma::ivec Get_OneSNP_Geno_forVarRatio(int SNPIdx);
+RcppExport SEXP _SAIGE_Get_OneSNP_Geno_forVarRatio(SEXP SNPIdxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type Yvec(YvecSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type fixtauVec(fixtauVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type Sigma_iY(Sigma_iYSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Sigma_iX(Sigma_iXSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type cov(covSEXP);
-    Rcpp::traits::input_parameter< int >::type nrun(nrunSEXP);
-    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type traceCVcutoff(traceCVcutoffSEXP);
-    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(getAIScore_multiV(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO));
+    Rcpp::traits::input_parameter< int >::type SNPIdx(SNPIdxSEXP);
+    rcpp_result_gen = Rcpp::wrap(Get_OneSNP_Geno_forVarRatio(SNPIdx));
     return rcpp_result_gen;
 END_RCPP
 }
-// fitglmmaiRPCG_multiV
-Rcpp::List fitglmmaiRPCG_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec& fixtauVec, arma::fvec& Sigma_iY, arma::fmat& Sigma_iX, arma::fmat& cov, int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOCO);
-RcppExport SEXP _SAIGE_fitglmmaiRPCG_multiV(SEXP YvecSEXP, SEXP XmatSEXP, SEXP wVecSEXP, SEXP tauVecSEXP, SEXP fixtauVecSEXP, SEXP Sigma_iYSEXP, SEXP Sigma_iXSEXP, SEXP covSEXP, SEXP nrunSEXP, SEXP maxiterPCGSEXP, SEXP tolPCGSEXP, SEXP tolSEXP, SEXP traceCVcutoffSEXP, SEXP LOCOSEXP) {
+// Get_OneSNP_StdGeno
+arma::fvec Get_OneSNP_StdGeno(int SNPIdx);
+RcppExport SEXP _SAIGE_Get_OneSNP_StdGeno(SEXP SNPIdxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::fvec& >::type Yvec(YvecSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Xmat(XmatSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type wVec(wVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type tauVec(tauVecSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type fixtauVec(fixtauVecSEXP);
-    Rcpp::traits::input_parameter< arma::fvec& >::type Sigma_iY(Sigma_iYSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type Sigma_iX(Sigma_iXSEXP);
-    Rcpp::traits::input_parameter< arma::fmat& >::type cov(covSEXP);
-    Rcpp::traits::input_parameter< int >::type nrun(nrunSEXP);
-    Rcpp::traits::input_parameter< int >::type maxiterPCG(maxiterPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type tolPCG(tolPCGSEXP);
-    Rcpp::traits::input_parameter< float >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< float >::type traceCVcutoff(traceCVcutoffSEXP);
-    Rcpp::traits::input_parameter< bool >::type LOCO(LOCOSEXP);
-    rcpp_result_gen = Rcpp::wrap(fitglmmaiRPCG_multiV(Yvec, Xmat, wVec, tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, tol, traceCVcutoff, LOCO));
+    Rcpp::traits::input_parameter< int >::type SNPIdx(SNPIdxSEXP);
+    rcpp_result_gen = Rcpp::wrap(Get_OneSNP_StdGeno(SNPIdx));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -2035,8 +1879,7 @@ static const R_CallMethodDef CallEntries[] = {
     {"_SAIGE_setPLINKobjInCPP", (DL_FUNC) &_SAIGE_setPLINKobjInCPP, 5},
     {"_SAIGE_setBGENobjInCPP", (DL_FUNC) &_SAIGE_setBGENobjInCPP, 5},
     {"_SAIGE_setVCFobjInCPP", (DL_FUNC) &_SAIGE_setVCFobjInCPP, 4},
-    {"_SAIGE_setSAIGEobjInCPP", (DL_FUNC) &_SAIGE_setSAIGEobjInCPP, 31},
-    {"_SAIGE_setSparseSigmaInCPP", (DL_FUNC) &_SAIGE_setSparseSigmaInCPP, 3},
+    {"_SAIGE_setSAIGEobjInCPP", (DL_FUNC) &_SAIGE_setSAIGEobjInCPP, 29},
     {"_SAIGE_RegionSetUpConditional_binary_InCPP", (DL_FUNC) &_SAIGE_RegionSetUpConditional_binary_InCPP, 1},
     {"_SAIGE_mainRegionInCPP", (DL_FUNC) &_SAIGE_mainRegionInCPP, 20},
     {"_SAIGE_assign_conditionMarkers_factors", (DL_FUNC) &_SAIGE_assign_conditionMarkers_factors, 5},
@@ -2052,13 +1895,54 @@ static const R_CallMethodDef CallEntries[] = {
     {"_SAIGE_set_flagSparseGRM_cur_SAIGE", (DL_FUNC) &_SAIGE_set_flagSparseGRM_cur_SAIGE, 1},
     {"_SAIGE_set_flagSparseGRM_cur_SAIGE_org", (DL_FUNC) &_SAIGE_set_flagSparseGRM_cur_SAIGE_org, 0},
     {"_SAIGE_copy_singleInGroup", (DL_FUNC) &_SAIGE_copy_singleInGroup, 0},
-    {"_SAIGE_addNewKat", (DL_FUNC) &_SAIGE_addNewKat, 1},
-    {"_SAIGE_getProdTauKmat", (DL_FUNC) &_SAIGE_getProdTauKmat, 1},
-    {"_SAIGE_getMeanDiagofKmat", (DL_FUNC) &_SAIGE_getMeanDiagofKmat, 0},
+    {"_SAIGE_set_dup_sample_index", (DL_FUNC) &_SAIGE_set_dup_sample_index, 1},
+    {"_SAIGE_setupSparseGRM_new", (DL_FUNC) &_SAIGE_setupSparseGRM_new, 1},
+    {"_SAIGE_set_I_longl_mat", (DL_FUNC) &_SAIGE_set_I_longl_mat, 2},
+    {"_SAIGE_set_T_longl_mat", (DL_FUNC) &_SAIGE_set_T_longl_mat, 2},
+    {"_SAIGE_getCrossprodMatAndKin", (DL_FUNC) &_SAIGE_getCrossprodMatAndKin, 2},
+    {"_SAIGE_getCrossprod_multiV", (DL_FUNC) &_SAIGE_getCrossprod_multiV, 4},
+    {"_SAIGE_getDiagOfSigma_multiV", (DL_FUNC) &_SAIGE_getDiagOfSigma_multiV, 3},
+    {"_SAIGE_gen_sp_Sigma_multiV", (DL_FUNC) &_SAIGE_gen_sp_Sigma_multiV, 2},
+    {"_SAIGE_getPCG1ofSigmaAndVector_multiV", (DL_FUNC) &_SAIGE_getPCG1ofSigmaAndVector_multiV, 6},
+    {"_SAIGE_set_seed", (DL_FUNC) &_SAIGE_set_seed, 1},
+    {"_SAIGE_nb", (DL_FUNC) &_SAIGE_nb, 1},
+    {"_SAIGE_setStartEndIndex", (DL_FUNC) &_SAIGE_setStartEndIndex, 3},
+    {"_SAIGE_setStartEndIndexVec", (DL_FUNC) &_SAIGE_setStartEndIndexVec, 2},
+    {"_SAIGE_calCV", (DL_FUNC) &_SAIGE_calCV, 1},
+    {"_SAIGE_getSigma_X_multiV", (DL_FUNC) &_SAIGE_getSigma_X_multiV, 6},
+    {"_SAIGE_getSigma_G_multiV", (DL_FUNC) &_SAIGE_getSigma_G_multiV, 6},
+    {"_SAIGE_fitglmmaiRPCG_multiV", (DL_FUNC) &_SAIGE_fitglmmaiRPCG_multiV, 14},
+    {"_SAIGE_getMeanDiagofKmat", (DL_FUNC) &_SAIGE_getMeanDiagofKmat, 1},
+    {"_SAIGE_getAIScore_multiV", (DL_FUNC) &_SAIGE_getAIScore_multiV, 13},
+    {"_SAIGE_GetTrace_multiV", (DL_FUNC) &_SAIGE_GetTrace_multiV, 11},
+    {"_SAIGE_getCoefficients_multiV", (DL_FUNC) &_SAIGE_getCoefficients_multiV, 7},
+    {"_SAIGE_setminMAC_VarianceRatio", (DL_FUNC) &_SAIGE_setminMAC_VarianceRatio, 3},
+    {"_SAIGE_get_GRMdiagVec", (DL_FUNC) &_SAIGE_get_GRMdiagVec, 0},
+    {"_SAIGE_setminMAFforGRM", (DL_FUNC) &_SAIGE_setminMAFforGRM, 1},
+    {"_SAIGE_setmaxMissingRateforGRM", (DL_FUNC) &_SAIGE_setmaxMissingRateforGRM, 1},
+    {"_SAIGE_set_Diagof_StdGeno_LOCO", (DL_FUNC) &_SAIGE_set_Diagof_StdGeno_LOCO, 0},
+    {"_SAIGE_get_DiagofKin", (DL_FUNC) &_SAIGE_get_DiagofKin, 0},
+    {"_SAIGE_parallelCrossProd_usingSubMarker", (DL_FUNC) &_SAIGE_parallelCrossProd_usingSubMarker, 1},
+    {"_SAIGE_getCrossprodMatAndKin_usingSubMarker", (DL_FUNC) &_SAIGE_getCrossprodMatAndKin_usingSubMarker, 1},
+    {"_SAIGE_parallelInnerProduct", (DL_FUNC) &_SAIGE_parallelInnerProduct, 2},
+    {"_SAIGE_createSparseKin", (DL_FUNC) &_SAIGE_createSparseKin, 4},
+    {"_SAIGE_refineKin", (DL_FUNC) &_SAIGE_refineKin, 1},
+    {"_SAIGE_getColfromStdGenoMultiMarkersMat", (DL_FUNC) &_SAIGE_getColfromStdGenoMultiMarkersMat, 1},
+    {"_SAIGE_getNColStdGenoMultiMarkersMat", (DL_FUNC) &_SAIGE_getNColStdGenoMultiMarkersMat, 0},
+    {"_SAIGE_getNRowStdGenoMultiMarkersMat", (DL_FUNC) &_SAIGE_getNRowStdGenoMultiMarkersMat, 0},
+    {"_SAIGE_setSubMarkerIndex", (DL_FUNC) &_SAIGE_setSubMarkerIndex, 1},
+    {"_SAIGE_setRelatednessCutoff", (DL_FUNC) &_SAIGE_setRelatednessCutoff, 1},
+    {"_SAIGE_innerProduct", (DL_FUNC) &_SAIGE_innerProduct, 2},
+    {"_SAIGE_getDiagOfSigma_noV", (DL_FUNC) &_SAIGE_getDiagOfSigma_noV, 3},
+    {"_SAIGE_getCrossprod_noV", (DL_FUNC) &_SAIGE_getCrossprod_noV, 4},
+    {"_SAIGE_getPCG1ofSigmaAndVector_noV", (DL_FUNC) &_SAIGE_getPCG1ofSigmaAndVector_noV, 6},
+    {"_SAIGE_getSigma_G_noV", (DL_FUNC) &_SAIGE_getSigma_G_noV, 6},
+    {"_SAIGE_set_useGRMtoFitNULL", (DL_FUNC) &_SAIGE_set_useGRMtoFitNULL, 1},
+    {"_SAIGE_set_isSparseGRM", (DL_FUNC) &_SAIGE_set_isSparseGRM, 1},
+    {"_SAIGE_set_store_sigma", (DL_FUNC) &_SAIGE_set_store_sigma, 1},
+    {"_SAIGE_set_num_Kmat", (DL_FUNC) &_SAIGE_set_num_Kmat, 1},
     {"_SAIGE_get_numofV", (DL_FUNC) &_SAIGE_get_numofV, 0},
-    {"_SAIGE_set_longlVar_vec", (DL_FUNC) &_SAIGE_set_longlVar_vec, 1},
     {"_SAIGE_set_covarianceidx_Mat", (DL_FUNC) &_SAIGE_set_covarianceidx_Mat, 0},
-    {"_SAIGE_set_Vmat_vec_longlVar", (DL_FUNC) &_SAIGE_set_Vmat_vec_longlVar, 0},
     {"_SAIGE_closeGenoFile_plink", (DL_FUNC) &_SAIGE_closeGenoFile_plink, 0},
     {"_SAIGE_gettotalMarker", (DL_FUNC) &_SAIGE_gettotalMarker, 0},
     {"_SAIGE_getAlleleFreqVec", (DL_FUNC) &_SAIGE_getAlleleFreqVec, 0},
@@ -2078,69 +1962,15 @@ static const R_CallMethodDef CallEntries[] = {
     {"_SAIGE_innerProductFun", (DL_FUNC) &_SAIGE_innerProductFun, 2},
     {"_SAIGE_parallelCrossProd_full", (DL_FUNC) &_SAIGE_parallelCrossProd_full, 2},
     {"_SAIGE_parallelCrossProd_LOCO", (DL_FUNC) &_SAIGE_parallelCrossProd_LOCO, 1},
-    {"_SAIGE_setupSparseGRM", (DL_FUNC) &_SAIGE_setupSparseGRM, 3},
-    {"_SAIGE_setupSparseGRM_new", (DL_FUNC) &_SAIGE_setupSparseGRM_new, 1},
-    {"_SAIGE_getCrossprodMatAndKin", (DL_FUNC) &_SAIGE_getCrossprodMatAndKin, 1},
-    {"_SAIGE_getCrossprodMatAndKin_LOCO", (DL_FUNC) &_SAIGE_getCrossprodMatAndKin_LOCO, 1},
     {"_SAIGE_printComb", (DL_FUNC) &_SAIGE_printComb, 1},
     {"_SAIGE_findIndiceRelatedSample", (DL_FUNC) &_SAIGE_findIndiceRelatedSample, 0},
     {"_SAIGE_parallelcalsparseGRM", (DL_FUNC) &_SAIGE_parallelcalsparseGRM, 1},
     {"_SAIGE_parallelsumTwoVec", (DL_FUNC) &_SAIGE_parallelsumTwoVec, 1},
+    {"_SAIGE_setgenoNULL", (DL_FUNC) &_SAIGE_setgenoNULL, 0},
     {"_SAIGE_setgeno", (DL_FUNC) &_SAIGE_setgeno, 7},
     {"_SAIGE_Get_OneSNP_Geno", (DL_FUNC) &_SAIGE_Get_OneSNP_Geno, 1},
     {"_SAIGE_Get_OneSNP_Geno_forVarRatio", (DL_FUNC) &_SAIGE_Get_OneSNP_Geno_forVarRatio, 1},
     {"_SAIGE_Get_OneSNP_StdGeno", (DL_FUNC) &_SAIGE_Get_OneSNP_StdGeno, 1},
-    {"_SAIGE_getDiagOfSigma_multiV", (DL_FUNC) &_SAIGE_getDiagOfSigma_multiV, 3},
-    {"_SAIGE_getCrossprod_multiV", (DL_FUNC) &_SAIGE_getCrossprod_multiV, 4},
-    {"_SAIGE_gen_sp_GRM", (DL_FUNC) &_SAIGE_gen_sp_GRM, 0},
-    {"_SAIGE_gen_sp_Sigma_multiV", (DL_FUNC) &_SAIGE_gen_sp_Sigma_multiV, 2},
-    {"_SAIGE_gen_spsolve_v4_multiV", (DL_FUNC) &_SAIGE_gen_spsolve_v4_multiV, 3},
-    {"_SAIGE_setisUsePrecondM", (DL_FUNC) &_SAIGE_setisUsePrecondM, 1},
-    {"_SAIGE_setisUseSparseSigmaforInitTau", (DL_FUNC) &_SAIGE_setisUseSparseSigmaforInitTau, 1},
-    {"_SAIGE_setisUseSparseSigmaforNullModelFitting", (DL_FUNC) &_SAIGE_setisUseSparseSigmaforNullModelFitting, 1},
-    {"_SAIGE_getPCG1ofSigmaAndVector_multiV", (DL_FUNC) &_SAIGE_getPCG1ofSigmaAndVector_multiV, 6},
-    {"_SAIGE_set_seed", (DL_FUNC) &_SAIGE_set_seed, 1},
-    {"_SAIGE_nb", (DL_FUNC) &_SAIGE_nb, 1},
-    {"_SAIGE_setStartEndIndex", (DL_FUNC) &_SAIGE_setStartEndIndex, 3},
-    {"_SAIGE_setStartEndIndexVec", (DL_FUNC) &_SAIGE_setStartEndIndexVec, 2},
-    {"_SAIGE_calCV", (DL_FUNC) &_SAIGE_calCV, 1},
-    {"_SAIGE_getSigma_X_multiV", (DL_FUNC) &_SAIGE_getSigma_X_multiV, 6},
-    {"_SAIGE_getSigma_G_multiV", (DL_FUNC) &_SAIGE_getSigma_G_multiV, 6},
-    {"_SAIGE_parallelCrossProd_usingSubMarker", (DL_FUNC) &_SAIGE_parallelCrossProd_usingSubMarker, 1},
-    {"_SAIGE_getCrossprodMatAndKin_usingSubMarker", (DL_FUNC) &_SAIGE_getCrossprodMatAndKin_usingSubMarker, 1},
-    {"_SAIGE_parallelInnerProduct", (DL_FUNC) &_SAIGE_parallelInnerProduct, 2},
-    {"_SAIGE_calGRMValueforSamplePair", (DL_FUNC) &_SAIGE_calGRMValueforSamplePair, 1},
-    {"_SAIGE_createSparseKin", (DL_FUNC) &_SAIGE_createSparseKin, 4},
-    {"_SAIGE_getColfromStdGenoMultiMarkersMat", (DL_FUNC) &_SAIGE_getColfromStdGenoMultiMarkersMat, 1},
-    {"_SAIGE_getNColStdGenoMultiMarkersMat", (DL_FUNC) &_SAIGE_getNColStdGenoMultiMarkersMat, 0},
-    {"_SAIGE_getNRowStdGenoMultiMarkersMat", (DL_FUNC) &_SAIGE_getNRowStdGenoMultiMarkersMat, 0},
-    {"_SAIGE_setSubMarkerIndex", (DL_FUNC) &_SAIGE_setSubMarkerIndex, 1},
-    {"_SAIGE_setRelatednessCutoff", (DL_FUNC) &_SAIGE_setRelatednessCutoff, 1},
-    {"_SAIGE_innerProduct", (DL_FUNC) &_SAIGE_innerProduct, 2},
-    {"_SAIGE_refineKin", (DL_FUNC) &_SAIGE_refineKin, 1},
-    {"_SAIGE_shortenList", (DL_FUNC) &_SAIGE_shortenList, 5},
-    {"_SAIGE_testTime", (DL_FUNC) &_SAIGE_testTime, 2},
-    {"_SAIGE_gen_sp_v2", (DL_FUNC) &_SAIGE_gen_sp_v2, 1},
-    {"_SAIGE_gen_spsolve_v2", (DL_FUNC) &_SAIGE_gen_spsolve_v2, 1},
-    {"_SAIGE_gen_spsolve_inR", (DL_FUNC) &_SAIGE_gen_spsolve_inR, 2},
-    {"_SAIGE_get_DiagofKin", (DL_FUNC) &_SAIGE_get_DiagofKin, 0},
-    {"_SAIGE_getstdgenoVectorScalorProduct", (DL_FUNC) &_SAIGE_getstdgenoVectorScalorProduct, 3},
-    {"_SAIGE_sumPz", (DL_FUNC) &_SAIGE_sumPz, 3},
-    {"_SAIGE_mmGetPb_MbyN", (DL_FUNC) &_SAIGE_mmGetPb_MbyN, 5},
-    {"_SAIGE_mmGetPb_NbyM", (DL_FUNC) &_SAIGE_mmGetPb_NbyM, 4},
-    {"_SAIGE_muliplyMailman", (DL_FUNC) &_SAIGE_muliplyMailman, 3},
-    {"_SAIGE_muliplyMailman_NbyM", (DL_FUNC) &_SAIGE_muliplyMailman_NbyM, 2},
-    {"_SAIGE_freqOverStd", (DL_FUNC) &_SAIGE_freqOverStd, 1},
-    {"_SAIGE_getCrossprodMatAndKin_mailman", (DL_FUNC) &_SAIGE_getCrossprodMatAndKin_mailman, 1},
-    {"_SAIGE_get_GRMdiagVec", (DL_FUNC) &_SAIGE_get_GRMdiagVec, 0},
-    {"_SAIGE_setminMAFforGRM", (DL_FUNC) &_SAIGE_setminMAFforGRM, 1},
-    {"_SAIGE_setmaxMissingRateforGRM", (DL_FUNC) &_SAIGE_setmaxMissingRateforGRM, 1},
-    {"_SAIGE_set_Diagof_StdGeno_LOCO", (DL_FUNC) &_SAIGE_set_Diagof_StdGeno_LOCO, 0},
-    {"_SAIGE_setminMAC_VarianceRatio", (DL_FUNC) &_SAIGE_setminMAC_VarianceRatio, 3},
-    {"_SAIGE_getCoefficients_multiV", (DL_FUNC) &_SAIGE_getCoefficients_multiV, 7},
-    {"_SAIGE_GetTrace_multiV", (DL_FUNC) &_SAIGE_GetTrace_multiV, 11},
-    {"_SAIGE_getAIScore_multiV", (DL_FUNC) &_SAIGE_getAIScore_multiV, 13},
-    {"_SAIGE_fitglmmaiRPCG_multiV", (DL_FUNC) &_SAIGE_fitglmmaiRPCG_multiV, 14},
     {"_SAIGE_SPA", (DL_FUNC) &_SAIGE_SPA, 10},
     {"_SAIGE_SPA_fast", (DL_FUNC) &_SAIGE_SPA_fast, 16},
     {"_SAIGE_Korg_Binom", (DL_FUNC) &_SAIGE_Korg_Binom, 3},
diff --git a/src/SAIGE_fitGLMM_fast_multiV.cpp~ b/src/SAIGE_fitGLMM_fast_multiV.cpp~
deleted file mode 100644
index 2b792fb9..00000000
--- a/src/SAIGE_fitGLMM_fast_multiV.cpp~
+++ /dev/null
@@ -1,260 +0,0 @@
-#define ARMA_USE_SUPERLU 1
-//[[Rcpp::depends(RcppArmadillo)]]
-#include <RcppArmadillo.h>
-//[[Rcpp::depends(RcppParallel)]]
-#include <RcppParallel.h> 
-#include <omp.h>
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <cmath>
-#include <ctime>// include this header for calculating execution time 
-#include <cassert>
-#include <boost/date_time.hpp> // for gettimeofday and timeval
-#include "getMem.hpp"
-using namespace Rcpp;
-using namespace std;
-using namespace RcppParallel;
-
-
-float minMAFtoConstructGRM = 0;
-//This is a class with attritbutes about the genotype informaiton 
-class genoClass{
-private:
-        //COPY from RVTEST:
-        // we reverse the two bits as defined in PLINK format
-        const static unsigned char HOM_REF = 0x0;  // 0b00 ;
-        const static unsigned char HET = 0x2;      // 0b10 ;
-        const static unsigned char HOM_ALT = 0x3;  // 0b11 ;
-        const static unsigned char MISSING = 0x1;  // 0b01 ;
-
-
-public:
-        //to chunk the geno vector to avoid large continuous memory usage 
-	int numMarkersofEachArray;
-        int numofGenoArray;
-        int numMarkersofLastArray;
-        std::vector< std::vector<unsigned char>* > genoVecofPointers;
-        ///////////
-        std::vector< std::vector<unsigned char>* > genoVecofPointers_forVarRatio;
-	//arma::fvec g_cateVarRatioMinMACVecExclude;
-	//arma::fvec g_cateVarRatioMaxMACVecInclude;
-	float g_minMACVarRatio;
-	float g_maxMACVarRatio;
-	bool isVarRatio = false;
-	int numberofMarkers_varRatio = 0;
-	int numberofMarkers_varRatio_common = 0;
-	arma::ivec g_randMarkerIndforVR;
-	std::vector<float>      invstdvVec0_forVarRatio;
-        arma::fvec      invstdvVec_forVarRatio;
-	 std::vector<float>      alleleFreqVec0_forVarRatio;
-        arma::fvec      alleleFreqVec_forVarRatio;
-	std::vector<int>      MACVec0_forVarRatio;
-	std::vector<int>      markerIndexVec0_forVarRatio;
-	arma::ivec MACVec_forVarRatio;
-	arma::ivec markerIndexVec_forVarRatio;
-
-
-	//vector<unsigned char> genoVec; 	 
-  	size_t M;
-  	size_t N;
-	size_t Nnomissing;
-	std::vector<float>	invstdvVec0;
-	arma::fvec	invstdvVec;
-	vector<int>	ptrsubSampleInGeno;
-	std::vector<bool> indicatorGenoSamplesWithPheno_in;	
-	
-
-  	std::vector<float> 	alleleFreqVec0;
-  	arma::fvec 	alleleFreqVec;
-  	arma::ivec	m_OneSNP_Geno;
-  	arma::fvec	m_OneSNP_StdGeno;
-  	arma::fvec	m_DiagStd;
-	arma::fvec	m_DiagStd_LOCO;
-  	arma::fmat	mtx_DiagStd_LOCO;
-
-
-	std::vector<int>	MACVec0; //for variance ratio based on different MAC categories
-	arma::ivec	MACVec;
-	arma::ivec	subMarkerIndex; //for sparse GRM
-	arma::fmat      stdGenoMultiMarkersMat;	
-	std::vector<float> stdGenoforSamples; //for sparse GRM
-	std::vector<float>     kinValueVecFinal;
-        float relatednessCutoff;
-	float maxMissingRate;
-
-	tbb::concurrent_vector< std::pair<int, int> > indiceVec;
-	arma::ivec xout;
-        arma::ivec yout;
-	//int Mmafge1perc;
-	bool setKinDiagtoOne;
-	int numberofMarkerswithMAFge_minMAFtoConstructGRM = 0;
-//	arma::SpMat<float> sparseGRMinC(2,2);
-	std::vector<bool> MarkerswithMAFge_minMAFtoConstructGRM_indVec;	
-
-
-        //std::vector<float> stdGenoVec;
-	//for LOCO
-	//bool LOCO = false;
-	//vector<int> chromosomeStartIndex;
-	//vector<int> chromosomeEndIndex;
-	//vector<int> chromosomeVec;
-        size_t Msub;
-        int startIndex;
-        int endIndex;
-	int chromIndex;
-
-        
-        arma::ivec startIndexVec;
-        arma::ivec endIndexVec;
-        arma::ivec startIndexVec_forvr;
-        arma::ivec endIndexVec_forvr;
-
-
-        int Msub_MAFge_minMAFtoConstructGRM;
-
-	int Msub_MAFge_minMAFtoConstructGRM_singleChr;
-	arma::ivec Msub_MAFge_minMAFtoConstructGRM_byChr;
-	//end for LOCO
-
-	unsigned char m_genotype_buffer[4];
-	int geno_idx;
-	int m_size_of_esi;
-	unsigned char m_bits_val[8];
-
-	
-	//look-up table for std geno
-	//float stdGenoLookUpArr[3] = {0};
-	void setStdGenoLookUpArr(float mafVal, float invsdVal, arma::fvec & stdGenoLookUpArr){
-	//	arma::fvec stdGenoLookUpArr(3);
-		float mafVal2 = 2*mafVal;
-		stdGenoLookUpArr(0) = (0-mafVal2)*invsdVal;
-		stdGenoLookUpArr(1) = (1-mafVal2)*invsdVal;
-		stdGenoLookUpArr(2) = (2-mafVal2)*invsdVal;
-	//	return(stdGenoLookUpArr)
-	}
-
-
-        //look-up table in a 2D array for sparseKin 
-        float sKinLookUpArr[3][3] = {{0}};
-	//(g - 2*freq)* invStd;;
-        void setSparseKinLookUpArr(float mafVal, float invsdVal){
-		float mafVal2 = 2*mafVal;
-		float a0 = (0-mafVal2)*invsdVal;
-		float a1 = (1-mafVal2)*invsdVal;
-		float a2 = (2-mafVal2)*invsdVal;
-		
-		sKinLookUpArr[0][0] = a0*a0;
-		sKinLookUpArr[0][1] = a0*a1;
-		sKinLookUpArr[0][2] = a0*a2;
-		sKinLookUpArr[1][0] = sKinLookUpArr[0][1];
-		sKinLookUpArr[1][1] = a1*a1;
-		sKinLookUpArr[1][2] = a1*a2;
-		sKinLookUpArr[2][0] = sKinLookUpArr[0][2];
-		sKinLookUpArr[2][1] = sKinLookUpArr[1][2];
-		sKinLookUpArr[2][2] = a2*a2;
-
-	}
-
-
-
-
-        void setBit(unsigned char & ch, int ii, int aVal, int bVal){
-
-                if (bVal == 1 && aVal == 1){
-			ch ^= char(1 << ((ii*2) + 1)); //set a to be 1
-
-                }else if(bVal == 0){
-			ch ^= char(1 << (ii*2)); //change b to 0
-
-                        if(aVal == 1){
-				ch ^= char(1 << ((ii*2) + 1)); //change a to 1
-                        }
-                }
-        }
-
-
-
-	//COPY from RVTEST:
-	void setGenotype(unsigned char* c, const int pos, const int geno) {
-    		(*c) |= (geno << (pos << 1));
-  	}
-
-	void getGenotype(unsigned char* c, const int pos, int& geno) {
-    		geno = ((*c) >> (pos << 1)) & 0x3;  // 0b11 = 0x3
-  	}
-
-
-
-	void Init_OneSNP_Geno(){
-		m_size_of_esi = (Nnomissing+3)/4;
-		int k = 8;
-		while (k > 0){
-			-- k;
-			m_bits_val[k] = 1 << k;
-		}
-	}
-	
-
-        arma::ivec * Get_OneSNP_Geno(size_t SNPIdx){
-                m_OneSNP_Geno.zeros(Nnomissing);
-
-		//avoid large continuous memory usage
-		int indexOfVectorPointer = SNPIdx/numMarkersofEachArray;
-                int SNPIdxinVec = SNPIdx % numMarkersofEachArray;
-		////////////////
-
-                size_t Start_idx = m_size_of_esi * SNPIdxinVec;
-                size_t ind= 0;
-                unsigned char geno1;
-                int bufferGeno;
-                for(size_t i=Start_idx; i< Start_idx+m_size_of_esi - 1; i++){
-                        //geno1 = genoVec[i];
-			geno1 = genoVecofPointers[indexOfVectorPointer]->at(i); //avoid large continuous memory usage
-                        for(int j=0; j<4; j++){
-                                int b = geno1 & 1 ;
-                                geno1 = geno1 >> 1;
-                                int a = geno1 & 1 ;
-				bufferGeno = 2-(a+b);
-				m_OneSNP_Geno[ind] = bufferGeno;
-                                ind++;
-                                geno1 = geno1 >> 1;
-                                //if(ind >= Nnomissing){
-
-                                ////printf("%d, %d-%d-%d-%f-%d\n",Start_idx, genoVec[i] ,a ,b , m_OneSNP_Geno[ind-1] , m_size_of_esi);
-                                //        return & m_OneSNP_Geno;
-                                //}
-                        }
-                }
-
-		size_t i = Start_idx+m_size_of_esi - 1;
-		geno1 = genoVecofPointers[indexOfVectorPointer]->at(i);
-		for(int j=0; j<4; j++){
-                                int b = geno1 & 1 ;
-                                geno1 = geno1 >> 1;
-                                int a = geno1 & 1 ;
-                                bufferGeno = 2-(a+b);
-                                m_OneSNP_Geno[ind] = bufferGeno;
-                                ind++;
-                                geno1 = geno1 >> 1;
-                                if(ind >= Nnomissing){
-
-                                ////printf("%d, %d-%d-%d-%f-%d\n",Start_idx, genoVec[i] ,a ,b , m_OneSNP_Geno[ind-1] , m_size_of_esi);
-                                        return & m_OneSNP_Geno;
-                                }
-                }
-
-                return & m_OneSNP_Geno;
-       }
-   
-        arma::ivec * Get_OneSNP_Geno_forVarRatio(size_t SNPIdx){
-                m_OneSNP_Geno.zeros(Nnomissing);
-
-		//avoid large continuous memory usage
-		int indexOfVectorPointer = SNPIdx/numMarkersofEachArray;
-                int SNPIdxinVec = SNPIdx % numMarkersofEachArray;
-		////////////////
-
-                size_t Start_idx = m_size_of_esi * SNPIdxinVec;
-                
\ No newline at end of file
diff --git a/src/SAIGE_test.cpp b/src/SAIGE_test.cpp
index b446ce62..54ff5716 100644
--- a/src/SAIGE_test.cpp
+++ b/src/SAIGE_test.cpp
@@ -24,7 +24,7 @@ namespace SAIGE {
 
 SAIGEClass::SAIGEClass(
 	arma::mat & t_XVX,
-	arma::mat  t_XXVX_inv,
+	arma::mat t_XXVX_inv,
 	arma::mat & t_XV,
 	arma::mat & t_XVX_inv_XV,
 	arma::mat & t_Sigma_iXXSigma_iX,
@@ -45,15 +45,13 @@ SAIGEClass::SAIGEClass(
 	bool t_flagSparseGRM,
 	bool t_isFastTest,
 	double t_pval_cutoff_for_fastTest,
-	arma::umat & t_locationMat,
-	arma::vec & t_valueVec,
-        int t_dimNum,
 	bool t_isCondition,
         std::vector<uint32_t> & t_condition_genoIndex,
 	bool t_is_Firth_beta,
         double t_pCutoffforFirth,
         arma::vec & t_offset,
-	arma::vec & t_resout){
+	arma::vec & t_resout, 
+	arma::sp_mat & t_SigmaMat_sp){
 
 
     m_XVX = t_XVX;
@@ -108,15 +106,19 @@ SAIGEClass::SAIGEClass(
 	m_offset = t_offset;
       //}
     }
-    m_dimNum = t_dimNum;
+    //m_dimNum = t_dimNum;
     m_flagSparseGRM = t_flagSparseGRM;
     m_isFastTest = t_isFastTest;
     m_pval_cutoff_for_fastTest = t_pval_cutoff_for_fastTest;
-    if(m_dimNum != 0){
-	m_locationMat = t_locationMat;
-    	m_valueVec = t_valueVec;
-    }
-
+    //if(m_dimNum != 0){
+    //	m_locationMat = t_locationMat;
+    //	m_valueVec = t_valueVec;
+    //}
+    //
+    //if(t_SigmaMat_sp.n_rows > 2){
+	std::cout << "here m_SigmaMat_sp" << std::endl;
+	m_SigmaMat_sp = t_SigmaMat_sp;
+    //}	    
 }    
 
 
@@ -158,15 +160,23 @@ void SAIGEClass::scoreTest(arma::vec & t_GVec,
       t_P2Vec = t_gtilde % m_mu2 *m_tauvec[0];  
       var2m = dot(t_P2Vec , t_gtilde);
     }else{
-      arma::sp_mat m_SigmaMat_sp = gen_sp_SigmaMat();
+      if(m_SigmaMat_sp.n_rows > 2){	
       t_P2Vec = arma::spsolve(m_SigmaMat_sp, t_gtilde);
-      var2m = dot(t_P2Vec , t_gtilde);
+      var2m = dot(t_P2Vec, t_gtilde);
       if(m_isVarPsadj){
 	var2m = var2m - t_gtilde.t() * m_Sigma_iXXSigma_iX * m_X.t() * t_P2Vec;	
       }
+     }else{	
+	t_P2Vec = m_sigmainvG_noV;
+	var2m = dot(t_P2Vec , t_gtilde);
+     }
+
     }	      
     var2 = var2m(0,0);
+        std::cout << "var2 " << var2 << std::endl;
+    std::cout << "m_varRatioVal " << m_varRatioVal << std::endl;
     double var1 = var2 * m_varRatioVal;
+        std::cout << "var1 " << var1 << std::endl;
     double stat = S*S/var1;
     double t_pval;
     
@@ -235,7 +245,10 @@ void SAIGEClass::scoreTestFast(arma::vec & t_GVec,
       var2 = ZtXVXZ(0,0)*m_tauvec[0] +  dot(g1,g1) - 2*Bmu2;
     }
 
+
+    std::cout << "var2 " << var2 << std::endl;
     var1 = var2 * m_varRatioVal;
+    std::cout << "var1 " << var1 << std::endl;
     S1 = dot(res1, g1_tilde);
     arma::mat res1X1_temp = (res1.t()) * X1;
     arma::vec res1X1 = res1X1_temp.t();
@@ -247,6 +260,7 @@ void SAIGEClass::scoreTestFast(arma::vec & t_GVec,
 
     double stat = S*S/var1;
     double t_pval;
+    std::cout << "S " << S << std::endl;
 
     //if (var1 <= std::pow(std::numeric_limits<double>::min(), 2)){
     if (var1 <= std::numeric_limits<double>::min()){
@@ -437,7 +451,8 @@ void SAIGEClass::getMarkerPval(arma::vec & t_GVec,
 if(!t_isER){
 
 
-  if(StdStat > m_SPA_Cutoff && m_traitType != "quantitative"){
+  //if(StdStat > m_SPA_Cutoff && m_traitType != "quantitative"){
+  if(StdStat > m_SPA_Cutoff && m_traitType == "binary"){
 
        if(!is_gtilde){
           t_gtilde.resize(m_n);
@@ -519,10 +534,10 @@ if(!t_isER){
 	double tol0 = std::numeric_limits<double>::epsilon();
 	tol1 = std::pow(tol0, 0.25);
 	if(p_iIndexComVecSize >= 0.5){
-		//std::cout << "SPA_fast" << std::endl;
+		std::cout << "SPA_fast" << std::endl;
         	SPA_fast(m_mu, t_gtilde, q, qinv, pval_noadj, false, gNA, gNB, muNA, muNB, NAmu, NAsigma, tol1, m_traitType, t_SPApval, t_isSPAConverge);
 	}else{
-		//std::cout << "SPA" << std::endl;
+		std::cout << "SPA" << std::endl;
 		SPA(m_mu, t_gtilde, q, qinv, pval_noadj, tol1, logp, m_traitType, t_SPApval, t_isSPAConverge);	
 	}
 
@@ -540,10 +555,11 @@ if(!t_isER){
         } 
   }
    t_pval_noSPA = pval_noadj; 
-   if(m_traitType!="quantitative"){
+   //if(m_traitType!="quantitative"){
+   if(m_traitType=="binary"){
         if(t_isSPAConverge){
-                //t_pval = t_SPApval;
-                t_pval = pval_noadj;
+                t_pval = t_SPApval;
+                //t_pval = pval_noadj;
         }else{
                 t_pval = pval_noadj;
         }
@@ -667,7 +683,8 @@ if(!t_isER){
   t_pval_noSPA_c = pval_noSPA_c; 
 
 
-    if(m_traitType != "quantitative" && stat_c > std::pow(m_SPA_Cutoff,2)){
+    //if(m_traitType != "quantitative" && stat_c > std::pow(m_SPA_Cutoff,2)){
+    if(m_traitType == "binary" && stat_c > std::pow(m_SPA_Cutoff,2)){
 	bool t_isSPAConverge_c;
 	double q_c, qinv_c, pval_noadj_c, SPApval_c;    
 	if(m_traitType == "binary"){
@@ -731,8 +748,24 @@ if(!t_isER){
       if(!m_flagSparseGRM_cur){
         t_P2Vec = t_gtilde % m_mu2 *m_tauvec[0];
       }else{
-        arma::sp_mat m_SigmaMat_sp = gen_sp_SigmaMat();
-        t_P2Vec = arma::spsolve(m_SigmaMat_sp, t_gtilde);
+
+	 if(m_SigmaMat_sp.n_rows > 2){
+
+
+      t_P2Vec = arma::spsolve(m_SigmaMat_sp, t_gtilde);
+      //var2m = dot(t_P2Vec , t_gtilde);
+      //if(m_isVarPsadj){
+      //  var2m = var2m - t_gtilde.t() * m_Sigma_iXXSigma_iX * m_X.t() * t_P2Vec;
+      //}
+     }else{
+        t_P2Vec = m_sigmainvG_noV;
+        //var2m = dot(t_P2Vec , t_GVec);
+     }
+
+
+
+        //arma::sp_mat m_SigmaMat_sp = gen_sp_SigmaMat();
+        //t_P2Vec = arma::spsolve(m_SigmaMat_sp, t_gtilde);
       }
     }
 }
diff --git a/src/SAIGE_test.hpp b/src/SAIGE_test.hpp
index 70517751..83a71de2 100644
--- a/src/SAIGE_test.hpp
+++ b/src/SAIGE_test.hpp
@@ -18,8 +18,6 @@ class SAIGEClass
       arma::vec m_res;
       arma::vec m_resout;
       arma::vec m_mu;
-      arma::vec m_mu2;
-      arma::vec m_tauvec;
       arma::vec  m_S_a;
       std::string m_traitType; 
       std::string m_impute_method;
@@ -27,6 +25,8 @@ class SAIGEClass
       	
 
     public:
+      arma::vec m_mu2;
+      arma::vec m_tauvec;
       arma::mat m_XXVX_inv;
       arma::mat m_XV;
       int m_n, m_p; //MAIN Dimensions: sample size, number of covariates
@@ -46,7 +46,7 @@ class SAIGEClass
       arma::uvec m_ctrl_het_indices;
       int m_n_case;
       int m_n_ctrl;
-      arma::sp_mat m_SigmaMat_sp;
+      //arma::sp_mat m_SigmaMat_sp;
       bool m_flagSparseGRM;
       bool m_flagSparseGRM_cur;
       bool m_isFastTest;
@@ -75,6 +75,10 @@ class SAIGEClass
       double m_pCutoffforFirth;
      arma::vec  m_offset;	
       bool m_isVarPsadj;
+
+      arma::vec m_sigmainvG_noV;	
+      arma::sp_mat m_SigmaMat_sp;
+      //arma::m_var2m;
   ////////////////////// -------------------- functions ---------------------------------- //////////////////////
   
 
@@ -101,15 +105,13 @@ class SAIGEClass
         bool t_flagSparseGRM,
 	bool t_isFastTest,
 	double t_pval_cutoff_for_fastTest,
-        arma::umat & t_locationMat,
-        arma::vec & t_valueVec,
-        int t_dimNum,
         bool t_isCondition,
         std::vector<uint32_t> & t_condition_genoIndex,
 	bool t_is_Firth_beta,
         double t_pCutoffforFirth,
 	arma::vec & t_offset,
-	arma::vec & t_resout);
+	arma::vec & t_resout, 
+	arma::sp_mat & t_SigmaMat_sp);
 
    void set_seed(unsigned int seed);
 
diff --git a/src/SIGMA.hpp b/src/SIGMA.hpp
new file mode 100644
index 00000000..a9b2d267
--- /dev/null
+++ b/src/SIGMA.hpp
@@ -0,0 +1,35 @@
+#define ARMA_USE_SUPERLU 1
+//[[Rcpp::depends(RcppArmadillo)]]
+#include <RcppArmadillo.h>
+//[[Rcpp::depends(RcppParallel)]]
+#include <RcppParallel.h>
+#include <omp.h>
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include <cmath>
+#include <ctime>// include this header for calculating execution time
+#include <cassert>
+#include <boost/date_time.hpp> // for gettimeofday and timeval
+#include "getMem.hpp"
+using namespace Rcpp;
+using namespace std;
+using namespace RcppParallel;
+
+
+
+namespace SIGMA {
+
+class sigmaClass{
+
+private:
+
+
+
+
+};
+
+}
+
+#endif	
diff --git a/src/SPA.cpp b/src/SPA.cpp
index 8411eced..f7edce19 100644
--- a/src/SPA.cpp
+++ b/src/SPA.cpp
@@ -32,15 +32,15 @@ void SPA(arma::vec & mu, arma::vec & g, double q, double qinv, double pval_noadj
           outuni2 = getroot_K1_Poi(0, mu, g, qinv, tol);
         }
 
-        //double outuni1root = outuni1["root"];
-        //double outuni2root = outuni2["root"];
-        //bool Isconverge1 = outuni1["Isconverge"];
-        //bool Isconverge2 = outuni2["Isconverge"];
+        double outuni1root = outuni1["root"];
+        double outuni2root = outuni2["root"];
+        bool Isconverge1 = outuni1["Isconverge"];
+        bool Isconverge2 = outuni2["Isconverge"];
 
-        //std::cout << "outuni1root" << outuni1root << std::endl;
-        //std::cout << "outuni2root" << outuni2root << std::endl;
-        //std::cout << "Isconverge1" << Isconverge1 << std::endl;
-        //std::cout << "Isconverge2" << Isconverge2 << std::endl;
+        std::cout << "outuni1root" << outuni1root << std::endl;
+        std::cout << "outuni2root" << outuni2root << std::endl;
+        std::cout << "Isconverge1" << Isconverge1 << std::endl;
+        std::cout << "Isconverge2" << Isconverge2 << std::endl;
 
 
         Rcpp::List getSaddle;
@@ -75,7 +75,7 @@ void SPA(arma::vec & mu, arma::vec & g, double q, double qinv, double pval_noadj
                                 p2 = pval_noadj/2;
                         }
                 }
-                //std::cout << "p1_nofast " << p1 << "p2 " << p2 << std::endl;
+                std::cout << "p1_nofast " << p1 << "p2 " << p2 << std::endl;
 
                 if(logp)
                 {
@@ -83,6 +83,8 @@ void SPA(arma::vec & mu, arma::vec & g, double q, double qinv, double pval_noadj
                 } else {
                         pval = std::abs(p1)+std::abs(p2);
                 }
+
+		std::cout << "pval " << pval << std::endl;
                 Isconverge=true;
         }else {
                         //std::cout << "Error_Converge" << std::endl;
diff --git a/src/SAIGE_fitGLMM_fast_multiV.cpp b/src/backup2/SAIGE_fitGLMM_fast_multiV.cpp
similarity index 69%
rename from src/SAIGE_fitGLMM_fast_multiV.cpp
rename to src/backup2/SAIGE_fitGLMM_fast_multiV.cpp
index a8e491c1..a920000a 100644
--- a/src/SAIGE_fitGLMM_fast_multiV.cpp
+++ b/src/backup2/SAIGE_fitGLMM_fast_multiV.cpp
@@ -1165,8 +1165,31 @@ public:
 genoClass geno;
 
 std::vector<arma::sp_fmat> Kmat_vec;
+arma::fvec g_longl_vec;
+
+arma::sp_fmat g_I_longl_mat;
+arma::sp_fmat g_T_longl_mat;
+arma::uvec g_I_longl_vec;
+arma::fvec g_T_longl_vec;
+
+// [[Rcpp::export]]
+void set_I_longl_mat(arma::sp_mat & t_Ilongmat, arma::vec & t_I_longl_vec){
+	arma::sp_fmat t_Kmat_new = arma::conv_to< arma::sp_fmat >::from(t_Ilongmat);
+	g_I_longl_mat = t_Kmat_new;
+	arma::uvec t_I_longl_vec_new = arma::conv_to< arma::uvec >::from(t_I_longl_vec);
+	g_I_longl_vec = t_I_longl_vec_new;
+
+}
+
+
+// [[Rcpp::export]]
+void set_T_longl_mat(arma::sp_mat & t_Tlongmat, arma::vec & t_T_longl_vec){
+        arma::sp_fmat t_Kmat_new = arma::conv_to< arma::sp_fmat >::from(t_Tlongmat);
+        g_T_longl_mat = t_Kmat_new;
+	arma::fvec t_T_longl_vec_new = arma::conv_to< arma::fvec >::from(t_T_longl_vec);
+	g_T_longl_vec = t_T_longl_vec_new;
+}
 
-arma::vec g_longl_vec;
 
 // [[Rcpp::export]]
 void addNewKat( arma::sp_mat & t_Kmat){
@@ -1176,6 +1199,23 @@ void addNewKat( arma::sp_mat & t_Kmat){
         std::cout << "Kmat_vec.size() " << Kmat_vec.size() << std::endl;
 }
 
+// [[Rcpp::export]]
+arma::fvec getCrossprodMatAndKin(arma::fcolvec& bVec, bool LOCO){
+    arma::fvec crossProdVec;
+    if(g_isSparseGRM){
+        crossProdVec = g_spGRM * bVec;
+    }else{
+        if(!LOCO){
+          crossProdVec = parallelCrossProd(bVec);
+        }else{
+          crossProdVec = parallelCrossProd_LOCO(bVec)
+        }
+    }
+    return(crossProdVec);
+}
+
+
+
 // [[Rcpp::export]]
 arma::sp_fmat getProdTauKmat(arma::fvec & tauVec){
 	arma::sp_fmat Kmat_sigma;
@@ -1190,24 +1230,37 @@ arma::sp_fmat getProdTauKmat(arma::fvec & tauVec){
 }	
 
 
-arma::sp_mat g_spGRM;
+arma::sp_fmat g_spGRM;
+arma::sp_fmat g_spSigma;
+bool g_isStoreSigma;
+int g_num_Kmat;
+bool g_isGRM;
+bool g_isSparseGRM;
 
 // [[Rcpp::export]]
-arma::fvec getMeanDiagofKmat(){
-	arma::fvec mean_diag_kins_vec(Kmat_vec.size() + 1);
-	arma::fvec diagVecofKmat;
-	for (int i = 0; i < Kmat_vec.size(); i++){
-		diagVecofKmat = Kmat_vec[i].diag();
-		mean_diag_kins_vec(i+1) = arma::mean(diagVecofKmat);
-	}
-	//arma::vec = g_spGRM.diag();
+void set_useGRMtoFitNULL(bool useGRMtoFitNULL){
+	g_isGRM = useGRMtoFitNULL;
+}
+
+// [[Rcpp::export]]
+void set_isSparseGRM(bool t_isSparseGRM){
+        g_isSparseGRM = t_isSparseGRM;
+}
+
+
+// [[Rcpp::export]]
+void set_store_sigma(bool isstoreSigma){
+        //g_longl_vec = arma::conv_to< arma::fvec >::from(longlVec);
+        g_isStoreSigma = isstoreSigma;
+}
+
+
+// [[Rcpp::export]]
+void set_num_Kmat(int t_num_Kmat){
+        //g_longl_vec = arma::conv_to< arma::fvec >::from(longlVec);
+        g_num_Kmat = t_num_Kmat;
+}
 
-	arma::vec diagVecofKmat_0;
-       diagVecofKmat_0	= arma::diagvec(g_spGRM);
-	diagVecofKmat = arma::conv_to< arma::fvec >::from(diagVecofKmat_0);
-	mean_diag_kins_vec(0) = arma::mean(diagVecofKmat); 
-	return(mean_diag_kins_vec);
-}	
 
 
 // [[Rcpp::export]]
@@ -1218,8 +1271,8 @@ int get_numofV(){
 
 // [[Rcpp::export]]
 void set_longlVar_vec(arma::vec & longlVec){
-	//g_longl_vec = arma::conv_to< arma::fvec >::from(longlVec);
-	g_longl_vec = longlVec;
+	g_longl_vec = arma::conv_to< arma::fvec >::from(longlVec);
+	//g_longl_vec = longlVec;
 }
 
 arma::umat g_covarianceidxMat;
@@ -1253,7 +1306,9 @@ kins1.cov.intercept.slope kins2.cov.intercept.slope           kins1.var.slope
 
 // [[Rcpp::export]]
 arma::umat set_covarianceidx_Mat(){
-	unsigned int k = Kmat_vec.size();
+	//unsigned int k = Kmat_vec.size();
+	unsigned int k = g_num_Kmat;
+
 	unsigned int q = (k+1)/3; 
 	g_covarianceidxMat.set_size(q, 3);
 	g_covarianceidxMat.zeros();
@@ -1278,22 +1333,24 @@ arma::umat set_covarianceidx_Mat(){
 void set_Vmat_vec_longlVar(){
 	std::cout << "here" << std::endl;
 	int k  = Kmat_vec.size(); 
-	arma::sp_mat spGRM_longl_0;
+	arma::sp_fmat spGRM_longl_0;
 	arma::sp_fmat spGRM_longl;
 	for(int j=0; j < 1+k; j++){
 	  if(j == 0){
 	    spGRM_longl_0 = g_spGRM;
 	  }else{
 	    //spGRM_longl = Kmat_vec[j-1];	  
-	    spGRM_longl_0 = arma::conv_to< arma::sp_mat >::from(Kmat_vec[j-1]);	
+	    //spGRM_longl_0 = arma::conv_to< arma::sp_mat >::from(Kmat_vec[j-1]);	
+	    spGRM_longl_0 = Kmat_vec[j-1];
 	  }	  
           //spGRM_longl_0 = g_longl_vec.t() % (spGRM_longl_0.each_row());
           for(int q=0; q < spGRM_longl_0.n_rows; q++){
           //for(int q=0; q < spGRM_longl.n_rows; q++){
 		 spGRM_longl_0.row(q) = g_longl_vec.t() % spGRM_longl_0.row(q); 
 	  }
-	  spGRM_longl = arma::conv_to< arma::sp_fmat >::from(spGRM_longl_0);
-          Kmat_vec.push_back(spGRM_longl);
+	  //spGRM_longl = arma::conv_to< arma::sp_fmat >::from(spGRM_longl_0);
+          //Kmat_vec.push_back(spGRM_longl);
+          Kmat_vec.push_back(spGRM_longl_0);
 	  	
 	  //spGRM_longl_0 = spGRM_longl_0 % g_longl_vec;
 	  //spGRM_longl_0 = g_longl_vec.t() % (spGRM_longl_0.t().each_row());
@@ -1302,8 +1359,9 @@ void set_Vmat_vec_longlVar(){
                  spGRM_longl_0.col(q) = spGRM_longl_0.col(q) % g_longl_vec;
                  //spGRM_longl.col(q) = spGRM_longl.col(q) % g_longl_vec;
           }
-	  spGRM_longl = arma::conv_to< arma::sp_fmat >::from(spGRM_longl_0);
-          Kmat_vec.push_back(spGRM_longl);
+	  //spGRM_longl = arma::conv_to< arma::sp_fmat >::from(spGRM_longl_0);
+          //Kmat_vec.push_back(spGRM_longl);
+          Kmat_vec.push_back(spGRM_longl_0);
 	  std::cout << "x here" << std::endl;
 	  //spGRM_longl_0.clear();
 	  spGRM_longl.clear();
@@ -1841,54 +1899,18 @@ void setupSparseGRM(int r, arma::umat & locationMatinR, arma::vec & valueVecinR)
 
 // [[Rcpp::export]]
 void setupSparseGRM_new(arma::sp_mat & t_spGRM){
-	g_spGRM = t_spGRM;
+	arma::sp_mat t_spGRM_1 = t_spGRM;
+	arma::sp_fmat g_spGRM_f = arma::conv_to<arma::sp_fmat>::from(t_spGRM_1);
+	g_spGRM = g_spGRM_f;
 }
 
+
 bool isUsePrecondM = false;
 bool isUseSparseSigmaforInitTau = false;
 bool isUseSparseSigmaforModelFitting = false;
 
 
 
-// [[Rcpp::export]]
-arma::fvec getCrossprodMatAndKin(arma::fcolvec& bVec){
-    arma::fvec crossProdVec;
-    if(isUseSparseSigmaforInitTau | isUseSparseSigmaforModelFitting){
-        arma::dcolvec bVec_new = arma::conv_to<arma::dcolvec>::from(bVec);
-        //cout << "use sparse kinship to estimate initial tau and for getCrossprodMatAndKin" <<  endl;
-	//arma::sp_mat result(locationMat, valueVec, dimNum, dimNum);
-	//arma::vec x = result * bVec_new;
-	arma::vec x = g_spGRM * bVec_new;
-        // double wall3in = get_wall_time();
-        // double cpu3in  = get_cpu_time();
-        // cout << "Wall Time in gen_spsolve_v4 = " << wall3in - wall2in << endl;
-        // cout << "CPU Time  in gen_spsolve_v4 = " << cpu3in - cpu2in  << endl;
-        crossProdVec = arma::conv_to<arma::fvec>::from(x);
-
-
-    }else{ 
-  	crossProdVec = parallelCrossProd(bVec) ;
-    }  
-    return(crossProdVec);
-}
-
-
-// [[Rcpp::export]]
-arma::fvec getCrossprodMatAndKin_LOCO(arma::fcolvec& bVec){
-
-        arma::fvec crossProdVec = parallelCrossProd_LOCO(bVec) ;
-        //arma::fvec crossProdVec_2 = parallelCrossProd_LOCO_2(bVec) ;
-
-	//for(int k=0; k < 10; k++) {
-        //	std::cout << "new crossProdVec " << k << " " << crossProdVec[k] << std::endl;
-        //	std::cout << "old crossProdVec " << k << " " << crossProdVec_2[k] << std::endl;
-
-	//}	
-
-
-        return(crossProdVec);
-}
-
 
 // [[Rcpp::depends(RcppParallel)]]
 // [[Rcpp::plugins(cpp11)]]
@@ -2149,7 +2171,7 @@ arma::fvec Get_OneSNP_StdGeno(int SNPIdx)
 
 //Sigma = tau[1] * diag(1/W) + tau[2] * kins 
 // [[Rcpp::export]]
-arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+arma::fvec getDiagOfSigma_largeMem__multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
   
 	int Nnomissing = geno.getNnomissing();
 	arma::fvec diagVec(Nnomissing);
@@ -2206,8 +2228,165 @@ arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO
 }
 
 
+
+
+
 // [[Rcpp::export]]
-arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+arma::fvec getDiagOfSigma_multiV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+        int Nnomissing = wVec.n_elem;
+        arma::fvec diagVec(Nnomissing);
+        arma::sp_fvec diagVecV0;
+        arma::fvec diagVecG, diagVecV, diagVecG_I, diagVecG_T, diagVecG_IT,diagVecV_I, diagVecV_T, diagVecV_IT;
+        unsigned int tauind = 0;
+
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+         if(g_isGRM){
+          if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+           if(!g_isSparseGRM){
+            if(!LOCO){
+              int MminMAF = geno->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+              diagVec = tauVec(1)* (*ptr_gNULLGENOobj->Get_Diagof_StdGeno()) /MminMAF + tauVec(0)/wVec;
+            }else{
+              diagVec = tauVec(1)* (*ptr_gNULLGENOobj->Get_Diagof_StdGeno_LOCO());
+              int Msub_MAFge_minMAFtoConstructGRM_in_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_in();
+              int Msub_MAFge_minMAFtoConstructGRM_singleVar_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_singleChr_in();
+              diagVec = diagVec/(Msub_MAFge_minMAFtoConstructGRM_in_b - Msub_MAFge_minMAFtoConstructGRM_singleVar_b) + tauVec(0)/wVec;
+            }
+            tauind = tauind + 2;
+           }else{
+             diagVec = tauVec(0)/wVec;
+             tauind = tauind + 1;
+             diagVecG = g_spGRM.diag();
+             diagVec = diagVec + tauVec(tauind) * diagVecG;
+             tauind = tauind + 1;
+
+           }
+          }else{ //if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+            diagVec = tauVec(1) + tauVec(0)/wVec;
+            tauind = tauind + 2;
+          }
+        }else{//if(g_isGRM){
+          diagVec = tauVec(0)/wVec;
+          tauind = tauind + 1;
+        }
+
+
+          if(Kmat_vec.size() > 0){
+            for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+              diagVec = diagVec + (Kmat_vec[i]).diag() * tauVec(tauind);
+            }
+          }
+
+        }else{ //if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                diagVec = tauVec(0)/wVec;
+                tauind = tauind + 1;
+          if(g_isGRM && g_isSparseGRM){
+                diagVecG = g_spGRM.diag();
+                diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVec + tauVec(tauind) * diagVecG_I;
+                tauind = tauind + 1;
+
+                if(g_T_longl_mat.n_rows > 0){
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_IT;
+                  tauind = tauind + 1;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_T;
+                  tauind = tauind + 1;
+                }
+            }
+
+
+
+                if(Kmat_vec.size() > 0){
+                  for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                    diagVecV0 = Kmat_vec[i].diag();
+                    arma::fvec diagVecVtemp(diagVecV0);
+                    diagVecV = diagVecVtemp;
+                    diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                    diagVec = diagVec + tauVec(tauind) * diagVecV_I;
+                    tauind = tauind + 1;
+                    if(g_T_longl_mat.n_rows > 0){
+                      diagVecV_IT = diagVecV_I % g_T_longl_vec;
+                      diagVecV_T = diagVecV_IT % g_T_longl_vec;
+                      diagVecV_IT = 2 * diagVecV_IT;
+                      diagVec = diagVec + tauVec(tauind) * diagVecV_IT;
+                      tauind = tauind + 1;
+                      diagVec = diagVec + tauVec(tauind) * diagVecV_T;
+                      tauind = tauind + 1;
+                    }
+                  }
+                }
+
+        }
+
+        for(unsigned int i=0; i< Nnomissing; i++){
+                if(diagVec(i) < 1e-4){
+                        diagVec(i) = 1e-4 ;
+                }
+        }
+
+        return(diagVec);
+}
+
+
+
+// [[Rcpp::export]]
+arma::fvec getDiagOfSigma_noV(arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+        int Nnomissing = wVec.n_elem;
+        arma::fvec diagVec(Nnomissing);
+        arma::sp_fvec diagVecV0;
+        arma::fvec diagVecG, diagVecV, diagVecG_I, diagVecG_T, diagVecG_IT,diagVecV_I, diagVecV_T, diagVecV_IT;
+        unsigned int tauind = 0;
+
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+          if(!(geno.setKinDiagtoOne)){
+             diagVec = tauVec(0)/wVec;
+             tauind = tauind + 1;
+             diagVecG = g_spGRM.diag();
+             diagVec = diagVec + tauVec(tauind) * diagVecG;
+             tauind = tauind + 1;
+          }else{ //if(!(ptr_gNULLGENOobj->setKinDiagtoOne)){
+            diagVec = tauVec(1) + tauVec(0)/wVec;
+            tauind = tauind + 2;
+          }
+
+
+        }else{ //if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                diagVec = tauVec(0)/wVec;
+                tauind = tauind + 1;
+                diagVecG = g_spGRM.diag();
+                diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVec + tauVec(tauind) * diagVecG_I;
+                tauind = tauind + 1;
+
+                if(g_T_longl_mat.n_rows > 0){
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_IT;
+                  tauind = tauind + 1;
+                  diagVec = diagVec + tauVec(tauind) * diagVecG_T;
+                  tauind = tauind + 1;
+                }
+
+        }
+
+        for(unsigned int i=0; i< Nnomissing; i++){
+                if(diagVec(i) < 1e-4){
+                        diagVec(i) = 1e-4 ;
+                }
+        }
+
+        return(diagVec);
+}
+
+
+// [[Rcpp::export]]
+arma::fcolvec getCrossprod_largeMem_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
 
         arma::fcolvec crossProdVec;
         // Added by SLEE, 04/16/2017
@@ -2254,6 +2433,150 @@ arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::f
 
 
 
+// [[Rcpp::export]]
+arma::fcolvec getCrossprod_multiV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+
+        arma::fcolvec crossProdVec;
+        // Added by SLEE, 04/16/2017
+        if(tauVec(1) == 0 && tauVec.n_elem == 2){
+                crossProdVec = tauVec(0)*(bVec % (1/wVec));
+                return(crossProdVec);
+        }
+        //
+        arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+
+        unsigned int tau_ind = 0;
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){ //it must have specified GRM
+                if(g_isGRM){
+                  crossProd1 = getCrossprodMatAndKin(bVec, LOCO);
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+                }else{
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec));
+                  tau_ind = tau_ind + 1;
+                }
+        }else{
+                if(g_isGRM){
+                  Ibvec = g_I_longl_mat.t() * bVec;
+                  GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                  crossProd1 = g_I_longl_mat * GRM_I_bvec;
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+                }else{
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec));
+                  tau_ind = tau_ind + 1;
+                }
+
+
+                if(g_T_longl_mat.n_rows > 0){
+                        Tbvec = g_T_longl_mat.t() * bVec;
+                        if(g_isGRM){
+                          GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                          crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                          crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+                          crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdGRM_TGIb + crossProdGRM_IGTb);
+                          tau_ind = tau_ind + 1;
+                          crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * GRM_T_bvec);
+                          tau_ind = tau_ind + 1;
+                        }
+                }
+
+        }
+
+
+        if(g_T_longl_mat.n_rows == 0 && g_I_longl_mat.n_rows == 0){
+
+                if(Kmat_vec.size() > 0){
+                        for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                                crossProdVec  = crossProdVec + tauVec(tau_ind)*(Kmat_vec[i] * bVec);
+                                tau_ind = tau_ind + 1;
+                        }
+                }
+
+        }else{ //if(g_T_longl_mat.n_rows == 0 && g_I_longl_mat.n_rows == 0){
+                crossProdVec  = crossProdVec + tauVec(tau_ind) * (g_I_longl_mat * Ibvec);
+                tau_ind = tau_ind + 1;
+
+                if(g_T_longl_mat.n_rows > 0){
+                        crossProdGRM_TIb = g_T_longl_mat * Ibvec;
+                        crossProdGRM_ITb = g_I_longl_mat * Tbvec;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdGRM_TIb + crossProdGRM_ITb);
+                        tau_ind = tau_ind + 1;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * Tbvec);
+                        tau_ind = tau_ind + 1;
+                        //crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                        //crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+                }
+
+
+                if(Kmat_vec.size() > 0){
+                        for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                                V_I_bvec = Kmat_vec[i] * Ibvec;
+                                crossProdVec  = crossProdVec + tauVec(tau_ind) * (g_I_longl_mat * V_I_bvec);
+                                tau_ind = tau_ind + 1;
+                                if(g_T_longl_mat.n_rows > 0){
+                                        V_T_bvec = Kmat_vec[i] * Tbvec;
+                                        crossProdV_TGIb = g_T_longl_mat * V_I_bvec;
+                                        crossProdV_IGTb = g_I_longl_mat * V_T_bvec;
+                                        crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdV_TGIb + crossProdV_IGTb);
+                                        tau_ind = tau_ind + 1;
+                                        crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * V_T_bvec);
+                                        tau_ind = tau_ind + 1;
+                                }
+                        }
+                }
+
+        }
+        return(crossProdVec);
+}
+
+
+
+
+// [[Rcpp::export]]
+arma::fcolvec getCrossprod_noV(arma::fcolvec& bVec, arma::fvec& wVec, arma::fvec& tauVec, bool LOCO){
+
+        arma::fcolvec crossProdVec;
+        // Added by SLEE, 04/16/2017
+        if(tauVec(1) == 0 && tauVec.n_elem == 2){
+                crossProdVec = tauVec(0)*(bVec % (1/wVec));
+                return(crossProdVec);
+        }
+        //
+        arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+
+        unsigned int tau_ind = 0;
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){ //it must have specified GRM
+                  crossProd1 = getCrossprodMatAndKin(bVec, LOCO);
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+        }else{
+                  Ibvec = g_I_longl_mat.t() * bVec;
+                  GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                  crossProd1 = g_I_longl_mat * GRM_I_bvec;
+                  crossProdVec = tauVec(0)*(bVec % (1/wVec)) + tauVec(1)*crossProd1;
+                  tau_ind = tau_ind + 2;
+
+
+                if(g_T_longl_mat.n_rows > 0){
+                        Tbvec = g_T_longl_mat.t() * bVec;
+                        GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                        crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                        crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (crossProdGRM_TGIb + crossProdGRM_IGTb);
+                        tau_ind = tau_ind + 1;
+                        crossProdVec = crossProdVec + tauVec(tau_ind) * (g_T_longl_mat * GRM_T_bvec);
+                        tau_ind = tau_ind + 1;
+                }
+
+        }
+
+        return(crossProdVec);
+}
+
+
+
+
 
 
 double get_wall_time(){
@@ -2285,10 +2608,8 @@ arma::sp_mat gen_sp_GRM() {
 
 
 // [[Rcpp::export]]
-arma::sp_mat gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
+arma::sp_fmat gen_sp_Sigma_largeMem_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
    arma::fvec dtVec = (1/wVec) * (tauVec(0));
-
-
    std::cout << "tauVec(0) " << tauVec(0) << std::endl;
 
 //   dtVec.print();
@@ -2313,7 +2634,7 @@ arma::sp_mat gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
     arma::sp_mat result(locationMat, valueVecNew, dimNum, dimNum);
 
 */
-   arma::sp_mat result = g_spGRM * tauVec(1);
+   arma::sp_fmat result = g_spGRM * tauVec(1);
    //std::cout << "tauVec(1) " << tauVec(1) << std::endl;
    //std::cout << "g_spGRM(1775,1775) " << g_spGRM(1775,1775) << std::endl;
    result.diag() = result.diag() + dtVec;   
@@ -2325,8 +2646,6 @@ arma::sp_mat gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
 	//std::cout << "Kmat_vec[i] " << Kmat_vec[i](1775,1775) << std::endl;
       }	      
     }
-
-
 //    std::cout << "result.n_rows " << result.n_rows << std::endl;
 //    std::cout << "result.n_cols " << result.n_cols << std::endl;
     //result.print();
@@ -2336,6 +2655,95 @@ arma::sp_mat gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
 }
 
 
+
+
+// [[Rcpp::export]]
+void gen_sp_Sigma_multiV(arma::fvec& wVec,  arma::fvec& tauVec){
+   arma::fvec dtVec = (1/wVec) * (tauVec(0));
+   arma::sp_fmat GRM_Imat, GRM_Tmat;
+   arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+   unsigned int tau_ind = 0;
+   //arma::sp_fmat g_spGRM_f = arma::conv_to< arma::sp_fmat >::from(g_spGRM);
+
+   if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+       if(g_isGRM && g_isSparseGRM){
+         g_spSigma = g_spGRM * tauVec(1);
+         g_spSigma.diag() = g_spSigma.diag() + dtVec;
+         tau_ind = tau_ind + 2;
+        }else{
+          g_spSigma.zeros(wVec.n_elem, wVec.n_elem);
+          g_spSigma.diag() = g_spSigma.diag() + dtVec;
+          tau_ind = tau_ind + 1;
+        }
+   }else{
+       if(g_isGRM && g_isSparseGRM){
+         GRM_Imat = g_spGRM * (g_I_longl_mat.t());
+         g_spSigma = g_I_longl_mat * GRM_Imat;
+         g_spSigma = g_spSigma * tauVec(1);
+         g_spSigma.diag() = g_spSigma.diag() + dtVec;
+         tau_ind = tau_ind + 2;
+         if(g_T_longl_mat.n_rows > 0){
+           GRM_Tmat = g_spGRM * (g_T_longl_mat.t());
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * GRM_Imat + g_I_longl_mat * GRM_Tmat);
+           tau_ind = tau_ind + 1;
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * GRM_Tmat);
+           tau_ind = tau_ind + 1;
+         }
+       }else{
+         g_spSigma.zeros(wVec.n_elem, wVec.n_elem);
+         g_spSigma.diag() = g_spSigma.diag() + dtVec;
+         tau_ind = tau_ind + 1;
+        }
+   }
+
+
+   if(g_T_longl_mat.n_rows == 0 && g_I_longl_mat.n_rows == 0){
+        if(Kmat_vec.size() > 0){
+             for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                     g_spSigma = g_spSigma + tauVec(tau_ind)*(Kmat_vec[i]);
+                     tau_ind = tau_ind + 1;
+             }
+         }
+   }else{
+       g_spSigma = g_spSigma + tauVec(tau_ind) * g_I_longl_mat * (g_I_longl_mat.t());
+       tau_ind = tau_ind + 1;
+
+       if(g_T_longl_mat.n_rows > 0){
+
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * (g_I_longl_mat.t()) + g_I_longl_mat * (g_T_longl_mat.t()));
+           tau_ind = tau_ind + 1;
+           g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * (g_T_longl_mat.t()));
+           tau_ind = tau_ind + 1;
+                        //crossProdGRM_TGIb = g_T_longl_mat * GRM_I_bvec;
+                        //crossProdGRM_IGTb = g_I_longl_mat * GRM_T_bvec;
+       }
+
+       if(Kmat_vec.size() > 0){
+           for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                GRM_Imat = Kmat_vec[i] * (g_I_longl_mat.t());
+                g_spSigma = g_spSigma + tauVec(tau_ind) * (g_I_longl_mat * GRM_Imat);
+                tau_ind = tau_ind + 1;
+                if(g_T_longl_mat.n_rows > 0){
+                        GRM_Tmat = Kmat_vec[i] * (g_T_longl_mat.t());
+                        g_spSigma = g_spSigma + tauVec(tau_ind) * ((g_T_longl_mat * GRM_Imat) + (g_I_longl_mat * GRM_Tmat));
+                        tau_ind = tau_ind + 1;
+                        g_spSigma = g_spSigma + tauVec(tau_ind) * (g_T_longl_mat * GRM_Tmat);
+                        tau_ind = tau_ind + 1;
+                }
+           }
+        }
+
+   }
+
+    //return g_spSigma;
+}
+
+
+
+
+
+/*
 // [[Rcpp::export]]
 arma::fvec gen_spsolve_v4_multiV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec & yvec){
 
@@ -2380,12 +2788,12 @@ arma::fvec gen_spsolve_v4_multiV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fv
     return z;
 }
 
+*/
 
 //bool isUsePrecondM = false;
 //bool isUseSparseSigmaforInitTau = false;
 
 
-
 // [[Rcpp::export]]
 void setisUsePrecondM(bool isUseSparseSigmaforPCG){
 	isUsePrecondM = isUseSparseSigmaforPCG;
@@ -2404,195 +2812,107 @@ void setisUseSparseSigmaforNullModelFitting(bool isUseSparseSigmaforModelFitting
 }
 
 
-//Modified on 11-28-2018 to allow for a preconditioner for CG (the sparse Sigma)                                                                                                                                     //Sigma = tau[1] * diag(1/W) + tau[2] * kins + tau[3] * V3 + .....
-//This function needs the function getDiagOfSigma and function getCrossprod
 
 // [[Rcpp::export]]
-arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO){       
+arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO){
     // Start Timers
     double wall0 = get_wall_time();
     double cpu0  = get_cpu_time();
-    int Nnomissing = geno.getNnomissing();
+    int Nnomissing = wVec.n_elem;
     arma::fvec xVec(Nnomissing);
     xVec.zeros();
-    
-    if(isUseSparseSigmaforInitTau){
-	cout << "use sparse kinship to estimate initial tau " <<  endl;
-	xVec = gen_spsolve_v4_multiV(wVec, tauVec, bVec);
-    }else if(isUseSparseSigmaforModelFitting){
-	cout << "use sparse kinship to fit the model " << endl;
-        xVec = gen_spsolve_v4_multiV(wVec, tauVec, bVec);
+
+    if(g_isStoreSigma){
+        std::cout << " arma::spsolve(g_spSigma, bVec) 0" << std::endl;
+        xVec = arma::spsolve(g_spSigma, bVec);
+        std::cout << " arma::spsolve(g_spSigma, bVec) 1" << std::endl;
     }else{
         arma::fvec rVec = bVec;
         arma::fvec r1Vec;
-        //cout << "HELLOb: "  << endl;
-        //int Nnomissing = geno.getNnomissing();
-        //cout << "HELL1: "  << endl;
         arma::fvec crossProdVec(Nnomissing);
-        //arma::SpMat<float> precondM = sparseGRMinC;
         arma::fvec zVec(Nnomissing);
         arma::fvec minvVec(Nnomissing);
- //     double wall1 = get_wall_time();
- //     double cpu1  = get_cpu_time();
-
-//      cout << "Wall Time 1= " << wall1 - wall0 << endl;
-//      cout << "CPU Time 1 = " << cpu1  - cpu0  << endl;
-        if (!isUsePrecondM){
-	    double wall1_gDiag = get_wall_time();
-	    double cpu1_gDiag  = get_cpu_time();
-/*		for(int i = 0; i < 10; i++){
-                	cout << "wVec[i]: " << i << " " << wVec[i] << endl;
-                	cout << "bVec[i]: " << i << " " << bVec[i] << endl;
-        	}
-*/
-	    minvVec = 1/getDiagOfSigma_multiV(wVec, tauVec, LOCO);
-	    //	for(int i = 0; i < 10; i++){
-          //      	cout << "minvVec[i]: " << i << " " << minvVec[i] << endl;
-        //	}
-
-	    double wall1_gDiag_2 = get_wall_time();
-	    double cpu1_gDiag_2  = get_cpu_time();
-//		 cout << "Wall Time getDiagOfSigma = " << wall1_gDiag_2 - wall1_gDiag << endl;
-// cout << "CPU Time getDiagOfSigma = " << cpu1_gDiag_2 - cpu1_gDiag  << endl;
-            zVec = minvVec % rVec;
+        minvVec = 1/getDiagOfSigma_multiV(wVec, tauVec, LOCO);
+        zVec = minvVec % rVec;
 
-        }else{
-//      std::chrono::steady_clock::time_point end= std::chrono::steady_clock::now();
-//        std::cout << "Time difference = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() <<std::endl;
-	     zVec = gen_spsolve_v4_multiV(wVec, tauVec, rVec);
-                //sparseGRMinC = (sparseGRMinC) * (tauVec(1));
-                //arma::fvec dtVec = (1/wVec) * (tauVec(0));
-                //(sparseGRMinC).diag() = (sparseGRMinC).diag() + dtVec;
-                //zVec = gen_spsolve_v4(sparseGRMinC, rVec) ;
-        }
-// double wall1 = get_wall_time();
-// double cpu1  = get_cpu_time();
-// cout << "Wall Time 1 = " << wall1 - wall0 << endl;
-// cout << "CPU Time 1 = " << cpu1  - cpu0  << endl;
-
-
-//      cout << "HELL3: "  << endl;
-      //for(int i = 0; i < 10; i++){
-       //         cout << "zVec[i]: " << zVec[i] << endl;
-        //}
         float sumr2 = sum(rVec % rVec);
-
-/*
-        if(bVec[0] == 1 && bVec[99] == 1){
-        for(int i = 0; i < 100; i++){
-                cout << "rVec[i]: " << i << " " << rVec[i] << endl;
-                cout << "minvVec[i]: " << i << " " << minvVec[i] << endl;
-                cout << "wVec[i]: " << i << " " << wVec[i] << endl;
-        }
-        }
-*/
         arma::fvec z1Vec(Nnomissing);
         arma::fvec pVec = zVec;
-        /*
-        if(bVec[0] == 1 && bVec[2] == 1){
-        for(int i = 0; i < 10; i++){
-                cout << "pVec[i]: " << i << " " << pVec[i] << endl;
-        }
-        }
-*/
-        //arma::fvec xVec(Nnomissing);
-        //xVec.zeros();
 
         int iter = 0;
         while (sumr2 > tolPCG && iter < maxiterPCG) {
-// double wall2 = get_wall_time();
-//        double cpu2  = get_cpu_time();
-
-//    cout << "Wall Time 2= " << wall2 - wall1 << endl;
-//    cout << "CPU Time 2 = " << cpu2  - cpu1  << endl;
-
-
-
                 iter = iter + 1;
                 arma::fcolvec ApVec = getCrossprod_multiV(pVec, wVec, tauVec, LOCO);
-//		for(int i = 0; i < 10; i++){
-//                	cout << "ApVec[i]: " << i << " " << ApVec[i] << endl;
-//        	}
                 arma::fvec preA = (rVec.t() * zVec)/(pVec.t() * ApVec);
-// double wall3 = get_wall_time();
-//        double cpu3  = get_cpu_time();
 
-//    cout << "Wall Time 3= " << wall3 - wall2 << endl;
-//    cout << "CPU Time 3 = " << cpu3  - cpu2  << endl;
                 float a = preA(0);
+                xVec = xVec + a * pVec;
+                r1Vec = rVec - a * ApVec;
+                z1Vec = minvVec % r1Vec;
 
-/*           if(bVec[0] == 1 && bVec[2] == 1){
-                        cout << "bVec[0] == 1 && bVec[2] == 1: " << endl;
-                        for(int i = 0; i < 10; i++){
+                arma::fvec Prebet = (z1Vec.t() * r1Vec)/(zVec.t() * rVec);
+                float bet = Prebet(0);
+                pVec = z1Vec+ bet*pVec;
+                zVec = z1Vec;
+                rVec = r1Vec;
+                sumr2 = sum(rVec % rVec);
+        }
 
-                                cout << "ApVec[i]: " << i << " " << ApVec[i] << endl;
-                                cout << "pVec[i]: " << i << " " << pVec[i] << endl;
-                                cout << "zVec[i]: " << i << " " << zVec[i] << endl;
-                                cout << "rVec[i]: " << i << " " << rVec[i] << endl;
-                        }
-                    }
-*/
+        if (iter >= maxiterPCG){
+                cout << "pcg did not converge. You may increase maxiter number." << endl;
 
-                xVec = xVec + a * pVec;
-/*
-                if(bVec[0] == 1 && bVec[2] == 1){
-                        for(int i = 0; i < 10; i++){
-                                cout << "xVec[i]: " << i << " " << xVec[i] << endl;
-                        }
-                }
+        }
+        cout << "iter from getPCG1ofSigmaAndVector " << iter << endl;
+}
+        return(xVec);
+}
 
-*/
 
 
-                r1Vec = rVec - a * ApVec;
-/*
-                if(bVec[0] == 1 && bVec[2] == 1){
-                        cout << "a: " << a  << endl;
-                        for(int i = 0; i < 10; i++){
-                                cout << "ApVec[i]: " << i << " " << ApVec[i] << endl;
-                                cout << "rVec[i]: " << i << " " << rVec[i] << endl;
-                                cout << "r1Vec[i]: " << i << " " << r1Vec[i] << endl;
-                        }
-                }
-*/
-//                z1Vec = minvVec % r1Vec;
-// double wall3a = get_wall_time();
-//       double cpu3a  = get_cpu_time();
+// [[Rcpp::export]]
+arma::fvec getPCG1ofSigmaAndVector_noV(arma::fvec& wVec,  arma::fvec& tauVec, arma::fvec& bVec, int maxiterPCG, float tolPCG, bool LOCO){
+    // Start Timers
+    double wall0 = get_wall_time();
+    double cpu0  = get_cpu_time();
+    int Nnomissing = wVec.n_elem;
+    arma::fvec xVec(Nnomissing);
+    xVec.zeros();
 
-        if (!isUsePrecondM){
-                z1Vec = minvVec % r1Vec;
-        }else{
-		z1Vec = gen_spsolve_v4_multiV(wVec, tauVec, r1Vec);
-                //z1Vec = arma::spsolve(sparseGRMinC, r1Vec) ;
-        }
+    if(g_isStoreSigma){
+        std::cout << " arma::spsolve(g_spSigma, bVec) 0" << std::endl;
+        //xVec = arma::spsolve(g_spSigma, bVec);
+	xVec = arma::spsolve(g_spSigma_noV, bVec);
+        std::cout << " arma::spsolve(g_spSigma, bVec) 1" << std::endl;
+    }else{
+        arma::fvec rVec = bVec;
+        arma::fvec r1Vec;
+        arma::fvec crossProdVec(Nnomissing);
+        arma::fvec zVec(Nnomissing);
+        arma::fvec minvVec(Nnomissing);
+        minvVec = 1/getDiagOfSigma_noV(wVec, tauVec, LOCO);
+        zVec = minvVec % rVec;
 
-//       double wall3b = get_wall_time();
-//       double cpu3b  = get_cpu_time();
-// cout << "Wall Time 3b = " << wall3b - wall3a << endl;
-// cout << "CPU Time 3b = " << cpu3b  - cpu3a  << endl;
+        float sumr2 = sum(rVec % rVec);
+        arma::fvec z1Vec(Nnomissing);
+        arma::fvec pVec = zVec;
 
+        int iter = 0;
+        while (sumr2 > tolPCG && iter < maxiterPCG) {
+                iter = iter + 1;
+                arma::fcolvec ApVec = getCrossprod_noV(pVec, wVec, tauVec, LOCO);
+                arma::fvec preA = (rVec.t() * zVec)/(pVec.t() * ApVec);
+
+                float a = preA(0);
+                xVec = xVec + a * pVec;
+                r1Vec = rVec - a * ApVec;
+                z1Vec = minvVec % r1Vec;
 
                 arma::fvec Prebet = (z1Vec.t() * r1Vec)/(zVec.t() * rVec);
                 float bet = Prebet(0);
                 pVec = z1Vec+ bet*pVec;
                 zVec = z1Vec;
                 rVec = r1Vec;
-
-// double wall4 = get_wall_time();
-//        double cpu4  = get_cpu_time();
-
-//    cout << "Wall Time 4= " << wall4 - wall3 << endl;
-//    cout << "CPU Time 4 = " << cpu4  - cpu3  << endl;
-
                 sumr2 = sum(rVec % rVec);
-                //        std::cout << "sumr2: " << sumr2 << std::endl;
-                //        std::cout << "tolPCG: " << tolPCG << std::endl;
-/*
-                if(bVec[0] == 1 && bVec[2] == 1){
-                        std::cout << "sumr2: " << sumr2 << std::endl;
-                        std::cout << "tolPCG: " << tolPCG << std::endl;
-                }
-*/
         }
 
         if (iter >= maxiterPCG){
@@ -2600,19 +2920,12 @@ arma::fvec getPCG1ofSigmaAndVector_multiV(arma::fvec& wVec,  arma::fvec& tauVec,
 
         }
         cout << "iter from getPCG1ofSigmaAndVector " << iter << endl;
-} //else if(isUseSparseKinforInitTau){
-//  double wall5 = get_wall_time();
-//    double cpu5  = get_cpu_time();
-//    cout << "Wall Time getPCG1ofSigmaAndVector = " << wall5 - wall0 << endl;
-//    cout << "CPU Time  getPCG1ofSigmaAndVector = " << cpu5  - cpu0  << endl;
-
-
-//      std::chrono::steady_clock::time_point end= std::chrono::steady_clock::now();
-//        std::cout << "Time difference = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() <<std::endl;
+}
         return(xVec);
 }
 
 
+
 //http://thecoatlessprofessor.com/programming/set_rs_seed_in_rcpp_sequential_case/
 // [[Rcpp::export]]
 void set_seed(unsigned int seed) {
@@ -2720,6 +3033,16 @@ arma::fvec  getSigma_G_multiV(arma::fvec& wVec, arma::fvec& tauVec,arma::fvec& G
 }
 
 
+// [[Rcpp::export]]
+arma::fvec  getSigma_G_noV(arma::fvec& wVec, arma::fvec& tauVec,arma::fvec& Gvec, int maxiterPCG, float tolPCG, bool LOCO){
+        arma::fvec Sigma_iG;
+        Sigma_iG = getPCG1ofSigmaAndVector_noV(wVec, tauVec, Gvec, maxiterPCG, tolPCG, LOCO);
+        return(Sigma_iG);
+}
+
+
+
+
 //http://gallery.rcpp.org/articles/parallel-inner-product/
 struct CorssProd_usingSubMarker : public Worker
 {
@@ -3876,7 +4199,7 @@ Rcpp::List getCoefficients_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec
 
 
 // [[Rcpp::export]]
-arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec & fixtauVec, arma::fmat& cov1,  int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){		
+arma::fvec GetTrace_largeMem_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec & fixtauVec, arma::fmat& cov1,  int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){		
 		
   	set_seed(200);
 	
@@ -4015,18 +4338,348 @@ arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wV
 
 
 
+
+// [[Rcpp::export]]
+// [[Rcpp::export]]
+arma::fvec GetTrace_multiV(arma::fmat Sigma_iX, arma::fmat& Xmat, arma::fvec& wVec, arma::fvec& tauVec, arma::ivec & fixtauVec, arma::fmat& cov1,  int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){
+
+        set_seed(200);
+
+        int q2 = arma::sum(fixtauVec==0);
+        arma::uvec idxtau = arma::find(fixtauVec==0);
+
+        idxtau.print("idxtau");
+
+        arma::fmat Sigma_iXt = Sigma_iX.t();
+        int Nnomissing = wVec.n_elem;;
+        //unsigned int k = Kmat_vec.size();
+        //unsigned int k1 = k + 2;
+        unsigned int  k1 = g_num_Kmat;
+        arma::fmat temp_mat(nrun, k1);
+        arma::fmat temp_mat_update(nrun, q2);
+        arma::fvec temp_vec(nrun);
+        arma::fvec temp_vec_double(Nnomissing);
+        temp_mat.zeros();
+        temp_mat_update.zeros();
+
+        arma::fvec Sigma_iu;
+        arma::fvec Pu;
+        arma::fmat Au_mat(Nnomissing, k1);
+        arma::fvec uVec;
+        NumericVector uVec0;
+
+        int nrun_trace_start = 0;
+        int nrun_trace_end = nrun;
+        arma::fvec traceCV(q2);
+        traceCV.fill(traceCVcutoff + 0.1);
+
+        arma::uvec covarianceidxVec;
+        arma::fvec traceCVsub;
+        arma::uvec indexsubvec =  { 1, 2 };
+        if(g_covarianceidxMat.n_cols > 0){
+             covarianceidxVec = arma::vectorise(g_covarianceidxMat.cols(indexsubvec));
+             covarianceidxVec = covarianceidxVec - 1;
+        }
+        bool isConverge = false;
+        //while((traceCV > cutoff_trace) | (traceCV0 > cutoff_trace)){
+        //while( arma::any(traceCV > traceCVcutoff) ){
+        //
+        //
+        arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+        while( !isConverge ){
+                for(int i = nrun_trace_start; i < nrun_trace_end; i++){
+
+                        uVec0 = nb(Nnomissing);
+                        uVec = as<arma::fvec>(uVec0);
+                        uVec = uVec*2 - 1;
+                        Sigma_iu = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, uVec, maxiterPCG, tolPCG, LOCO);
+                        Pu = Sigma_iu - Sigma_iX * (cov1 *  (Sigma_iXt * uVec));
+
+                        if(fixtauVec(0) == 0)   {
+                                Au_mat.col(0) = uVec;
+                                temp_mat(i,0) = dot(Au_mat.col(0), Pu);
+                        }
+                        // conversion for ops with sp_mat
+                     if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                        if(fixtauVec(1) == 0){
+                                if(g_isGRM){
+                                        temp_vec_double = getCrossprodMatAndKin(uVec, LOCO);
+                                }else{
+                                        if(Kmat_vec.size() > 0){
+                                                temp_vec_double = 0.0+Kmat_vec[0] * uVec;
+                                        }
+                                }
+                                Au_mat.col(1) = temp_vec_double;
+                                temp_mat(i,1) = dot(temp_vec_double, Pu);
+                        }
+
+
+                        if(g_isGRM){
+                          for(int j=2; j<k1;j++){
+                                if(fixtauVec(j) == 0){
+                                        Au_mat.col(j) = 0.0+Kmat_vec[j-2] * uVec;
+                                        temp_mat(i,j) = dot(Au_mat.col(j), Pu);
+                                }
+                          } // end for j in 2:k1
+                        }else{
+                          for(int j=2; j<k1;j++){
+                                if(fixtauVec(j) == 0){
+                                        Au_mat.col(j) = 0.0+Kmat_vec[j-1] * uVec;
+                                        temp_mat(i,j) = dot(Au_mat.col(j), Pu);
+                                }
+                          } // end for j in 1:k1
+
+                        }
+                   }else{
+                        Ibvec = g_I_longl_mat.t() * uVec;
+                        if(g_isGRM){
+                                GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                        }
+                        if(g_T_longl_mat.n_rows == 0){
+                           if(g_isGRM){
+                                if(fixtauVec(1) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * GRM_I_bvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(2) == 0){
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                for(int j=3; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                V_I_bvec = Kmat_vec[j-3] * Ibvec;
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                }
+                           }else{
+
+                                if(fixtauVec(1) == 0){
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                for(int j=2; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                V_I_bvec = Kmat_vec[j-2] * Ibvec;
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                }
+                           }
+                        }else{
+                             Tbvec = g_T_longl_mat.t() * uVec;
+                             if(g_isGRM){
+                                        GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                                if(fixtauVec(1) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * GRM_I_bvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(2) == 0)   {
+                                        temp_vec_double = (g_I_longl_mat * GRM_T_bvec) + (g_T_longl_mat * GRM_I_bvec);
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(3) == 0)   {
+                                        temp_vec_double = g_T_longl_mat * GRM_T_bvec;
+                                        Au_mat.col(3) = temp_vec_double;
+                                        temp_mat(i,3) = dot(temp_vec_double, Pu);
+					                                }
+
+                                 if(fixtauVec(4) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(4) = temp_vec_double;
+                                        temp_mat(i,4) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(5) == 0)   {
+                                        temp_vec_double = (g_I_longl_mat * Tbvec) + (g_T_longl_mat * Ibvec);
+                                        Au_mat.col(5) = temp_vec_double;
+                                        temp_mat(i,5) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(6) == 0)   {
+                                        temp_vec_double = g_T_longl_mat * Tbvec;
+                                        Au_mat.col(6) = temp_vec_double;
+                                        temp_mat(i,6) = dot(temp_vec_double, Pu);
+                                }
+
+
+                                int j = 7;
+                                while(j < k1){
+                                        V_I_bvec = Kmat_vec[j-7] * Ibvec;
+                                        V_T_bvec = Kmat_vec[j-7] * Tbvec;
+                                //for(int j=7; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = (g_I_longl_mat * V_T_bvec) + (g_T_longl_mat * V_I_bvec);
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_T_longl_mat * V_T_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+
+                                        }
+                                        j = j + 1;
+                                }
+
+                        }else{// if(g_isGRM){
+
+
+                                 if(fixtauVec(1) == 0)   {
+                                        temp_vec_double = g_I_longl_mat * Ibvec;
+                                        Au_mat.col(1) = temp_vec_double;
+                                        temp_mat(i,1) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(2) == 0)   {
+                                        temp_vec_double = (g_I_longl_mat * Tbvec) + (g_T_longl_mat * Ibvec);
+                                        Au_mat.col(2) = temp_vec_double;
+                                        temp_mat(i,2) = dot(temp_vec_double, Pu);
+                                }
+
+                                if(fixtauVec(3) == 0)   {
+                                        temp_vec_double = g_T_longl_mat * Tbvec;
+                                        Au_mat.col(3) = temp_vec_double;
+                                        temp_mat(i,3) = dot(temp_vec_double, Pu);
+                                }
+
+
+                                int j = 4;
+                                while(j < k1){
+                                        V_I_bvec = Kmat_vec[j-4] * Ibvec;
+                                        V_T_bvec = Kmat_vec[j-4] * Tbvec;
+                                //for(int j=7; j<k1;j++){
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_I_longl_mat * V_I_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = (g_I_longl_mat * V_T_bvec) + (g_T_longl_mat * V_I_bvec);
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+                                        }
+                                        j = j + 1;
+
+                                        if(fixtauVec(j) == 0){
+                                                temp_vec_double = g_T_longl_mat * V_T_bvec;
+                                                Au_mat.col(j) = temp_vec_double;
+                                                temp_mat(i,j) = dot(temp_vec_double, Pu);
+
+                                        }
+                                        j = j + 1;
+                                }
+
+
+
+                        }//}else{// if(g_isGRM){
+                }
+
+        }
+
+
+
+                        uVec.clear();
+                        Pu.clear();
+                        Sigma_iu.clear();
+
+                } // end for i
+                temp_mat_update = temp_mat.cols(idxtau);
+
+                std::cout << "dim temp_mat_update" << temp_mat_update.n_rows << " " << temp_mat_update.n_cols << std::endl;;
+                // update trace cv vector
+                for(int k=0; k<q2; k++){
+                        temp_vec = temp_mat_update.col(k);
+                        traceCV(k) = calCV(temp_vec);
+                }
+                //traceCV.print("traceCV");
+                //traceCVcutoff = 1.0;
+                // if not converge, increase nrun_trace and rerun
+                //temp_mat.print("temp_mat");
+                //
+
+                if(g_covarianceidxMat.n_cols > 0){
+                        traceCVsub = traceCV.elem(covarianceidxVec);
+                        //if(arma::any(traceCVsub > traceCVcutoff)){
+                        if(arma::any(traceCV > traceCVcutoff)){
+                                isConverge = false;
+                        }else{
+                                isConverge = true;
+				                        }
+                }else{
+                        if( arma::any(traceCV > traceCVcutoff) ){
+                                isConverge = false;
+                        }else{
+                                isConverge = true;
+                        }
+                }
+
+
+
+                if( !isConverge){
+                        nrun_trace_start = nrun_trace_end;
+                        nrun_trace_end = nrun_trace_end + 10;
+                        temp_mat.resize(nrun_trace_end,k1);
+                        temp_mat_update.resize(nrun_trace_end,q2);
+                        //std::cout << "arma::mean(temp_mat0): " << arma::mean(temp_mat0) << std::endl;
+                        Rcout << "CV for trace random estimator using "<< nrun_trace_start << " runs is " << traceCV <<  " > " << traceCVcutoff << std::endl;
+                        Rcout << "try " << nrun_trace_end << "runs" << std::endl;
+                } // end if arma::any(traceCV > traceCVcutoff)
+
+        } // end while  arma::any(traceCV > traceCVcutoff)
+        Au_mat.clear();
+        Pu.clear();
+        Sigma_iu.clear();
+        uVec.clear();
+        temp_vec.clear();
+
+        arma::fvec traVec(q2);
+        for(int i=0; i<q2; i++){
+                traVec(i) = arma::mean(temp_mat_update.col(i));
+        }
+        temp_mat.clear();
+        temp_mat_update.clear();
+        return(traVec);
+}
+
+
+
+
+
+
 // [[Rcpp::export]]
-Rcpp::List getAIScore_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, arma::ivec & fixtauVec, 
+Rcpp::List getAIScore_largeMem_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, arma::ivec & fixtauVec, 
 arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
 int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){
 
-
 	int q2 = arma::sum(fixtauVec==0);
 	arma::uvec idxtau = arma::find(fixtauVec==0);
 	//int ncol_x = X.n_cols;
 	arma::fvec tau0;
-	unsigned int k = Kmat_vec.size();
-	unsigned int k1 = k + 2;	
+	//unsigned int k = Kmat_vec.size();
+	//unsigned int k1 = k + 2;	
+	unsigned int k1 = idxtau.size();
 	arma::fmat AI(k1,k1);
 	arma::fvec YPAPY(k1);
 	YPAPY.zeros();
@@ -4096,6 +4749,249 @@ int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){
 }
 
 
+
+
+// [[Rcpp::export]]
+Rcpp::List getAIScore_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec& wVec,  arma::fvec& tauVec, arma::ivec & fixtauVec,
+arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
+int nrun, int maxiterPCG, float tolPCG, float traceCVcutoff, bool LOCO){
+
+        std::cout << "getAIScore_multiV " << getAIScore_multiV << std::endl;
+        int q2 = arma::sum(fixtauVec==0);
+        arma::uvec idxtau = arma::find(fixtauVec==0);
+        arma::fvec tau0;
+        unsigned int k1 = g_num_Kmat;
+        arma::fmat AI(k1,k1);
+        arma::fvec YPAPY(k1);
+        YPAPY.zeros();
+        arma::fvec Trace(k1);
+        Trace.zeros();
+        std::cout << "k1 " << k1 << std::endl;
+        arma::fmat Sigma_iXt = Sigma_iX.t();
+        arma::fmat Xmatt = Xmat.t();
+
+        //Sigma_iY.print("Sigma_iY");
+        //Sigma_iX.print("Sigma_iX");
+        //cov.print("cov");
+        //Sigma_iXt.print("Sigma_iXt");
+        //Yvec.print("Yvec");
+
+        arma::fvec PY1 = Sigma_iY - Sigma_iX * (cov * (Sigma_iXt * Yvec));
+
+        //PY1.print("PY1");
+        //arma::fvec APY = getCrossprodMatAndKin(PY1);
+        //float YPAPY = dot(PY1, APY);
+        //arma::fvec A0PY = PY1; ////Quantitative
+        //float YPA0PY = dot(PY1, A0PY); ////Quantitative
+        //arma::fvec Trace = GetTrace_q(Sigma_iX, Xmat, wVec, tauVec, cov1, nrun, maxiterPCG, tolPCG, traceCVcutoff);
+        unsigned int n = PY1.n_elem;
+        //arma::fvec PA0PY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, A0PY, maxiterPCG, tolPCG);
+        //arma::fvec PA0PY = PA0PY_1 - Sigma_iX * (cov1 * (Sigma_iXt * PA0PY_1));
+        arma::fvec PAPY_1, PAPY,  APY;
+        arma::fmat APYmat(n, k1);
+
+        //if(q2>0){
+        //
+        arma::fvec crossProd1, GRM_I_bvec, Ibvec, Tbvec, GRM_T_bvec, crossProdGRM_TGIb, crossProdGRM_IGTb, V_I_bvec, V_T_bvec, crossProdV_TGIb, crossProdV_IGTb, crossProdGRM_TIb, crossProdGRM_ITb;
+
+
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+                for(int i=0; i<k1; i++){
+                    if(fixtauVec(i) == 0){
+                        if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+                                if(g_isGRM){
+                                        APY = getCrossprodMatAndKin(PY1, LOCO);
+                                }else{
+                                        if(Kmat_vec.size() > 0){
+                                                APY = Kmat_vec[0]*PY1;
+                                        }
+                                }
+                        }else{
+                                if(g_isGRM){
+                                        if(Kmat_vec.size() > 0){
+                                                APY = Kmat_vec[i-2]*PY1;
+                                        }
+                                }else{
+                                        if(Kmat_vec.size() > 0){
+                                                APY = Kmat_vec[i-1]*PY1;
+                                        }
+                                }
+                        }
+                        APYmat.col(i) = APY;
+                        PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG, LOCO);
+                        PAPY = PAPY_1 - Sigma_iX * (cov * (Sigma_iXt * PAPY_1));
+                        for(int j=0; j<=i; j++){
+                                AI(i,j) = arma::dot(APYmat.col(j), PAPY);
+                                if(j !=i){
+                                        AI(j,i) = AI(i,j);
+                                }
+                        }
+                        YPAPY(i) = arma::dot(PY1, APYmat.col(i));
+                     }
+                }
+        }else{
+               Ibvec = g_I_longl_mat.t() * PY1;
+                std::cout << "Ibvec.n_elem " << Ibvec.n_elem << std::endl;
+
+                if(g_isGRM){
+                        GRM_I_bvec = getCrossprodMatAndKin(Ibvec, LOCO);
+                }
+
+                std::cout << "g_I_longl_mat.n_rows " << g_I_longl_mat.n_rows << std::endl;
+               if(g_T_longl_mat.n_rows == 0){
+                  for(int i=0; i<k1; i++){
+                    if(fixtauVec(i) == 0){
+                        if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+                                if(g_isGRM){
+                                  std::cout << "GRM_I_bvec.n_elem " << GRM_I_bvec.n_elem << std::endl;
+                                  APY = g_I_longl_mat * GRM_I_bvec;
+                                }else{
+                                  APY = g_I_longl_mat * Ibvec;
+                                }
+                        }else if (i == 2){
+                                if(g_isGRM){
+                                  APY = g_I_longl_mat * Ibvec;
+                                }else{
+                                  if(Kmat_vec.size() > 0){
+                                        V_I_bvec = Kmat_vec[0]*Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                  }
+                                }
+                                //APY = Kmat_vec[i-2]*PY1;
+                        }else{
+                             if(g_isGRM){
+                                if(Kmat_vec.size() > 0){
+                                        V_I_bvec = Kmat_vec[i-3]*Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }
+                             }else{
+                                if(Kmat_vec.size() > 0){
+                                        V_I_bvec = Kmat_vec[i-2]*Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }
+                             }
+
+                        }
+                        APYmat.col(i) = APY;
+                        PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG, LOCO);
+                        PAPY = PAPY_1 - Sigma_iX * (cov * (Sigma_iXt * PAPY_1));
+                        for(int j=0; j<=i; j++){
+                                AI(i,j) = arma::dot(APYmat.col(j), PAPY);
+                                if(j !=i){
+                                        AI(j,i) = AI(i,j);
+                                }
+                        }
+                        YPAPY(i) = arma::dot(PY1, APYmat.col(i));
+                     }
+                  }
+
+                }else{
+                  Tbvec = g_T_longl_mat.t() * PY1;
+                  if(g_isGRM){
+                    GRM_T_bvec = getCrossprodMatAndKin(Tbvec, LOCO);
+                  }
+
+                  unsigned int kmatind = 0;
+                  for(int i=0; i<k1; i++){
+                    if(fixtauVec(i) == 0){
+                     if(g_isGRM){
+                        if(i==0){
+				                                APY = PY1;
+                        }else if(i==1){
+                                APY = g_I_longl_mat * GRM_I_bvec;
+                        }else if(i == 2){
+                                APY = (g_T_longl_mat * GRM_I_bvec) + (g_I_longl_mat * GRM_T_bvec);
+                        }else if(i == 3){
+                                APY = g_T_longl_mat * GRM_T_bvec;
+
+                        }else if(i == 4){
+                                APY = g_I_longl_mat * Ibvec;
+                        }else if(i == 5){
+
+                                APY = (g_T_longl_mat * Ibvec) + (g_I_longl_mat * Tbvec);
+
+                        }else if(i == 6){
+                                APY = g_T_longl_mat * Tbvec;
+
+                        }else{
+                                if(i % 3 == 1){
+                                        V_I_bvec = Kmat_vec[kmatind] * Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }else if(i % 3 == 2){
+                                        V_T_bvec = Kmat_vec[kmatind] * Tbvec;
+                                        APY = (g_T_longl_mat * V_I_bvec) + (g_I_longl_mat * V_T_bvec);
+                                }else if(i % 3 == 0){
+                                        APY = g_T_longl_mat * V_T_bvec;
+                                        kmatind = kmatind + 1;
+
+                                }
+                        }
+                     }else{ //if(g_isGRM){
+                        if(i==0){
+                                APY = PY1;
+                        }else if(i==1){
+                                APY = g_I_longl_mat * Ibvec;
+                        }else if(i == 2){
+                                APY = (g_T_longl_mat * Ibvec) + (g_I_longl_mat * Tbvec);
+                        }else if(i == 3){
+                                APY = g_T_longl_mat * Tbvec;
+
+                        }else{
+                                if(i % 3 == 1){
+                                        V_I_bvec = Kmat_vec[kmatind] * Ibvec;
+                                        APY = g_I_longl_mat * V_I_bvec;
+                                }else if(i % 3 == 2){
+                                        V_T_bvec = Kmat_vec[kmatind] * Tbvec;
+                                        APY = (g_T_longl_mat * V_I_bvec) + (g_I_longl_mat * V_T_bvec);
+                                }else if(i % 3 == 0){
+                                        APY = g_T_longl_mat * V_T_bvec;
+                                        kmatind = kmatind + 1;
+
+                                }
+                        }
+
+
+
+                     }//else for if(g_isGRM){
+                        APYmat.col(i) = APY;
+                        PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG, LOCO);
+                        PAPY = PAPY_1 - Sigma_iX * (cov * (Sigma_iXt * PAPY_1));
+                        for(int j=0; j<=i; j++){
+                                AI(i,j) = arma::dot(APYmat.col(j), PAPY);
+                                if(j !=i){
+                                        AI(j,i) = AI(i,j);
+                                }
+                        }
+                                                YPAPY(i) = arma::dot(PY1, APYmat.col(i));
+                     }
+                  }
+
+                }
+        }
+
+        AI.print("AI");
+        arma::fmat AI_update = AI.submat(idxtau, idxtau);
+        arma::fvec YPAPY_update = YPAPY.elem(idxtau);
+
+        //vector with length=q2
+        Trace = GetTrace_multiV(Sigma_iX, Xmat, wVec, tauVec, fixtauVec, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO);
+        YPAPY_update.print("YPAPY_update");
+        Trace.print("Trace");
+        //arma::fvec PAPY_1 = getPCG1ofSigmaAndVector_multiV(wVec, tauVec, APY, maxiterPCG, tolPCG);
+        //arma::fvec PAPY = PAPY_1 - Sigma_iX * (cov1 * (Sigma_iXt * PAPY_1));
+        return Rcpp::List::create(Named("YPAPY") = YPAPY_update, Named("Trace") = Trace,Named("PY") = PY1,Named("AI") = AI_update);
+}
+
+
+
+
+
+
+
 arma::ivec updatefixrhoidx0(arma::fvec & t_tau0Vec, float tol){
 	arma::ivec fixrhoidx0Vec(g_covarianceidxMat.n_rows);
 	arma::uvec covarianceidxVec;
@@ -4144,18 +5040,19 @@ arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
 int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOCO){
 	Function warning("warning");
 
-	unsigned int k = Kmat_vec.size();
-        unsigned int k1 = k + 2;
+	//unsigned int k = Kmat_vec.size();
+        //unsigned int k1 = k + 2;
+        unsigned int k1 = g_num_Kmat;
 
 	int q2 = arma::sum(fixtauVec==0);
 	arma::uvec idxtau = arma::find(fixtauVec==0);
 	arma::fvec tau0 = tauVec;
 
 
-	//std::cout << "check 1" << std::endl;
+	std::cout << "check 1" << std::endl;
 	Rcpp::List re = getAIScore_multiV(Yvec, Xmat,wVec,  tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO);
 
-	//std::cout << "check 2" << std::endl;
+	std::cout << "check 2" << std::endl;
 
 	arma::fvec YPAPY = re["YPAPY"];
 	arma::fvec Trace = re["Trace"];
@@ -4202,18 +5099,18 @@ int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOC
 	arma::uvec covarianceidxVec1, covarianceidxVec_sub1, covarianceidxVec2, covarianceidxVec_sub2,covarianceidxVec3, covarianceidxVec_sub3;	
 
 	if(g_covarianceidxMat.n_rows == 0){
-		tauVec.elem( arma::find(tauVec < tol) ).zeros();
+		tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
 		float step = 1.0;
 		while ( arma::any(tauVec < 0.0) ){
 			step = step*0.5;
 			tauVec = tau0 + step*Dtau_k1;
+	 		tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
 	 	} // end while
-
-	 	tauVec.elem( arma::find(tauVec < tol) ).zeros();
+		tauVec.elem( arma::find(tauVec < tol) ).zeros();
 	}else{
 		fixrhoidx0 = updatefixrhoidx0(tau0, tol);
 		tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
-		tauVec.elem(g_covarianceidxMat_col1) = tau0.elem(g_covarianceidxMat_col1);
+		tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
 		fixrhoidx = updatefixrhoidx0(tauVec, tol);
 		covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
 		covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
@@ -4228,7 +5125,7 @@ int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOC
                         step = step*0.5;
                         tauVec = tau0 + step*Dtau_k1;
 			tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
-                	tauVec.elem(g_covarianceidxMat_col1) = tau0.elem(g_covarianceidxMat_col1);
+                	tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
 			fixrhoidx = updatefixrhoidx0(tauVec, tol);
                 	covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
                 	covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
@@ -4238,14 +5135,239 @@ int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOC
 			tauupdateidx = tauUpdateValue(tauVec);
 			Rcpp::checkUserInterrupt();
                 } // end while
-		tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
-                tauVec.elem(g_covarianceidxMat_col1) = tau0.elem(g_covarianceidxMat_col1);
-		covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx == 1));
-		covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx == 1));
-		covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx == 1));
+		tauVec.elem( arma::find(tauVec < tol) ).zeros();
+                tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+		//covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx == 1));
+		//covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx == 1));
+		//covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx == 1));
 		tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
                 tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
 	}	
 	 return List::create(Named("tau") = tauVec, Named("AI") = AI1, Named("score") = score1);
 }	
 
+
+
+
+// [[Rcpp::export]]
+Rcpp::List fitglmmaiRPCG_largeMem_multiV(arma::fvec& Yvec, arma::fmat& Xmat, arma::fvec &wVec,  arma::fvec & tauVec, arma::ivec & fixtauVec,
+arma::fvec& Sigma_iY, arma::fmat & Sigma_iX, arma::fmat & cov,
+int nrun, int maxiterPCG, float tolPCG, float tol, float traceCVcutoff, bool LOCO){
+        Function warning("warning");
+
+        unsigned int k = Kmat_vec.size();
+        unsigned int k1 = k + 2;
+
+        int q2 = arma::sum(fixtauVec==0);
+        arma::uvec idxtau = arma::find(fixtauVec==0);
+        arma::fvec tau0 = tauVec;
+
+
+        std::cout << "check 1" << std::endl;
+        Rcpp::List re = getAIScore_multiV(Yvec, Xmat,wVec,  tauVec, fixtauVec, Sigma_iY, Sigma_iX, cov, nrun, maxiterPCG, tolPCG, traceCVcutoff, LOCO);
+
+        std::cout << "check 2" << std::endl;
+
+        arma::fvec YPAPY = re["YPAPY"];
+        arma::fvec Trace = re["Trace"];
+        arma::fvec score1 = YPAPY - Trace;
+        YPAPY.print("YPAPY");
+        Trace.print("Trace");
+        arma::fmat AI1 = re["AI"];
+        arma::fvec Dtau(AI1.n_cols);
+        score1.print("score");
+        try{
+                Dtau = arma::solve(AI1, score1, arma::solve_opts::allow_ugly);
+        }
+        catch(std::runtime_error){
+                std::cout << "arma::solve(AI, score): AI seems singular, using less variant components matrix is suggested." << std::endl;
+                Dtau.zeros();
+        }
+        //std::cout << "check 3" << std::endl;
+        Dtau.print("Dtau");
+        score1.print("score1");
+        AI1.print("AI1");
+        //
+        //
+        arma::fvec Dtau_k1(k1);
+        Dtau_k1.zeros();
+
+        std::cout << "k1 " << k1 << std::endl;
+        fixtauVec.print("fixtauVec");
+
+        // fill dtau using dtau_pre, padding 0
+        int i2 = 0;
+        for(int i=0; i<k1; i++){
+                std::cout << "i " << i << std::endl;
+                if(fixtauVec(i)==0){ // not fixed
+                        Dtau_k1(i) = Dtau(i2);
+                        i2++;
+                }
+        } // end for i
+        Dtau_k1.print("Dtau_k1");
+        tau0 = tauVec;
+        tauVec = tauVec + Dtau_k1;
+        arma::fvec tauVecabs;
+        arma::ivec fixrhoidx0, fixrhoidx, tauupdateidx;
+        //arma::ivec fixrhoidx0, fixrhoidx, covarianceidxVec1, covarianceidxVec_sub1, covarianceidxVec2, covarianceidxVec_sub2,covarianceidxVec3, covarianceidxVec_sub3, tauupdateidx;
+        arma::uvec covarianceidxVec1, covarianceidxVec_sub1, covarianceidxVec2, covarianceidxVec_sub2,covarianceidxVec3, covarianceidxVec_sub3;
+
+        if(g_covarianceidxMat.n_rows == 0){
+                tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                float step = 1.0;
+                while ( arma::any(tauVec < 0.0) ){
+                        step = step*0.5;
+                        tauVec = tau0 + step*Dtau_k1;
+                        tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                } // end while
+                tauVec.elem( arma::find(tauVec < tol) ).zeros();
+        }else{
+                fixrhoidx0 = updatefixrhoidx0(tau0, tol);
+                tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+                fixrhoidx = updatefixrhoidx0(tauVec, tol);
+                covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+                tauupdateidx = tauUpdateValue(tauVec);
+                float step = 1.0;
+                 while ( arma::any(tauVec.elem(g_covarianceidxMat_notcol1) < 0.0) || tauVec(0) < 0.0 || arma::any(tauupdateidx == 0)){
+                 tauVec.print("tauVec");
+                 tauupdateidx.print("tauupdateidx");
+                        step = step*0.5;
+                        tauVec = tau0 + step*Dtau_k1;
+                        tauVec.elem( arma::find(tauVec < tol && tau0 < tol) ).zeros();
+                        tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+                        fixrhoidx = updatefixrhoidx0(tauVec, tol);
+                        covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                        covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                        covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx0 == 1 && fixrhoidx == 1));
+                        tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                        tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+                        tauupdateidx = tauUpdateValue(tauVec);
+                        Rcpp::checkUserInterrupt();
+                } // end while
+                tauVec.elem( arma::find(tauVec < tol) ).zeros();
+                tauVec.elem(g_covarianceidxMat_col1) = tauVec.elem(g_covarianceidxMat_col1);
+                //covarianceidxVec_sub1 = g_covarianceidxMat_col1.elem(arma::find(fixrhoidx == 1));
+                //covarianceidxVec_sub2 = g_covarianceidxMat_col2.elem(arma::find(fixrhoidx == 1));
+                //covarianceidxVec_sub3 = g_covarianceidxMat_col3.elem(arma::find(fixrhoidx == 1));
+                tauVecabs = tauVec.elem(covarianceidxVec_sub1) / arma::abs(tauVec.elem(covarianceidxVec_sub1));
+                tauVec.elem(covarianceidxVec_sub1) = tauVecabs % (arma::sqrt(tauVec.elem(covarianceidxVec_sub2) % tauVec.elem(covarianceidxVec_sub3)));
+        }
+         return List::create(Named("tau") = tauVec, Named("AI") = AI1, Named("score") = score1);
+}
+
+
+
+
+// [[Rcpp::export]]
+arma::fvec getMeanDiagofKmat(bool LOCO){
+        arma::fvec mean_diag_kins_vec(g_num_Kmat - 1);
+        arma::sp_vec diagVecG0;
+        arma::sp_fvec diagVecV0;
+        arma::fvec diagVecG, diagVecV, diagVecG_I, diagVecG_T, diagVecG_IT,diagVecV_I, diagVecV_T, diagVecV_IT;
+        arma::fvec diagVec;
+        unsigned int tauind = 0;
+        if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+
+        if(g_isGRM){
+           if(!LOCO){
+              if(!g_isSparseGRM){
+                int MminMAF = ptr_gNULLGENOobj->getnumberofMarkerswithMAFge_minMAFtoConstructGRM();
+                diagVec = (*ptr_gNULLGENOobj->Get_Diagof_StdGeno()) /MminMAF;
+              }else{
+                diagVec = arma::diagvec(g_spGRM);
+              }
+            }else{
+              diagVec = (*ptr_gNULLGENOobj->Get_Diagof_StdGeno_LOCO());
+              int Msub_MAFge_minMAFtoConstructGRM_in_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_in();
+              int Msub_MAFge_minMAFtoConstructGRM_singleVar_b = ptr_gNULLGENOobj->getMsub_MAFge_minMAFtoConstructGRM_singleChr_in();
+              diagVec = diagVec/(Msub_MAFge_minMAFtoConstructGRM_in_b - Msub_MAFge_minMAFtoConstructGRM_singleVar_b);
+            }
+           mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+           tauind = tauind + 1
+          }
+
+          if(Kmat_vec.size() > 0){
+            for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+              diagVec = (Kmat_vec[i]).diag();
+              mean_diag_kins_vec(i+tauind) = arma::mean(diagVec);
+            }
+          }
+
+        }else{ //if(g_I_longl_mat.n_rows == 0 && g_T_longl_mat.n_rows == 0){
+            if(g_isGRM && g_isSparseGRM){
+                diagVecG = arma::diagvec(g_spGRM);
+                diagVecG_I = diagVecG.elem(g_I_longl_vec);
+                diagVec = diagVecG_I;
+                mean_diag_kins_vec(0) = arma::mean(diagVec);
+                tauind = tauind + 1;
+            }
+
+            if(g_T_longl_mat.n_rows > 0){
+                if(g_isGRM && g_isSparseGRM){
+                  diagVecG_IT = diagVecG_I % g_T_longl_vec;
+                  diagVecG_T = diagVecG_IT % g_T_longl_vec;
+                  diagVecG_IT = 2 * diagVecG_IT;
+                  diagVec = diagVecG_IT;
+                  std::cout << "Here1" << std::endl;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+                  std::cout << "Here2" << std::endl;
+                  diagVec = diagVecG_T;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+                }
+
+                  diagVecV = diagVecG;
+                  diagVecV.ones();
+                  diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                  diagVec = diagVecV_I;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+                  diagVecV_IT = diagVecV_I % g_T_longl_vec;
+                  diagVecV_T = diagVecV_IT % g_T_longl_vec;
+                  diagVecV_IT = 2 * diagVecV_IT;
+                  diagVec = diagVecV_IT;
+
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+                  std::cout << "Here2" << std::endl;
+                  diagVec = diagVecV_T;
+                  mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                  tauind = tauind + 1;
+
+
+           }
+
+                if(Kmat_vec.size() > 0){
+                  for(unsigned int i = 0; i < Kmat_vec.size(); i++){
+                    diagVecV0 = Kmat_vec[i].diag();
+                    arma::fvec diagVecVtemp(diagVecV0);
+                    diagVecV = diagVecVtemp;
+                    diagVecV_I = diagVecV.elem(g_I_longl_vec);
+                    diagVec = diagVecV_I;
+                    mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                    tauind = tauind + 1;
+                    if(g_T_longl_mat.n_rows > 0){
+                      diagVecV_IT = diagVecV_I % g_T_longl_vec;
+                      diagVecV_T = diagVecV_IT % g_T_longl_vec;
+                      diagVecV_IT = 2 * diagVecV_IT;
+                      diagVec = diagVecV_IT;
+                      mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                      tauind = tauind + 1;
+                      diagVec = diagVecV_T;
+                      mean_diag_kins_vec(tauind) = arma::mean(diagVec);
+                      tauind = tauind + 1;
+                    }
+                  }
+                }
+
+        }
+
+        return(mean_diag_kins_vec);
+}
+
